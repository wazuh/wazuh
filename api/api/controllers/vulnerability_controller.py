# Copyright (C) 2015-2021, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

import logging

from aiohttp import web

from api.encoder import dumps, prettify
from api.util import parse_api_param, remove_nones_to_dict, raise_if_exc
from wazuh import vulnerability
from wazuh.core.cluster.dapi.dapi import DistributedAPI

logger = logging.getLogger('wazuh-api')


async def get_vulnerability_agent(request, pretty=False, wait_for_complete=False, agent_id=None, offset=0, limit=None,
                                  sort=None, search=None, select=None, q='', distinct=None, architecture=None, cve=None,
                                  name=None, version=None, type=None, status=None, severity=None):
    """Get agents' vulnerabilities.

    Parameters
    ----------
    pretty : bool
        Show results in human-readable format.
    wait_for_complete : bool
        Disable timeout response.
    agent_id : str
        ID of the agent to retrieve CVE info.
    offset : int
        First element to return in the collection.
    limit : int
        Maximum number of elements to return.
    sort : str
        Sort the collection by a field or fields (separated by comma). Use +/- at the beginning to list in
        ascending or descending order.
    search : str
        Look for elements with the specified string.
    select : list
        Fields to return.
    q : str
        Query to filter results by.
    distinct : bool
        Look for distinct values.
    architecture : str
        Filter by architecture.
    cve : str
        Filter by CVE ID.
    name : str
        Filter by package ID.
    version : str
        Filter by version.
    type : str
        Filter by CVE type.
    status : str
        Filter by CVE status.
    severity : str
        Filter by CVE severity.

    Returns
    -------
    web.json_response
    """
    f_kwargs = {
        'agent_list': [agent_id],
        'offset': offset,
        'limit': limit,
        'sort': parse_api_param(sort, 'sort'),
        'search': parse_api_param(search, 'search'),
        'select': select,
        'q': q,
        'distinct': distinct,
        'filters': {
            'architecture': architecture,
            'cve': cve,
            'name': name,
            'version': version,
            'status':  status,
            'type': type,
            'severity': severity
        }
    }

    dapi = DistributedAPI(f=vulnerability.get_agent_cve,
                          f_kwargs=remove_nones_to_dict(f_kwargs),
                          request_type='distributed_master',
                          is_async=False,
                          wait_for_complete=wait_for_complete,
                          logger=logger,
                          rbac_permissions=request['token_info']['rbac_policies']
                          )
    data = raise_if_exc(await dapi.distribute_function())

    return web.json_response(data=data, status=200, dumps=prettify if pretty else dumps)


async def get_last_scan_agent(request, pretty=False, wait_for_complete=False, agent_id=None):
    """Return when the last full and partial vulnerability scan of a specified agent end.

    Parameters
    ----------
    pretty : bool
        Show results in human-readable format.
    wait_for_complete : bool
        Disable timeout response.
    agent_id : str
        ID of the agent to retrieve scans info.

    Returns
    -------
    web.json_response
    """
    f_kwargs = {'agent_list': [agent_id]}

    dapi = DistributedAPI(f=vulnerability.last_scan,
                          f_kwargs=remove_nones_to_dict(f_kwargs),
                          request_type='distributed_master',
                          is_async=False,
                          wait_for_complete=wait_for_complete,
                          logger=logger,
                          rbac_permissions=request['token_info']['rbac_policies']
                          )
    data = raise_if_exc(await dapi.distribute_function())

    return web.json_response(data=data, status=200, dumps=prettify if pretty else dumps)
