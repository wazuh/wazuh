/*
 * Copyright (C) 2015, Wazuh Inc.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <cmocka.h>
#include <time.h>

#include "shared.h"
#include "../wazuh_modules/wmodules.h"
#include "../wazuh_modules/wm_vulnerability_scanner.h"

#include "../scheduling/wmodules_scheduling_helpers.h"

#include "../config/global-config.h"

#include "../../wrappers/libc/stdio_wrappers.h"

char * test_path;

extern int __real_ReadConfig(int modules, const char *cfgfile, void *d1, void *d2);
int __wrap_ReadConfig(int modules, const char *cfgfile, void *d1, __attribute__((unused)) void *d2) {
    check_expected(modules);
    check_expected(cfgfile);
    return __real_ReadConfig(modules, test_path, d1, NULL);
}

typedef struct test_struct {
    wm_vulnerability_scanner_t *vulnerability_scanner_config;
} test_struct_t;

static int setup_test_read(void **state) {
    test_structure *test;
    os_calloc(1, sizeof(test_structure), test);
    test->module = NULL;
    *state = test;
    return 0;
}

static int teardown_test_read(void **state) {
    test_structure *test = *state;
    OS_ClearNode(test->nodes);
    OS_ClearXML(&(test->xml));
    if(test->module) {
        if (test->module->data) {
            if (((wm_vulnerability_scanner_t*)test->module->data)->vulnerability_detection) {
                cJSON_Delete(((wm_vulnerability_scanner_t*)test->module->data)->vulnerability_detection);
            }
            os_free(test->module->data);
        }
        os_free(test->module->tag);
        os_free(test->module);
    }
    os_free(test);
    return 0;
}

void test_read_custom_cti_url_full_configuration(void **state) {
    const char *string =
        "<enabled>yes</enabled>"
        "<index-status>no</index-status>"
        "<feed-update-interval>60m</feed-update-interval>"
        "<offline-url>file:///var/algo.tar.gz</offline-url>"
    ;
    test_structure *test = *state;
    test->nodes = string_to_xml_node(string, &(test->xml));

    test_path = "test_global.conf";

    expect_value(__wrap_ReadConfig, modules, CGLOBAL);
    expect_string(__wrap_ReadConfig, cfgfile, OSSECCONF);

    assert_int_equal(Read_Vulnerability_Detection(&(test->xml), test->nodes, &(test->module)), 0);
    wm_vulnerability_scanner_t *module_data = (wm_vulnerability_scanner_t*)test->module->data;
    char * json_result = cJSON_PrintUnformatted(module_data->vulnerability_detection);
    assert_string_equal(json_result, "{\"enabled\":\"yes\",\"index-status\":\"no\",\"feed-update-interval\":\"60m\",\"offline-url\":\"file:///var/algo.tar.gz\",\"cti-url\":\"random.cti.url.com\"}");
    cJSON_free(json_result);
}

void test_read_empty_configuration(void **state) {
    const char *string = "";
    test_structure *test = *state;
    test->nodes = string_to_xml_node(string, &(test->xml));
    assert_int_equal(Read_Vulnerability_Detection(&(test->xml), test->nodes, &(test->module)), 0);
    wm_vulnerability_scanner_t *module_data = (wm_vulnerability_scanner_t*)test->module->data;
    char * json_result = cJSON_PrintUnformatted(module_data->vulnerability_detection);
    assert_string_equal(json_result, "{}");
    cJSON_free(json_result);
}

void test_read_empty_field_default_cti_url_configuration(void **state) {
    const char *string =
        "<enabled>yes</enabled>"
        "<index-status>no</index-status>"
        "<feed-update-interval></feed-update-interval>"
        "<offline-url>file:///var/algo.tar.gz</offline-url>"
    ;
    test_structure *test = *state;
    test->nodes = string_to_xml_node(string, &(test->xml));

    test_path = "test_global_no_cti_url.conf";

    expect_value(__wrap_ReadConfig, modules, CGLOBAL);
    expect_string(__wrap_ReadConfig, cfgfile, OSSECCONF);

    assert_int_equal(Read_Vulnerability_Detection(&(test->xml), test->nodes, &(test->module)), 0);
    wm_vulnerability_scanner_t *module_data = (wm_vulnerability_scanner_t*)test->module->data;
    char * json_result = cJSON_PrintUnformatted(module_data->vulnerability_detection);
    assert_string_equal(json_result, "{\"enabled\":\"yes\",\"index-status\":\"no\",\"feed-update-interval\":\"\",\"offline-url\":\"file:///var/algo.tar.gz\",\"cti-url\":\"cti.wazuh.com\"}");
    cJSON_free(json_result);
}

int main(void) {
    const struct CMUnitTest tests_configuration[] = {
        cmocka_unit_test_setup_teardown(test_read_custom_cti_url_full_configuration, setup_test_read, teardown_test_read),
        cmocka_unit_test_setup_teardown(test_read_empty_configuration, setup_test_read, teardown_test_read),
        cmocka_unit_test_setup_teardown(test_read_empty_field_default_cti_url_configuration, setup_test_read, teardown_test_read),
    };
    return cmocka_run_group_tests(tests_configuration, NULL, NULL);
}
