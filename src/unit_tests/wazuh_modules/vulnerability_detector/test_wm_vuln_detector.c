/*
 * Copyright (C) 2015-2020, Wazuh Inc.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <cmocka.h>
#include <stdio.h>

#include "../../wazuh_modules/wmodules.h"
#include "../../headers/shared.h"

int pkg_version_compare(const struct pkg_version *a, const struct pkg_version *b);
bool pkg_version_relate(const struct pkg_version *a, enum pkg_relation rel, const struct pkg_version *b, version_type vertype);
void wm_vuldet_free_agent_software(agent_software *agent);
int wm_vuldet_get_oslinux_info(agent_software *agent);
int wm_vuldet_generate_os_and_kernel_package(sqlite3 *db, agent_software *agent);

/* setup/teardown */

static int setup_versions(void **state) {
    struct pkg_version *version_a;
    struct pkg_version *version_b;

    os_calloc(1, sizeof(version_a), version_a);
    os_calloc(1, sizeof(version_b), version_b);

    if(!version_a || !version_b) {
        return -1;
    }

    state[0] = version_a;
    state[1] = version_b;

    return 0;
}

static int setup_agent_software(void **state) {
    agent_software *agent = calloc(1, sizeof(agent_software));

    if(!agent) {
        return -1;
    }

    agent->agent_id = strdup("000");
    *state = agent;

    return 0;
}

static int teardown_versions(void **state) {
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    if(version_a) {
        free(version_a);
    }

    if(version_b) {
        free(version_b);
    }

    return 0;
}

static int teardown_agent_software(void **state) {
    agent_software *agent = *state;

    if(agent) {
        wm_vuldet_free_agent_software(agent);
    }

    return 0;
}

/* redefinitons/wrapping */

void __wrap__mterror(const char *tag, const char * file, int line, const char * func, const char *msg, ...) {
    char formatted_msg[OS_MAXSTR];
    va_list args;

    check_expected(tag);

    va_start(args, msg);
    vsnprintf(formatted_msg, OS_MAXSTR, msg, args);
    va_end(args);

    check_expected(formatted_msg);
}

void __wrap__mtdebug1(const char *tag, const char * file, int line, const char * func, const char *msg, ...) {
    char formatted_msg[OS_MAXSTR];
    va_list args;

    check_expected(tag);

    va_start(args, msg);
    vsnprintf(formatted_msg, OS_MAXSTR, msg, args);
    va_end(args);

    check_expected(formatted_msg);
}

void __wrap__mtdebug2(const char *tag, const char * file, int line, const char * func, const char *msg, ...) {
    char formatted_msg[OS_MAXSTR];
    va_list args;

    check_expected(tag);

    va_start(args, msg);
    vsnprintf(formatted_msg, OS_MAXSTR, msg, args);
    va_end(args);

    check_expected(formatted_msg);
}

int __wrap_OS_ConnectUnixDomain(const char *path, int type, int max_msg_size) {
    check_expected(path);
    check_expected(type);
    check_expected(max_msg_size);

    return mock();
}

int __wrap_OS_SendSecureTCP(int sock, uint32_t size, const void * msg) {
    check_expected(sock);
    check_expected(size);
    check_expected(msg);

    return mock();
}

int __wrap_OS_RecvSecureTCP(int sock, char * ret, uint32_t size) {
    check_expected(sock);
    check_expected(size);

    strncpy(ret, mock_type(char*), size);

    return mock();
}

int __wrap_close() {
    return 1;
}

int __wrap_sqlite3_prepare_v2() {
    return mock();
}

int __wrap_sqlite3_bind_text(sqlite3_stmt* pStmt, int a, const char* b, int c, void *d) {
    check_expected(a);
    if (b) check_expected(b);

    return mock();
}

int __wrap_sqlite3_bind_int(sqlite3_stmt* pStmt, int a, int b) {
    check_expected(a);
    check_expected(b);

    return mock();
}

int __wrap_sqlite3_step() {
    return mock();
}

int __wrap_sqlite3_close_v2() {
    return mock();
}

int __wrap_sqlite3_finalize() {
    return mock();
}

const char *__wrap_sqlite3_errmsg(){
    return mock_ptr_type(const char *);
}

/* tests */

void test_pkg_version_relate_epoch_NONE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 1;
    version_a->version = "";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GT, version_b, VER_TYPE_NONE);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_epoch_VER_TYPE_unknown(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 1;
    version_a->version = "";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "";
    version_b->revision = "";

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "unknown version_type 4");

    int ret = pkg_version_relate(version_a, PKG_RELATION_GT, version_b, 4);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_epoch_RELATION_unknown(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 1;
    version_a->version = "";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "";
    version_b->revision = "";

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "unknown pkg_relation 6");

    int ret = pkg_version_relate(version_a, 6, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_epoch_GT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 1;
    version_a->version = "";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GT, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_epoch_GE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 1;
    version_a->version = "";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GE, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_epoch_EQ(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 1;
    version_a->version = "";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_EQ, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_epoch_LE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 1;
    version_a->version = "";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LE, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_epoch_LT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 1;
    version_a->version = "";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LT, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_version_deb_GT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GT, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_version_deb_GE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GE, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_version_deb_EQ(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_EQ, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_version_deb_LE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LE, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_version_deb_LT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LT, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_version_rpm_GT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GT, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_version_rpm_GE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GE, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_version_rpm_EQ(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_EQ, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_version_rpm_LE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LE, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_version_rpm_LT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "";
    version_b->epoch = 0;
    version_b->version = "4.18.1";
    version_b->revision = "";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LT, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_revision_deb_GT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "2+2ubuntu1.2";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2+2ubuntu1.1";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GT, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_revision_deb_GE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "2+2ubuntu1.2";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2+2ubuntu1.1";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GE, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_revision_deb_EQ(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "2+2ubuntu1.2";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2+2ubuntu1.1";

    int ret = pkg_version_relate(version_a, PKG_RELATION_EQ, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_revision_deb_LE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "2+2ubuntu1.2";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2+2ubuntu1.1";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LE, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_revision_deb_LT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "2+2ubuntu1.2";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2+2ubuntu1.1";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LT, version_b, VER_TYPE_DEB);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_revision_rpm_GT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "12.9";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2.el8";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GT, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_revision_rpm_GE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "12.9";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2.el8";

    int ret = pkg_version_relate(version_a, PKG_RELATION_GE, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 1);
}

void test_pkg_version_relate_revision_rpm_EQ(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "12.9";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2.el8";

    int ret = pkg_version_relate(version_a, PKG_RELATION_EQ, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_revision_rpm_LE(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "12.9";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2.el8";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LE, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 0);
}

void test_pkg_version_relate_revision_rpm_LT(void **state)
{
    struct pkg_version *version_a = state[0];
    struct pkg_version *version_b = state[1];

    version_a->epoch = 0;
    version_a->version = "5.3.0.45";
    version_a->revision = "12.9";
    version_b->epoch = 0;
    version_b->version = "5.3.0.45";
    version_b->revision = "2.el8";

    int ret = pkg_version_relate(version_a, PKG_RELATION_LT, version_b, VER_TYPE_RPM);
    assert_int_equal(ret, 0);
}

void test_wm_vuldet_get_oslinux_info(void **state)
{
    agent_software *agent = *state;

    const char *query = "agent 000 sql SELECT OS_VERSION, RELEASE FROM SYS_OSINFO;";
    size_t query_size = strlen(query) + 1;

    char *response = "ok [{\"os_version\":\"10.0.1\",\"release\":\"4.5.1\"}]";
    size_t response_size = strlen(response) + 1;

    expect_string(__wrap_OS_ConnectUnixDomain, path, WDB_LOCAL_SOCK_PATH);
    expect_value(__wrap_OS_ConnectUnixDomain, type, SOCK_STREAM);
    expect_value(__wrap_OS_ConnectUnixDomain, max_msg_size, OS_SIZE_6144);
    will_return(__wrap_OS_ConnectUnixDomain, 11111);

    expect_value(__wrap_OS_SendSecureTCP, sock, 11111);
    expect_value(__wrap_OS_SendSecureTCP, size, query_size);
    expect_string(__wrap_OS_SendSecureTCP, msg, query);
    will_return(__wrap_OS_SendSecureTCP, 0);

    expect_value(__wrap_OS_RecvSecureTCP, sock, 11111);
    expect_value(__wrap_OS_RecvSecureTCP, size, OS_SIZE_128);
    will_return(__wrap_OS_RecvSecureTCP, response);
    will_return(__wrap_OS_RecvSecureTCP, response_size);

    int ret = wm_vuldet_get_oslinux_info(agent);

    assert_int_equal(ret, 0);
    assert_string_equal(agent->os_release, "10.0.1");
    assert_string_equal(agent->kernel_release, "4.5.1");
}

void test_wm_vuldet_get_oslinux_info_only_version(void **state)
{
    agent_software *agent = *state;

    const char *query = "agent 000 sql SELECT OS_VERSION, RELEASE FROM SYS_OSINFO;";
    size_t query_size = strlen(query) + 1;

    char *response = "ok [{\"os_version\":\"10.0.1 LTS\"}]";
    size_t response_size = strlen(response) + 1;

    expect_value(__wrap_OS_SendSecureTCP, sock, 11111);
    expect_value(__wrap_OS_SendSecureTCP, size, query_size);
    expect_string(__wrap_OS_SendSecureTCP, msg, query);
    will_return(__wrap_OS_SendSecureTCP, 0);

    expect_value(__wrap_OS_RecvSecureTCP, sock, 11111);
    expect_value(__wrap_OS_RecvSecureTCP, size, OS_SIZE_128);
    will_return(__wrap_OS_RecvSecureTCP, response);
    will_return(__wrap_OS_RecvSecureTCP, response_size);

    int ret = wm_vuldet_get_oslinux_info(agent);

    assert_int_equal(ret, 0);
    assert_string_equal(agent->os_release, "10.0.1");
    assert_null(agent->kernel_release);
}

void test_wm_vuldet_get_oslinux_info_only_release(void **state)
{
    agent_software *agent = *state;

    const char *query = "agent 000 sql SELECT OS_VERSION, RELEASE FROM SYS_OSINFO;";
    size_t query_size = strlen(query) + 1;

    char *response = "ok [{\"release\":\"4.5.1-4\"}]";
    size_t response_size = strlen(response) + 1;

    expect_value(__wrap_OS_SendSecureTCP, sock, 11111);
    expect_value(__wrap_OS_SendSecureTCP, size, query_size);
    expect_string(__wrap_OS_SendSecureTCP, msg, query);
    will_return(__wrap_OS_SendSecureTCP, 0);

    expect_value(__wrap_OS_RecvSecureTCP, sock, 11111);
    expect_value(__wrap_OS_RecvSecureTCP, size, OS_SIZE_128);
    will_return(__wrap_OS_RecvSecureTCP, response);
    will_return(__wrap_OS_RecvSecureTCP, response_size);

    int ret = wm_vuldet_get_oslinux_info(agent);

    assert_int_equal(ret, 0);
    assert_null(agent->os_release);
    assert_string_equal(agent->kernel_release, "4.5.1");
}

void test_wm_vuldet_get_oslinux_info_null_agent(void **state)
{
    (void) state;

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "(5580): The agent structure is not initialized.");

    int ret = wm_vuldet_get_oslinux_info(NULL);

    assert_int_equal(ret, -1);
}

void test_wm_vuldet_get_oslinux_info_request_invalid(void **state)
{
    agent_software *agent = *state;

    const char *query = "agent 000 sql SELECT OS_VERSION, RELEASE FROM SYS_OSINFO;";
    size_t query_size = strlen(query) + 1;

    expect_value(__wrap_OS_SendSecureTCP, sock, 11111);
    expect_value(__wrap_OS_SendSecureTCP, size, query_size);
    expect_string(__wrap_OS_SendSecureTCP, msg, query);
    will_return(__wrap_OS_SendSecureTCP, 0);

    expect_value(__wrap_OS_RecvSecureTCP, sock, 11111);
    expect_value(__wrap_OS_RecvSecureTCP, size, OS_SIZE_128);
    will_return(__wrap_OS_RecvSecureTCP, "");
    will_return(__wrap_OS_RecvSecureTCP, 0);

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "(5582): Couldn't get the OS information of the agent 000.");

    int ret = wm_vuldet_get_oslinux_info(agent);

    assert_int_equal(ret, -1);
    assert_null(agent->os_release);
    assert_null(agent->kernel_release);
}

void test_wm_vuldet_get_oslinux_info_request_error(void **state)
{
    agent_software *agent = *state;

    const char *query = "agent 000 sql SELECT OS_VERSION, RELEASE FROM SYS_OSINFO;";
    size_t query_size = strlen(query) + 1;

    expect_string(__wrap_OS_ConnectUnixDomain, path, WDB_LOCAL_SOCK_PATH);
    expect_value(__wrap_OS_ConnectUnixDomain, type, SOCK_STREAM);
    expect_value(__wrap_OS_ConnectUnixDomain, max_msg_size, OS_SIZE_6144);
    will_return(__wrap_OS_ConnectUnixDomain, 11111);

    expect_value(__wrap_OS_SendSecureTCP, sock, 11111);
    expect_value(__wrap_OS_SendSecureTCP, size, query_size);
    expect_string(__wrap_OS_SendSecureTCP, msg, query);
    will_return(__wrap_OS_SendSecureTCP, 0);

    expect_value(__wrap_OS_RecvSecureTCP, sock, 11111);
    expect_value(__wrap_OS_RecvSecureTCP, size, OS_SIZE_128);
    will_return(__wrap_OS_RecvSecureTCP, "err");
    will_return(__wrap_OS_RecvSecureTCP, 3);

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "(5502): Invalid response from wazuh-db: 'err'.");

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "(5582): Couldn't get the OS information of the agent 000.");

    int ret = wm_vuldet_get_oslinux_info(agent);

    assert_int_equal(ret, -1);
    assert_null(agent->os_release);
    assert_null(agent->kernel_release);
}

void test_wm_vuldet_get_oslinux_info_request_empty(void **state)
{
    agent_software *agent = *state;

    const char *query = "agent 000 sql SELECT OS_VERSION, RELEASE FROM SYS_OSINFO;";
    size_t query_size = strlen(query) + 1;

    expect_value(__wrap_OS_SendSecureTCP, sock, 11111);
    expect_value(__wrap_OS_SendSecureTCP, size, query_size);
    expect_string(__wrap_OS_SendSecureTCP, msg, query);
    will_return(__wrap_OS_SendSecureTCP, 0);

    expect_value(__wrap_OS_RecvSecureTCP, sock, 11111);
    expect_value(__wrap_OS_RecvSecureTCP, size, OS_SIZE_128);
    will_return(__wrap_OS_RecvSecureTCP, "ok []");
    will_return(__wrap_OS_RecvSecureTCP, 5);

    int ret = wm_vuldet_get_oslinux_info(agent);

    assert_int_equal(ret, 0);
    assert_null(agent->os_release);
    assert_null(agent->kernel_release);
}

void test_wm_vuldet_get_oslinux_info_request_parse_error(void **state)
{
    agent_software *agent = *state;

    const char *query = "agent 000 sql SELECT OS_VERSION, RELEASE FROM SYS_OSINFO;";
    size_t query_size = strlen(query) + 1;

    expect_value(__wrap_OS_SendSecureTCP, sock, 11111);
    expect_value(__wrap_OS_SendSecureTCP, size, query_size);
    expect_string(__wrap_OS_SendSecureTCP, msg, query);
    will_return(__wrap_OS_SendSecureTCP, 0);

    expect_value(__wrap_OS_RecvSecureTCP, sock, 11111);
    expect_value(__wrap_OS_RecvSecureTCP, size, OS_SIZE_128);
    will_return(__wrap_OS_RecvSecureTCP, "ok answer");
    will_return(__wrap_OS_RecvSecureTCP, 9);

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "(5582): Couldn't get the OS information of the agent 000.");

    int ret = wm_vuldet_get_oslinux_info(agent);

    assert_int_equal(ret, -1);
    assert_null(agent->os_release);
    assert_null(agent->kernel_release);
}

void test_wm_vuldet_generate_os_and_kernel_package_ubuntu(void **state)
{
    agent_software *agent = *state;
    sqlite3 *db = (sqlite3 *)1;

    agent->dist = FEED_UBUNTU;
    agent->dist_ver = FEED_BIONIC;
    agent->os_release = strdup("18.04");
    agent->kernel_release = strdup("3.10");
    agent->arch = strdup("x86_64");

    will_return_count(__wrap_sqlite3_prepare_v2, SQLITE_OK, 2);
    will_return_always(__wrap_sqlite3_bind_text, 0);
    will_return_always(__wrap_sqlite3_bind_int, 0);
    will_return_count(__wrap_sqlite3_step, SQLITE_DONE, 2);

    // OS package
    expect_value(__wrap_sqlite3_bind_text, a, 1);
    expect_string(__wrap_sqlite3_bind_text, b, "000");
    expect_value(__wrap_sqlite3_bind_text, a, 2);
    expect_value(__wrap_sqlite3_bind_text, a, 3);
    expect_value(__wrap_sqlite3_bind_int, a, 4);
    expect_value(__wrap_sqlite3_bind_int, b, 0);
    expect_value(__wrap_sqlite3_bind_text, a, 5);
    expect_string(__wrap_sqlite3_bind_text, b, "canonical");
    expect_value(__wrap_sqlite3_bind_text, a, 6);
    expect_string(__wrap_sqlite3_bind_text, b, "ubuntu_linux");
    expect_value(__wrap_sqlite3_bind_text, a, 7);
    expect_value(__wrap_sqlite3_bind_text, a, 8);
    expect_string(__wrap_sqlite3_bind_text, b, "18.04");
    expect_value(__wrap_sqlite3_bind_text, a, 9);
    expect_string(__wrap_sqlite3_bind_text, b, "x86_64");

    // Kernel package
    expect_value(__wrap_sqlite3_bind_text, a, 1);
    expect_string(__wrap_sqlite3_bind_text, b, "000");
    expect_value(__wrap_sqlite3_bind_text, a, 2);
    expect_value(__wrap_sqlite3_bind_text, a, 3);
    expect_value(__wrap_sqlite3_bind_int, a, 4);
    expect_value(__wrap_sqlite3_bind_int, b, 0);
    expect_value(__wrap_sqlite3_bind_text, a, 5);
    expect_string(__wrap_sqlite3_bind_text, b, "linux");
    expect_value(__wrap_sqlite3_bind_text, a, 6);
    expect_string(__wrap_sqlite3_bind_text, b, "linux_kernel");
    expect_value(__wrap_sqlite3_bind_text, a, 7);
    expect_value(__wrap_sqlite3_bind_text, a, 8);
    expect_string(__wrap_sqlite3_bind_text, b, "3.10");
    expect_value(__wrap_sqlite3_bind_text, a, 9);
    expect_string(__wrap_sqlite3_bind_text, b, "x86_64");

    int ret = wm_vuldet_generate_os_and_kernel_package(db, agent);

    assert_int_equal(ret, 0);
}

void test_wm_vuldet_generate_os_and_kernel_package_debian(void **state)
{
    agent_software *agent = *state;
    sqlite3 *db = (sqlite3 *)1;

    agent->dist = FEED_DEBIAN;
    agent->dist_ver = FEED_BUSTER;
    agent->os_release = strdup("10");
    agent->kernel_release = strdup("4.11");
    agent->arch = strdup("x86_64");

    will_return_count(__wrap_sqlite3_prepare_v2, SQLITE_OK, 2);
    will_return_always(__wrap_sqlite3_bind_text, 0);
    will_return_always(__wrap_sqlite3_bind_int, 0);
    will_return_count(__wrap_sqlite3_step, SQLITE_DONE, 2);

    // OS package
    expect_value(__wrap_sqlite3_bind_text, a, 1);
    expect_string(__wrap_sqlite3_bind_text, b, "000");
    expect_value(__wrap_sqlite3_bind_text, a, 2);
    expect_value(__wrap_sqlite3_bind_text, a, 3);
    expect_value(__wrap_sqlite3_bind_int, a, 4);
    expect_value(__wrap_sqlite3_bind_int, b, 0);
    expect_value(__wrap_sqlite3_bind_text, a, 5);
    expect_string(__wrap_sqlite3_bind_text, b, "debian");
    expect_value(__wrap_sqlite3_bind_text, a, 6);
    expect_string(__wrap_sqlite3_bind_text, b, "debian_linux");
    expect_value(__wrap_sqlite3_bind_text, a, 7);
    expect_value(__wrap_sqlite3_bind_text, a, 8);
    expect_string(__wrap_sqlite3_bind_text, b, "10");
    expect_value(__wrap_sqlite3_bind_text, a, 9);
    expect_string(__wrap_sqlite3_bind_text, b, "x86_64");

    // Kernel package
    expect_value(__wrap_sqlite3_bind_text, a, 1);
    expect_string(__wrap_sqlite3_bind_text, b, "000");
    expect_value(__wrap_sqlite3_bind_text, a, 2);
    expect_value(__wrap_sqlite3_bind_text, a, 3);
    expect_value(__wrap_sqlite3_bind_int, a, 4);
    expect_value(__wrap_sqlite3_bind_int, b, 0);
    expect_value(__wrap_sqlite3_bind_text, a, 5);
    expect_string(__wrap_sqlite3_bind_text, b, "linux");
    expect_value(__wrap_sqlite3_bind_text, a, 6);
    expect_string(__wrap_sqlite3_bind_text, b, "linux_kernel");
    expect_value(__wrap_sqlite3_bind_text, a, 7);
    expect_value(__wrap_sqlite3_bind_text, a, 8);
    expect_string(__wrap_sqlite3_bind_text, b, "4.11");
    expect_value(__wrap_sqlite3_bind_text, a, 9);
    expect_string(__wrap_sqlite3_bind_text, b, "x86_64");

    int ret = wm_vuldet_generate_os_and_kernel_package(db, agent);

    assert_int_equal(ret, 0);
}

void test_wm_vuldet_generate_os_and_kernel_package_redhat(void **state)
{
    agent_software *agent = *state;
    sqlite3 *db = (sqlite3 *)1;

    agent->dist = FEED_REDHAT;
    agent->dist_ver = FEED_RHEL7;
    agent->os_release = strdup("7.2");
    agent->kernel_release = strdup("5.1.0");
    agent->arch = strdup("x86_64");

    will_return_count(__wrap_sqlite3_prepare_v2, SQLITE_OK, 2);
    will_return_always(__wrap_sqlite3_bind_text, 0);
    will_return_always(__wrap_sqlite3_bind_int, 0);
    will_return_count(__wrap_sqlite3_step, SQLITE_DONE, 2);

    // OS package
    expect_value(__wrap_sqlite3_bind_text, a, 1);
    expect_string(__wrap_sqlite3_bind_text, b, "000");
    expect_value(__wrap_sqlite3_bind_text, a, 2);
    expect_value(__wrap_sqlite3_bind_text, a, 3);
    expect_value(__wrap_sqlite3_bind_int, a, 4);
    expect_value(__wrap_sqlite3_bind_int, b, 0);
    expect_value(__wrap_sqlite3_bind_text, a, 5);
    expect_string(__wrap_sqlite3_bind_text, b, "redhat");
    expect_value(__wrap_sqlite3_bind_text, a, 6);
    expect_string(__wrap_sqlite3_bind_text, b, "enterprise_linux");
    expect_value(__wrap_sqlite3_bind_text, a, 7);
    expect_value(__wrap_sqlite3_bind_text, a, 8);
    expect_string(__wrap_sqlite3_bind_text, b, "7.2");
    expect_value(__wrap_sqlite3_bind_text, a, 9);
    expect_string(__wrap_sqlite3_bind_text, b, "x86_64");

    // Kernel package
    expect_value(__wrap_sqlite3_bind_text, a, 1);
    expect_string(__wrap_sqlite3_bind_text, b, "000");
    expect_value(__wrap_sqlite3_bind_text, a, 2);
    expect_value(__wrap_sqlite3_bind_text, a, 3);
    expect_value(__wrap_sqlite3_bind_int, a, 4);
    expect_value(__wrap_sqlite3_bind_int, b, 0);
    expect_value(__wrap_sqlite3_bind_text, a, 5);
    expect_string(__wrap_sqlite3_bind_text, b, "linux");
    expect_value(__wrap_sqlite3_bind_text, a, 6);
    expect_string(__wrap_sqlite3_bind_text, b, "linux_kernel");
    expect_value(__wrap_sqlite3_bind_text, a, 7);
    expect_value(__wrap_sqlite3_bind_text, a, 8);
    expect_string(__wrap_sqlite3_bind_text, b, "5.1.0");
    expect_value(__wrap_sqlite3_bind_text, a, 9);
    expect_string(__wrap_sqlite3_bind_text, b, "x86_64");

    int ret = wm_vuldet_generate_os_and_kernel_package(db, agent);

    assert_int_equal(ret, 0);
}

void test_wm_vuldet_generate_os_and_kernel_package_null_db(void **state)
{
    (void) state;

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "(5581): The DB is not initialized.");

    int ret = wm_vuldet_generate_os_and_kernel_package(NULL, NULL);

    assert_int_equal(ret, -1);
}

void test_wm_vuldet_generate_os_and_kernel_package_null_agent(void **state)
{
    (void) state;
    sqlite3 *db = (sqlite3 *)1;

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "(5580): The agent structure is not initialized.");

    int ret = wm_vuldet_generate_os_and_kernel_package(db, NULL);

    assert_int_equal(ret, -1);
}

void test_wm_vuldet_generate_os_and_kernel_package_invalid_agent(void **state)
{
    agent_software *agent = *state;
    sqlite3 *db = (sqlite3 *)1;

    expect_string(__wrap__mtdebug2, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mtdebug2, formatted_msg, "(5549): Could not get the agent 000 os_version nor release, so its OS and kernel vulnerabilities will not be analysed. It may not have os_info scan activated.");

    int ret = wm_vuldet_generate_os_and_kernel_package(db, agent);

    assert_int_equal(ret, 1);
}

void test_wm_vuldet_generate_os_and_kernel_package_os_package_error(void **state)
{
    agent_software *agent = *state;
    sqlite3 *db = (sqlite3 *)1;

    agent->dist = FEED_REDHAT;
    agent->dist_ver = FEED_RHEL7;
    agent->os_release = strdup("7.2");
    agent->arch = strdup("x86_64");

    // OS package
    will_return(__wrap_sqlite3_prepare_v2, SQLITE_ERROR);

    will_return(__wrap_sqlite3_errmsg, "error");

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "(5405): SQL error: error");

    will_return(__wrap_sqlite3_close_v2, 0);

    expect_string(__wrap__mtdebug1, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mtdebug1, formatted_msg, "(5567): It was not possible to insert enterprise_linux in the agent software table.");

    int ret = wm_vuldet_generate_os_and_kernel_package(db, agent);

    assert_int_equal(ret, -1);
}

void test_wm_vuldet_generate_os_and_kernel_package_kernel_package_error(void **state)
{
    agent_software *agent = *state;
    sqlite3 *db = (sqlite3 *)1;

    agent->dist = FEED_REDHAT;
    agent->dist_ver = FEED_RHEL7;
    agent->kernel_release = strdup("5.1.0");
    agent->arch = strdup("x86_64");

    // Kernel package
    will_return(__wrap_sqlite3_prepare_v2, SQLITE_ERROR);

    will_return(__wrap_sqlite3_errmsg, "error");

    expect_string(__wrap__mterror, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mterror, formatted_msg, "(5405): SQL error: error");

    will_return(__wrap_sqlite3_close_v2, 0);

    expect_string(__wrap__mtdebug1, tag, "wazuh-modulesd:vulnerability-detector");
    expect_string(__wrap__mtdebug1, formatted_msg, "(5567): It was not possible to insert linux_kernel in the agent software table.");

    int ret = wm_vuldet_generate_os_and_kernel_package(db, agent);

    assert_int_equal(ret, -1);
}


int main(void) {
    const struct CMUnitTest tests[] = {
        cmocka_unit_test_setup_teardown(test_wm_vuldet_get_oslinux_info, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_get_oslinux_info_only_version, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_get_oslinux_info_only_release, setup_agent_software, teardown_agent_software),
        cmocka_unit_test(test_wm_vuldet_get_oslinux_info_null_agent),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_get_oslinux_info_request_invalid, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_get_oslinux_info_request_error, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_get_oslinux_info_request_empty, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_get_oslinux_info_request_parse_error, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_generate_os_and_kernel_package_ubuntu, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_generate_os_and_kernel_package_debian, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_generate_os_and_kernel_package_redhat, setup_agent_software, teardown_agent_software),
        cmocka_unit_test(test_wm_vuldet_generate_os_and_kernel_package_null_db),
        cmocka_unit_test(test_wm_vuldet_generate_os_and_kernel_package_null_agent),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_generate_os_and_kernel_package_invalid_agent, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_generate_os_and_kernel_package_os_package_error, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_wm_vuldet_generate_os_and_kernel_package_kernel_package_error, setup_agent_software, teardown_agent_software),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_epoch_NONE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_epoch_VER_TYPE_unknown, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_epoch_RELATION_unknown, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_epoch_GT, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_epoch_GE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_epoch_EQ, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_epoch_LE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_epoch_LT, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_deb_GT, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_deb_GE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_deb_EQ, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_deb_LE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_deb_LT, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_rpm_GT, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_rpm_GE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_rpm_EQ, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_rpm_LE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_version_rpm_LT, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_deb_GT, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_deb_GE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_deb_EQ, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_deb_LE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_deb_LT, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_rpm_GT, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_rpm_GE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_rpm_EQ, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_rpm_LE, setup_versions, teardown_versions),
        cmocka_unit_test_setup_teardown(test_pkg_version_relate_revision_rpm_LT, setup_versions, teardown_versions)
    };
    return cmocka_run_group_tests(tests, NULL, NULL);
}