// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: crud.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_crud_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_crud_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "engine.pb.h"
#include <google/protobuf/struct.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_crud_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_crud_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_crud_2eproto;
namespace com {
namespace wazuh {
namespace api {
namespace engine {
namespace content {
class ResourceSummary;
struct ResourceSummaryDefaultTypeInternal;
extern ResourceSummaryDefaultTypeInternal _ResourceSummary_default_instance_;
class namespaceDelete_Request;
struct namespaceDelete_RequestDefaultTypeInternal;
extern namespaceDelete_RequestDefaultTypeInternal _namespaceDelete_Request_default_instance_;
class namespaceGet_Request;
struct namespaceGet_RequestDefaultTypeInternal;
extern namespaceGet_RequestDefaultTypeInternal _namespaceGet_Request_default_instance_;
class namespaceGet_Response;
struct namespaceGet_ResponseDefaultTypeInternal;
extern namespaceGet_ResponseDefaultTypeInternal _namespaceGet_Response_default_instance_;
class namespaceImport_Request;
struct namespaceImport_RequestDefaultTypeInternal;
extern namespaceImport_RequestDefaultTypeInternal _namespaceImport_Request_default_instance_;
class namespacePost_Request;
struct namespacePost_RequestDefaultTypeInternal;
extern namespacePost_RequestDefaultTypeInternal _namespacePost_Request_default_instance_;
class policyDelete_Request;
struct policyDelete_RequestDefaultTypeInternal;
extern policyDelete_RequestDefaultTypeInternal _policyDelete_Request_default_instance_;
class policyPost_Request;
struct policyPost_RequestDefaultTypeInternal;
extern policyPost_RequestDefaultTypeInternal _policyPost_Request_default_instance_;
class policyValidate_Request;
struct policyValidate_RequestDefaultTypeInternal;
extern policyValidate_RequestDefaultTypeInternal _policyValidate_Request_default_instance_;
class resourceDelete_Request;
struct resourceDelete_RequestDefaultTypeInternal;
extern resourceDelete_RequestDefaultTypeInternal _resourceDelete_Request_default_instance_;
class resourceGet_Request;
struct resourceGet_RequestDefaultTypeInternal;
extern resourceGet_RequestDefaultTypeInternal _resourceGet_Request_default_instance_;
class resourceGet_Response;
struct resourceGet_ResponseDefaultTypeInternal;
extern resourceGet_ResponseDefaultTypeInternal _resourceGet_Response_default_instance_;
class resourceList_Request;
struct resourceList_RequestDefaultTypeInternal;
extern resourceList_RequestDefaultTypeInternal _resourceList_Request_default_instance_;
class resourceList_Response;
struct resourceList_ResponseDefaultTypeInternal;
extern resourceList_ResponseDefaultTypeInternal _resourceList_Response_default_instance_;
class resourcePost_Request;
struct resourcePost_RequestDefaultTypeInternal;
extern resourcePost_RequestDefaultTypeInternal _resourcePost_Request_default_instance_;
class resourceValidate_Request;
struct resourceValidate_RequestDefaultTypeInternal;
extern resourceValidate_RequestDefaultTypeInternal _resourceValidate_Request_default_instance_;
}  // namespace content
}  // namespace engine
}  // namespace api
}  // namespace wazuh
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::wazuh::api::engine::content::ResourceSummary* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::ResourceSummary>(Arena*);
template<> ::com::wazuh::api::engine::content::namespaceDelete_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::namespaceDelete_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::namespaceGet_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::namespaceGet_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::namespaceGet_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::namespaceGet_Response>(Arena*);
template<> ::com::wazuh::api::engine::content::namespaceImport_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::namespaceImport_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::namespacePost_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::namespacePost_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::policyDelete_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::policyDelete_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::policyPost_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::policyPost_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::policyValidate_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::policyValidate_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::resourceDelete_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::resourceDelete_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::resourceGet_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::resourceGet_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::resourceGet_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::resourceGet_Response>(Arena*);
template<> ::com::wazuh::api::engine::content::resourceList_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::resourceList_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::resourceList_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::resourceList_Response>(Arena*);
template<> ::com::wazuh::api::engine::content::resourcePost_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::resourcePost_Request>(Arena*);
template<> ::com::wazuh::api::engine::content::resourceValidate_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::content::resourceValidate_Request>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace wazuh {
namespace api {
namespace engine {
namespace content {

// ===================================================================

class ResourceSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.ResourceSummary) */ {
 public:
  inline ResourceSummary() : ResourceSummary(nullptr) {}
  ~ResourceSummary() override;
  explicit PROTOBUF_CONSTEXPR ResourceSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourceSummary(const ResourceSummary& from);
  ResourceSummary(ResourceSummary&& from) noexcept
    : ResourceSummary() {
    *this = ::std::move(from);
  }

  inline ResourceSummary& operator=(const ResourceSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourceSummary& operator=(ResourceSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourceSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourceSummary* internal_default_instance() {
    return reinterpret_cast<const ResourceSummary*>(
               &_ResourceSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ResourceSummary& a, ResourceSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourceSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourceSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResourceSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResourceSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResourceSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResourceSummary& from) {
    ResourceSummary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.ResourceSummary";
  }
  protected:
  explicit ResourceSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // optional string uuid = 1;
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;
  public:
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.ResourceSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class namespaceGet_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.namespaceGet_Request) */ {
 public:
  inline namespaceGet_Request() : namespaceGet_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR namespaceGet_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  namespaceGet_Request(const namespaceGet_Request& from);
  namespaceGet_Request(namespaceGet_Request&& from) noexcept
    : namespaceGet_Request() {
    *this = ::std::move(from);
  }

  inline namespaceGet_Request& operator=(const namespaceGet_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline namespaceGet_Request& operator=(namespaceGet_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const namespaceGet_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const namespaceGet_Request* internal_default_instance() {
    return reinterpret_cast<const namespaceGet_Request*>(
               &_namespaceGet_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(namespaceGet_Request& a, namespaceGet_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(namespaceGet_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(namespaceGet_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  namespaceGet_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<namespaceGet_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const namespaceGet_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const namespaceGet_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.namespaceGet_Request";
  }
  protected:
  explicit namespaceGet_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.namespaceGet_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class namespaceGet_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.namespaceGet_Response) */ {
 public:
  inline namespaceGet_Response() : namespaceGet_Response(nullptr) {}
  ~namespaceGet_Response() override;
  explicit PROTOBUF_CONSTEXPR namespaceGet_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  namespaceGet_Response(const namespaceGet_Response& from);
  namespaceGet_Response(namespaceGet_Response&& from) noexcept
    : namespaceGet_Response() {
    *this = ::std::move(from);
  }

  inline namespaceGet_Response& operator=(const namespaceGet_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline namespaceGet_Response& operator=(namespaceGet_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const namespaceGet_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const namespaceGet_Response* internal_default_instance() {
    return reinterpret_cast<const namespaceGet_Response*>(
               &_namespaceGet_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(namespaceGet_Response& a, namespaceGet_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(namespaceGet_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(namespaceGet_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  namespaceGet_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<namespaceGet_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const namespaceGet_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const namespaceGet_Response& from) {
    namespaceGet_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(namespaceGet_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.namespaceGet_Response";
  }
  protected:
  explicit namespaceGet_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpacesFieldNumber = 3,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated string spaces = 3;
  int spaces_size() const;
  private:
  int _internal_spaces_size() const;
  public:
  void clear_spaces();
  const std::string& spaces(int index) const;
  std::string* mutable_spaces(int index);
  void set_spaces(int index, const std::string& value);
  void set_spaces(int index, std::string&& value);
  void set_spaces(int index, const char* value);
  void set_spaces(int index, const char* value, size_t size);
  std::string* add_spaces();
  void add_spaces(const std::string& value);
  void add_spaces(std::string&& value);
  void add_spaces(const char* value);
  void add_spaces(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& spaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_spaces();
  private:
  const std::string& _internal_spaces(int index) const;
  std::string* _internal_add_spaces();
  public:

  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.namespaceGet_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> spaces_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class namespacePost_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.namespacePost_Request) */ {
 public:
  inline namespacePost_Request() : namespacePost_Request(nullptr) {}
  ~namespacePost_Request() override;
  explicit PROTOBUF_CONSTEXPR namespacePost_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  namespacePost_Request(const namespacePost_Request& from);
  namespacePost_Request(namespacePost_Request&& from) noexcept
    : namespacePost_Request() {
    *this = ::std::move(from);
  }

  inline namespacePost_Request& operator=(const namespacePost_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline namespacePost_Request& operator=(namespacePost_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const namespacePost_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const namespacePost_Request* internal_default_instance() {
    return reinterpret_cast<const namespacePost_Request*>(
               &_namespacePost_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(namespacePost_Request& a, namespacePost_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(namespacePost_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(namespacePost_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  namespacePost_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<namespacePost_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const namespacePost_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const namespacePost_Request& from) {
    namespacePost_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(namespacePost_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.namespacePost_Request";
  }
  protected:
  explicit namespacePost_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceFieldNumber = 1,
  };
  // string space = 1;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_NODISCARD std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.namespacePost_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class namespaceDelete_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.namespaceDelete_Request) */ {
 public:
  inline namespaceDelete_Request() : namespaceDelete_Request(nullptr) {}
  ~namespaceDelete_Request() override;
  explicit PROTOBUF_CONSTEXPR namespaceDelete_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  namespaceDelete_Request(const namespaceDelete_Request& from);
  namespaceDelete_Request(namespaceDelete_Request&& from) noexcept
    : namespaceDelete_Request() {
    *this = ::std::move(from);
  }

  inline namespaceDelete_Request& operator=(const namespaceDelete_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline namespaceDelete_Request& operator=(namespaceDelete_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const namespaceDelete_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const namespaceDelete_Request* internal_default_instance() {
    return reinterpret_cast<const namespaceDelete_Request*>(
               &_namespaceDelete_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(namespaceDelete_Request& a, namespaceDelete_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(namespaceDelete_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(namespaceDelete_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  namespaceDelete_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<namespaceDelete_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const namespaceDelete_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const namespaceDelete_Request& from) {
    namespaceDelete_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(namespaceDelete_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.namespaceDelete_Request";
  }
  protected:
  explicit namespaceDelete_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceFieldNumber = 1,
  };
  // string space = 1;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_NODISCARD std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.namespaceDelete_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class namespaceImport_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.namespaceImport_Request) */ {
 public:
  inline namespaceImport_Request() : namespaceImport_Request(nullptr) {}
  ~namespaceImport_Request() override;
  explicit PROTOBUF_CONSTEXPR namespaceImport_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  namespaceImport_Request(const namespaceImport_Request& from);
  namespaceImport_Request(namespaceImport_Request&& from) noexcept
    : namespaceImport_Request() {
    *this = ::std::move(from);
  }

  inline namespaceImport_Request& operator=(const namespaceImport_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline namespaceImport_Request& operator=(namespaceImport_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const namespaceImport_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const namespaceImport_Request* internal_default_instance() {
    return reinterpret_cast<const namespaceImport_Request*>(
               &_namespaceImport_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(namespaceImport_Request& a, namespaceImport_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(namespaceImport_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(namespaceImport_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  namespaceImport_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<namespaceImport_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const namespaceImport_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const namespaceImport_Request& from) {
    namespaceImport_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(namespaceImport_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.namespaceImport_Request";
  }
  protected:
  explicit namespaceImport_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceFieldNumber = 1,
    kJsonContentFieldNumber = 2,
    kForceFieldNumber = 3,
  };
  // string space = 1;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_NODISCARD std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // string jsonContent = 2;
  void clear_jsoncontent();
  const std::string& jsoncontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jsoncontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jsoncontent();
  PROTOBUF_NODISCARD std::string* release_jsoncontent();
  void set_allocated_jsoncontent(std::string* jsoncontent);
  private:
  const std::string& _internal_jsoncontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jsoncontent(const std::string& value);
  std::string* _internal_mutable_jsoncontent();
  public:

  // bool force = 3;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.namespaceImport_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsoncontent_;
    bool force_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class policyPost_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.policyPost_Request) */ {
 public:
  inline policyPost_Request() : policyPost_Request(nullptr) {}
  ~policyPost_Request() override;
  explicit PROTOBUF_CONSTEXPR policyPost_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  policyPost_Request(const policyPost_Request& from);
  policyPost_Request(policyPost_Request&& from) noexcept
    : policyPost_Request() {
    *this = ::std::move(from);
  }

  inline policyPost_Request& operator=(const policyPost_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline policyPost_Request& operator=(policyPost_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const policyPost_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const policyPost_Request* internal_default_instance() {
    return reinterpret_cast<const policyPost_Request*>(
               &_policyPost_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(policyPost_Request& a, policyPost_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(policyPost_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(policyPost_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  policyPost_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<policyPost_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const policyPost_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const policyPost_Request& from) {
    policyPost_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(policyPost_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.policyPost_Request";
  }
  protected:
  explicit policyPost_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceFieldNumber = 1,
    kYmlContentFieldNumber = 2,
  };
  // string space = 1;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_NODISCARD std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // string ymlContent = 2;
  void clear_ymlcontent();
  const std::string& ymlcontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ymlcontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ymlcontent();
  PROTOBUF_NODISCARD std::string* release_ymlcontent();
  void set_allocated_ymlcontent(std::string* ymlcontent);
  private:
  const std::string& _internal_ymlcontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ymlcontent(const std::string& value);
  std::string* _internal_mutable_ymlcontent();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.policyPost_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ymlcontent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class policyDelete_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.policyDelete_Request) */ {
 public:
  inline policyDelete_Request() : policyDelete_Request(nullptr) {}
  ~policyDelete_Request() override;
  explicit PROTOBUF_CONSTEXPR policyDelete_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  policyDelete_Request(const policyDelete_Request& from);
  policyDelete_Request(policyDelete_Request&& from) noexcept
    : policyDelete_Request() {
    *this = ::std::move(from);
  }

  inline policyDelete_Request& operator=(const policyDelete_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline policyDelete_Request& operator=(policyDelete_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const policyDelete_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const policyDelete_Request* internal_default_instance() {
    return reinterpret_cast<const policyDelete_Request*>(
               &_policyDelete_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(policyDelete_Request& a, policyDelete_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(policyDelete_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(policyDelete_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  policyDelete_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<policyDelete_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const policyDelete_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const policyDelete_Request& from) {
    policyDelete_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(policyDelete_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.policyDelete_Request";
  }
  protected:
  explicit policyDelete_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceFieldNumber = 1,
  };
  // string space = 1;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_NODISCARD std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.policyDelete_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class policyValidate_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.policyValidate_Request) */ {
 public:
  inline policyValidate_Request() : policyValidate_Request(nullptr) {}
  ~policyValidate_Request() override;
  explicit PROTOBUF_CONSTEXPR policyValidate_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  policyValidate_Request(const policyValidate_Request& from);
  policyValidate_Request(policyValidate_Request&& from) noexcept
    : policyValidate_Request() {
    *this = ::std::move(from);
  }

  inline policyValidate_Request& operator=(const policyValidate_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline policyValidate_Request& operator=(policyValidate_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const policyValidate_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const policyValidate_Request* internal_default_instance() {
    return reinterpret_cast<const policyValidate_Request*>(
               &_policyValidate_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(policyValidate_Request& a, policyValidate_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(policyValidate_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(policyValidate_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  policyValidate_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<policyValidate_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const policyValidate_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const policyValidate_Request& from) {
    policyValidate_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(policyValidate_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.policyValidate_Request";
  }
  protected:
  explicit policyValidate_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFullPolicyFieldNumber = 2,
    kLoadInTesterFieldNumber = 1,
  };
  // .google.protobuf.Struct full_policy = 2;
  bool has_full_policy() const;
  private:
  bool _internal_has_full_policy() const;
  public:
  void clear_full_policy();
  const ::PROTOBUF_NAMESPACE_ID::Struct& full_policy() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_full_policy();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_full_policy();
  void set_allocated_full_policy(::PROTOBUF_NAMESPACE_ID::Struct* full_policy);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_full_policy() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_full_policy();
  public:
  void unsafe_arena_set_allocated_full_policy(
      ::PROTOBUF_NAMESPACE_ID::Struct* full_policy);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_full_policy();

  // bool load_in_tester = 1;
  void clear_load_in_tester();
  bool load_in_tester() const;
  void set_load_in_tester(bool value);
  private:
  bool _internal_load_in_tester() const;
  void _internal_set_load_in_tester(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.policyValidate_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::Struct* full_policy_;
    bool load_in_tester_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class resourceList_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.resourceList_Request) */ {
 public:
  inline resourceList_Request() : resourceList_Request(nullptr) {}
  ~resourceList_Request() override;
  explicit PROTOBUF_CONSTEXPR resourceList_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resourceList_Request(const resourceList_Request& from);
  resourceList_Request(resourceList_Request&& from) noexcept
    : resourceList_Request() {
    *this = ::std::move(from);
  }

  inline resourceList_Request& operator=(const resourceList_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline resourceList_Request& operator=(resourceList_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resourceList_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const resourceList_Request* internal_default_instance() {
    return reinterpret_cast<const resourceList_Request*>(
               &_resourceList_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(resourceList_Request& a, resourceList_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(resourceList_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resourceList_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resourceList_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resourceList_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resourceList_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resourceList_Request& from) {
    resourceList_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resourceList_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.resourceList_Request";
  }
  protected:
  explicit resourceList_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string space = 1;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_NODISCARD std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.resourceList_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class resourceList_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.resourceList_Response) */ {
 public:
  inline resourceList_Response() : resourceList_Response(nullptr) {}
  ~resourceList_Response() override;
  explicit PROTOBUF_CONSTEXPR resourceList_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resourceList_Response(const resourceList_Response& from);
  resourceList_Response(resourceList_Response&& from) noexcept
    : resourceList_Response() {
    *this = ::std::move(from);
  }

  inline resourceList_Response& operator=(const resourceList_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline resourceList_Response& operator=(resourceList_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resourceList_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const resourceList_Response* internal_default_instance() {
    return reinterpret_cast<const resourceList_Response*>(
               &_resourceList_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(resourceList_Response& a, resourceList_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(resourceList_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resourceList_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resourceList_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resourceList_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resourceList_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resourceList_Response& from) {
    resourceList_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resourceList_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.resourceList_Response";
  }
  protected:
  explicit resourceList_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourcesFieldNumber = 3,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .com.wazuh.api.engine.content.ResourceSummary resources = 3;
  int resources_size() const;
  private:
  int _internal_resources_size() const;
  public:
  void clear_resources();
  ::com::wazuh::api::engine::content::ResourceSummary* mutable_resources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::wazuh::api::engine::content::ResourceSummary >*
      mutable_resources();
  private:
  const ::com::wazuh::api::engine::content::ResourceSummary& _internal_resources(int index) const;
  ::com::wazuh::api::engine::content::ResourceSummary* _internal_add_resources();
  public:
  const ::com::wazuh::api::engine::content::ResourceSummary& resources(int index) const;
  ::com::wazuh::api::engine::content::ResourceSummary* add_resources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::wazuh::api::engine::content::ResourceSummary >&
      resources() const;

  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.resourceList_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::wazuh::api::engine::content::ResourceSummary > resources_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class resourceGet_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.resourceGet_Request) */ {
 public:
  inline resourceGet_Request() : resourceGet_Request(nullptr) {}
  ~resourceGet_Request() override;
  explicit PROTOBUF_CONSTEXPR resourceGet_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resourceGet_Request(const resourceGet_Request& from);
  resourceGet_Request(resourceGet_Request&& from) noexcept
    : resourceGet_Request() {
    *this = ::std::move(from);
  }

  inline resourceGet_Request& operator=(const resourceGet_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline resourceGet_Request& operator=(resourceGet_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resourceGet_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const resourceGet_Request* internal_default_instance() {
    return reinterpret_cast<const resourceGet_Request*>(
               &_resourceGet_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(resourceGet_Request& a, resourceGet_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(resourceGet_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resourceGet_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resourceGet_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resourceGet_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resourceGet_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resourceGet_Request& from) {
    resourceGet_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resourceGet_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.resourceGet_Request";
  }
  protected:
  explicit resourceGet_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceFieldNumber = 1,
    kUuidFieldNumber = 2,
    kAsJsonFieldNumber = 3,
  };
  // string space = 1;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_NODISCARD std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // string uuid = 2;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // optional bool asJson = 3;
  bool has_asjson() const;
  private:
  bool _internal_has_asjson() const;
  public:
  void clear_asjson();
  bool asjson() const;
  void set_asjson(bool value);
  private:
  bool _internal_asjson() const;
  void _internal_set_asjson(bool value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.resourceGet_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    bool asjson_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class resourceGet_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.resourceGet_Response) */ {
 public:
  inline resourceGet_Response() : resourceGet_Response(nullptr) {}
  ~resourceGet_Response() override;
  explicit PROTOBUF_CONSTEXPR resourceGet_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resourceGet_Response(const resourceGet_Response& from);
  resourceGet_Response(resourceGet_Response&& from) noexcept
    : resourceGet_Response() {
    *this = ::std::move(from);
  }

  inline resourceGet_Response& operator=(const resourceGet_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline resourceGet_Response& operator=(resourceGet_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resourceGet_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const resourceGet_Response* internal_default_instance() {
    return reinterpret_cast<const resourceGet_Response*>(
               &_resourceGet_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(resourceGet_Response& a, resourceGet_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(resourceGet_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resourceGet_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resourceGet_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resourceGet_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resourceGet_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resourceGet_Response& from) {
    resourceGet_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resourceGet_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.resourceGet_Response";
  }
  protected:
  explicit resourceGet_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kContentFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // optional string content = 3;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.resourceGet_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class resourcePost_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.resourcePost_Request) */ {
 public:
  inline resourcePost_Request() : resourcePost_Request(nullptr) {}
  ~resourcePost_Request() override;
  explicit PROTOBUF_CONSTEXPR resourcePost_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resourcePost_Request(const resourcePost_Request& from);
  resourcePost_Request(resourcePost_Request&& from) noexcept
    : resourcePost_Request() {
    *this = ::std::move(from);
  }

  inline resourcePost_Request& operator=(const resourcePost_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline resourcePost_Request& operator=(resourcePost_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resourcePost_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const resourcePost_Request* internal_default_instance() {
    return reinterpret_cast<const resourcePost_Request*>(
               &_resourcePost_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(resourcePost_Request& a, resourcePost_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(resourcePost_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resourcePost_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resourcePost_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resourcePost_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resourcePost_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resourcePost_Request& from) {
    resourcePost_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resourcePost_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.resourcePost_Request";
  }
  protected:
  explicit resourcePost_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceFieldNumber = 1,
    kTypeFieldNumber = 2,
    kYmlContentFieldNumber = 3,
  };
  // string space = 1;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_NODISCARD std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // string type = 2;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string ymlContent = 3;
  void clear_ymlcontent();
  const std::string& ymlcontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ymlcontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ymlcontent();
  PROTOBUF_NODISCARD std::string* release_ymlcontent();
  void set_allocated_ymlcontent(std::string* ymlcontent);
  private:
  const std::string& _internal_ymlcontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ymlcontent(const std::string& value);
  std::string* _internal_mutable_ymlcontent();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.resourcePost_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ymlcontent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class resourceDelete_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.resourceDelete_Request) */ {
 public:
  inline resourceDelete_Request() : resourceDelete_Request(nullptr) {}
  ~resourceDelete_Request() override;
  explicit PROTOBUF_CONSTEXPR resourceDelete_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resourceDelete_Request(const resourceDelete_Request& from);
  resourceDelete_Request(resourceDelete_Request&& from) noexcept
    : resourceDelete_Request() {
    *this = ::std::move(from);
  }

  inline resourceDelete_Request& operator=(const resourceDelete_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline resourceDelete_Request& operator=(resourceDelete_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resourceDelete_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const resourceDelete_Request* internal_default_instance() {
    return reinterpret_cast<const resourceDelete_Request*>(
               &_resourceDelete_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(resourceDelete_Request& a, resourceDelete_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(resourceDelete_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resourceDelete_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resourceDelete_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resourceDelete_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resourceDelete_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resourceDelete_Request& from) {
    resourceDelete_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resourceDelete_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.resourceDelete_Request";
  }
  protected:
  explicit resourceDelete_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpaceFieldNumber = 1,
    kUuidFieldNumber = 2,
  };
  // string space = 1;
  void clear_space();
  const std::string& space() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_space(ArgT0&& arg0, ArgT... args);
  std::string* mutable_space();
  PROTOBUF_NODISCARD std::string* release_space();
  void set_allocated_space(std::string* space);
  private:
  const std::string& _internal_space() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_space(const std::string& value);
  std::string* _internal_mutable_space();
  public:

  // string uuid = 2;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.resourceDelete_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr space_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// -------------------------------------------------------------------

class resourceValidate_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.content.resourceValidate_Request) */ {
 public:
  inline resourceValidate_Request() : resourceValidate_Request(nullptr) {}
  ~resourceValidate_Request() override;
  explicit PROTOBUF_CONSTEXPR resourceValidate_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  resourceValidate_Request(const resourceValidate_Request& from);
  resourceValidate_Request(resourceValidate_Request&& from) noexcept
    : resourceValidate_Request() {
    *this = ::std::move(from);
  }

  inline resourceValidate_Request& operator=(const resourceValidate_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline resourceValidate_Request& operator=(resourceValidate_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const resourceValidate_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const resourceValidate_Request* internal_default_instance() {
    return reinterpret_cast<const resourceValidate_Request*>(
               &_resourceValidate_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(resourceValidate_Request& a, resourceValidate_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(resourceValidate_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(resourceValidate_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  resourceValidate_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<resourceValidate_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const resourceValidate_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const resourceValidate_Request& from) {
    resourceValidate_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(resourceValidate_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.content.resourceValidate_Request";
  }
  protected:
  explicit resourceValidate_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kResourceFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // .google.protobuf.Struct resource = 2;
  bool has_resource() const;
  private:
  bool _internal_has_resource() const;
  public:
  void clear_resource();
  const ::PROTOBUF_NAMESPACE_ID::Struct& resource() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Struct* release_resource();
  ::PROTOBUF_NAMESPACE_ID::Struct* mutable_resource();
  void set_allocated_resource(::PROTOBUF_NAMESPACE_ID::Struct* resource);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Struct& _internal_resource() const;
  ::PROTOBUF_NAMESPACE_ID::Struct* _internal_mutable_resource();
  public:
  void unsafe_arena_set_allocated_resource(
      ::PROTOBUF_NAMESPACE_ID::Struct* resource);
  ::PROTOBUF_NAMESPACE_ID::Struct* unsafe_arena_release_resource();

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.content.resourceValidate_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::Struct* resource_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_crud_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ResourceSummary

// optional string uuid = 1;
inline bool ResourceSummary::_internal_has_uuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ResourceSummary::has_uuid() const {
  return _internal_has_uuid();
}
inline void ResourceSummary::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ResourceSummary::uuid() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.ResourceSummary.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceSummary::set_uuid(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.ResourceSummary.uuid)
}
inline std::string* ResourceSummary::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.ResourceSummary.uuid)
  return _s;
}
inline const std::string& ResourceSummary::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void ResourceSummary::_internal_set_uuid(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceSummary::_internal_mutable_uuid() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceSummary::release_uuid() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.ResourceSummary.uuid)
  if (!_internal_has_uuid()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.uuid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResourceSummary::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.ResourceSummary.uuid)
}

// optional string name = 2;
inline bool ResourceSummary::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ResourceSummary::has_name() const {
  return _internal_has_name();
}
inline void ResourceSummary::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ResourceSummary::name() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.ResourceSummary.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResourceSummary::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.ResourceSummary.name)
}
inline std::string* ResourceSummary::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.ResourceSummary.name)
  return _s;
}
inline const std::string& ResourceSummary::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ResourceSummary::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ResourceSummary::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ResourceSummary::release_name() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.ResourceSummary.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ResourceSummary::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.ResourceSummary.name)
}

// -------------------------------------------------------------------

// namespaceGet_Request

// -------------------------------------------------------------------

// namespaceGet_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void namespaceGet_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus namespaceGet_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus namespaceGet_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.namespaceGet_Response.status)
  return _internal_status();
}
inline void namespaceGet_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void namespaceGet_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.namespaceGet_Response.status)
}

// optional string error = 2;
inline bool namespaceGet_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool namespaceGet_Response::has_error() const {
  return _internal_has_error();
}
inline void namespaceGet_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& namespaceGet_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.namespaceGet_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void namespaceGet_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.namespaceGet_Response.error)
}
inline std::string* namespaceGet_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.namespaceGet_Response.error)
  return _s;
}
inline const std::string& namespaceGet_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void namespaceGet_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* namespaceGet_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* namespaceGet_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.namespaceGet_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void namespaceGet_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.namespaceGet_Response.error)
}

// repeated string spaces = 3;
inline int namespaceGet_Response::_internal_spaces_size() const {
  return _impl_.spaces_.size();
}
inline int namespaceGet_Response::spaces_size() const {
  return _internal_spaces_size();
}
inline void namespaceGet_Response::clear_spaces() {
  _impl_.spaces_.Clear();
}
inline std::string* namespaceGet_Response::add_spaces() {
  std::string* _s = _internal_add_spaces();
  // @@protoc_insertion_point(field_add_mutable:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
  return _s;
}
inline const std::string& namespaceGet_Response::_internal_spaces(int index) const {
  return _impl_.spaces_.Get(index);
}
inline const std::string& namespaceGet_Response::spaces(int index) const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
  return _internal_spaces(index);
}
inline std::string* namespaceGet_Response::mutable_spaces(int index) {
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
  return _impl_.spaces_.Mutable(index);
}
inline void namespaceGet_Response::set_spaces(int index, const std::string& value) {
  _impl_.spaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
}
inline void namespaceGet_Response::set_spaces(int index, std::string&& value) {
  _impl_.spaces_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
}
inline void namespaceGet_Response::set_spaces(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.spaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
}
inline void namespaceGet_Response::set_spaces(int index, const char* value, size_t size) {
  _impl_.spaces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
}
inline std::string* namespaceGet_Response::_internal_add_spaces() {
  return _impl_.spaces_.Add();
}
inline void namespaceGet_Response::add_spaces(const std::string& value) {
  _impl_.spaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
}
inline void namespaceGet_Response::add_spaces(std::string&& value) {
  _impl_.spaces_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
}
inline void namespaceGet_Response::add_spaces(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.spaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
}
inline void namespaceGet_Response::add_spaces(const char* value, size_t size) {
  _impl_.spaces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
namespaceGet_Response::spaces() const {
  // @@protoc_insertion_point(field_list:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
  return _impl_.spaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
namespaceGet_Response::mutable_spaces() {
  // @@protoc_insertion_point(field_mutable_list:com.wazuh.api.engine.content.namespaceGet_Response.spaces)
  return &_impl_.spaces_;
}

// -------------------------------------------------------------------

// namespacePost_Request

// string space = 1;
inline void namespacePost_Request::clear_space() {
  _impl_.space_.ClearToEmpty();
}
inline const std::string& namespacePost_Request::space() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.namespacePost_Request.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void namespacePost_Request::set_space(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.namespacePost_Request.space)
}
inline std::string* namespacePost_Request::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.namespacePost_Request.space)
  return _s;
}
inline const std::string& namespacePost_Request::_internal_space() const {
  return _impl_.space_.Get();
}
inline void namespacePost_Request::_internal_set_space(const std::string& value) {
  
  _impl_.space_.Set(value, GetArenaForAllocation());
}
inline std::string* namespacePost_Request::_internal_mutable_space() {
  
  return _impl_.space_.Mutable(GetArenaForAllocation());
}
inline std::string* namespacePost_Request::release_space() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.namespacePost_Request.space)
  return _impl_.space_.Release();
}
inline void namespacePost_Request::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  _impl_.space_.SetAllocated(space, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_.IsDefault()) {
    _impl_.space_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.namespacePost_Request.space)
}

// -------------------------------------------------------------------

// namespaceDelete_Request

// string space = 1;
inline void namespaceDelete_Request::clear_space() {
  _impl_.space_.ClearToEmpty();
}
inline const std::string& namespaceDelete_Request::space() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.namespaceDelete_Request.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void namespaceDelete_Request::set_space(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.namespaceDelete_Request.space)
}
inline std::string* namespaceDelete_Request::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.namespaceDelete_Request.space)
  return _s;
}
inline const std::string& namespaceDelete_Request::_internal_space() const {
  return _impl_.space_.Get();
}
inline void namespaceDelete_Request::_internal_set_space(const std::string& value) {
  
  _impl_.space_.Set(value, GetArenaForAllocation());
}
inline std::string* namespaceDelete_Request::_internal_mutable_space() {
  
  return _impl_.space_.Mutable(GetArenaForAllocation());
}
inline std::string* namespaceDelete_Request::release_space() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.namespaceDelete_Request.space)
  return _impl_.space_.Release();
}
inline void namespaceDelete_Request::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  _impl_.space_.SetAllocated(space, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_.IsDefault()) {
    _impl_.space_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.namespaceDelete_Request.space)
}

// -------------------------------------------------------------------

// namespaceImport_Request

// string space = 1;
inline void namespaceImport_Request::clear_space() {
  _impl_.space_.ClearToEmpty();
}
inline const std::string& namespaceImport_Request::space() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.namespaceImport_Request.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void namespaceImport_Request::set_space(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.namespaceImport_Request.space)
}
inline std::string* namespaceImport_Request::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.namespaceImport_Request.space)
  return _s;
}
inline const std::string& namespaceImport_Request::_internal_space() const {
  return _impl_.space_.Get();
}
inline void namespaceImport_Request::_internal_set_space(const std::string& value) {
  
  _impl_.space_.Set(value, GetArenaForAllocation());
}
inline std::string* namespaceImport_Request::_internal_mutable_space() {
  
  return _impl_.space_.Mutable(GetArenaForAllocation());
}
inline std::string* namespaceImport_Request::release_space() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.namespaceImport_Request.space)
  return _impl_.space_.Release();
}
inline void namespaceImport_Request::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  _impl_.space_.SetAllocated(space, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_.IsDefault()) {
    _impl_.space_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.namespaceImport_Request.space)
}

// string jsonContent = 2;
inline void namespaceImport_Request::clear_jsoncontent() {
  _impl_.jsoncontent_.ClearToEmpty();
}
inline const std::string& namespaceImport_Request::jsoncontent() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.namespaceImport_Request.jsonContent)
  return _internal_jsoncontent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void namespaceImport_Request::set_jsoncontent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jsoncontent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.namespaceImport_Request.jsonContent)
}
inline std::string* namespaceImport_Request::mutable_jsoncontent() {
  std::string* _s = _internal_mutable_jsoncontent();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.namespaceImport_Request.jsonContent)
  return _s;
}
inline const std::string& namespaceImport_Request::_internal_jsoncontent() const {
  return _impl_.jsoncontent_.Get();
}
inline void namespaceImport_Request::_internal_set_jsoncontent(const std::string& value) {
  
  _impl_.jsoncontent_.Set(value, GetArenaForAllocation());
}
inline std::string* namespaceImport_Request::_internal_mutable_jsoncontent() {
  
  return _impl_.jsoncontent_.Mutable(GetArenaForAllocation());
}
inline std::string* namespaceImport_Request::release_jsoncontent() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.namespaceImport_Request.jsonContent)
  return _impl_.jsoncontent_.Release();
}
inline void namespaceImport_Request::set_allocated_jsoncontent(std::string* jsoncontent) {
  if (jsoncontent != nullptr) {
    
  } else {
    
  }
  _impl_.jsoncontent_.SetAllocated(jsoncontent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jsoncontent_.IsDefault()) {
    _impl_.jsoncontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.namespaceImport_Request.jsonContent)
}

// bool force = 3;
inline void namespaceImport_Request::clear_force() {
  _impl_.force_ = false;
}
inline bool namespaceImport_Request::_internal_force() const {
  return _impl_.force_;
}
inline bool namespaceImport_Request::force() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.namespaceImport_Request.force)
  return _internal_force();
}
inline void namespaceImport_Request::_internal_set_force(bool value) {
  
  _impl_.force_ = value;
}
inline void namespaceImport_Request::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.namespaceImport_Request.force)
}

// -------------------------------------------------------------------

// policyPost_Request

// string space = 1;
inline void policyPost_Request::clear_space() {
  _impl_.space_.ClearToEmpty();
}
inline const std::string& policyPost_Request::space() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.policyPost_Request.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void policyPost_Request::set_space(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.policyPost_Request.space)
}
inline std::string* policyPost_Request::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.policyPost_Request.space)
  return _s;
}
inline const std::string& policyPost_Request::_internal_space() const {
  return _impl_.space_.Get();
}
inline void policyPost_Request::_internal_set_space(const std::string& value) {
  
  _impl_.space_.Set(value, GetArenaForAllocation());
}
inline std::string* policyPost_Request::_internal_mutable_space() {
  
  return _impl_.space_.Mutable(GetArenaForAllocation());
}
inline std::string* policyPost_Request::release_space() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.policyPost_Request.space)
  return _impl_.space_.Release();
}
inline void policyPost_Request::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  _impl_.space_.SetAllocated(space, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_.IsDefault()) {
    _impl_.space_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.policyPost_Request.space)
}

// string ymlContent = 2;
inline void policyPost_Request::clear_ymlcontent() {
  _impl_.ymlcontent_.ClearToEmpty();
}
inline const std::string& policyPost_Request::ymlcontent() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.policyPost_Request.ymlContent)
  return _internal_ymlcontent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void policyPost_Request::set_ymlcontent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ymlcontent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.policyPost_Request.ymlContent)
}
inline std::string* policyPost_Request::mutable_ymlcontent() {
  std::string* _s = _internal_mutable_ymlcontent();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.policyPost_Request.ymlContent)
  return _s;
}
inline const std::string& policyPost_Request::_internal_ymlcontent() const {
  return _impl_.ymlcontent_.Get();
}
inline void policyPost_Request::_internal_set_ymlcontent(const std::string& value) {
  
  _impl_.ymlcontent_.Set(value, GetArenaForAllocation());
}
inline std::string* policyPost_Request::_internal_mutable_ymlcontent() {
  
  return _impl_.ymlcontent_.Mutable(GetArenaForAllocation());
}
inline std::string* policyPost_Request::release_ymlcontent() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.policyPost_Request.ymlContent)
  return _impl_.ymlcontent_.Release();
}
inline void policyPost_Request::set_allocated_ymlcontent(std::string* ymlcontent) {
  if (ymlcontent != nullptr) {
    
  } else {
    
  }
  _impl_.ymlcontent_.SetAllocated(ymlcontent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ymlcontent_.IsDefault()) {
    _impl_.ymlcontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.policyPost_Request.ymlContent)
}

// -------------------------------------------------------------------

// policyDelete_Request

// string space = 1;
inline void policyDelete_Request::clear_space() {
  _impl_.space_.ClearToEmpty();
}
inline const std::string& policyDelete_Request::space() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.policyDelete_Request.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void policyDelete_Request::set_space(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.policyDelete_Request.space)
}
inline std::string* policyDelete_Request::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.policyDelete_Request.space)
  return _s;
}
inline const std::string& policyDelete_Request::_internal_space() const {
  return _impl_.space_.Get();
}
inline void policyDelete_Request::_internal_set_space(const std::string& value) {
  
  _impl_.space_.Set(value, GetArenaForAllocation());
}
inline std::string* policyDelete_Request::_internal_mutable_space() {
  
  return _impl_.space_.Mutable(GetArenaForAllocation());
}
inline std::string* policyDelete_Request::release_space() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.policyDelete_Request.space)
  return _impl_.space_.Release();
}
inline void policyDelete_Request::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  _impl_.space_.SetAllocated(space, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_.IsDefault()) {
    _impl_.space_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.policyDelete_Request.space)
}

// -------------------------------------------------------------------

// policyValidate_Request

// bool load_in_tester = 1;
inline void policyValidate_Request::clear_load_in_tester() {
  _impl_.load_in_tester_ = false;
}
inline bool policyValidate_Request::_internal_load_in_tester() const {
  return _impl_.load_in_tester_;
}
inline bool policyValidate_Request::load_in_tester() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.policyValidate_Request.load_in_tester)
  return _internal_load_in_tester();
}
inline void policyValidate_Request::_internal_set_load_in_tester(bool value) {
  
  _impl_.load_in_tester_ = value;
}
inline void policyValidate_Request::set_load_in_tester(bool value) {
  _internal_set_load_in_tester(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.policyValidate_Request.load_in_tester)
}

// .google.protobuf.Struct full_policy = 2;
inline bool policyValidate_Request::_internal_has_full_policy() const {
  return this != internal_default_instance() && _impl_.full_policy_ != nullptr;
}
inline bool policyValidate_Request::has_full_policy() const {
  return _internal_has_full_policy();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& policyValidate_Request::_internal_full_policy() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.full_policy_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& policyValidate_Request::full_policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.policyValidate_Request.full_policy)
  return _internal_full_policy();
}
inline void policyValidate_Request::unsafe_arena_set_allocated_full_policy(
    ::PROTOBUF_NAMESPACE_ID::Struct* full_policy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.full_policy_);
  }
  _impl_.full_policy_ = full_policy;
  if (full_policy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.wazuh.api.engine.content.policyValidate_Request.full_policy)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* policyValidate_Request::release_full_policy() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.full_policy_;
  _impl_.full_policy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* policyValidate_Request::unsafe_arena_release_full_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.policyValidate_Request.full_policy)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.full_policy_;
  _impl_.full_policy_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* policyValidate_Request::_internal_mutable_full_policy() {
  
  if (_impl_.full_policy_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.full_policy_ = p;
  }
  return _impl_.full_policy_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* policyValidate_Request::mutable_full_policy() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_full_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.policyValidate_Request.full_policy)
  return _msg;
}
inline void policyValidate_Request::set_allocated_full_policy(::PROTOBUF_NAMESPACE_ID::Struct* full_policy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.full_policy_);
  }
  if (full_policy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(full_policy));
    if (message_arena != submessage_arena) {
      full_policy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, full_policy, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.full_policy_ = full_policy;
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.policyValidate_Request.full_policy)
}

// -------------------------------------------------------------------

// resourceList_Request

// string space = 1;
inline void resourceList_Request::clear_space() {
  _impl_.space_.ClearToEmpty();
}
inline const std::string& resourceList_Request::space() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceList_Request.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceList_Request::set_space(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceList_Request.space)
}
inline std::string* resourceList_Request::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceList_Request.space)
  return _s;
}
inline const std::string& resourceList_Request::_internal_space() const {
  return _impl_.space_.Get();
}
inline void resourceList_Request::_internal_set_space(const std::string& value) {
  
  _impl_.space_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceList_Request::_internal_mutable_space() {
  
  return _impl_.space_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceList_Request::release_space() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceList_Request.space)
  return _impl_.space_.Release();
}
inline void resourceList_Request::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  _impl_.space_.SetAllocated(space, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_.IsDefault()) {
    _impl_.space_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceList_Request.space)
}

// string type = 2;
inline void resourceList_Request::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& resourceList_Request::type() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceList_Request.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceList_Request::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceList_Request.type)
}
inline std::string* resourceList_Request::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceList_Request.type)
  return _s;
}
inline const std::string& resourceList_Request::_internal_type() const {
  return _impl_.type_.Get();
}
inline void resourceList_Request::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceList_Request::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceList_Request::release_type() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceList_Request.type)
  return _impl_.type_.Release();
}
inline void resourceList_Request::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceList_Request.type)
}

// -------------------------------------------------------------------

// resourceList_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void resourceList_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus resourceList_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus resourceList_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceList_Response.status)
  return _internal_status();
}
inline void resourceList_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void resourceList_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceList_Response.status)
}

// optional string error = 2;
inline bool resourceList_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool resourceList_Response::has_error() const {
  return _internal_has_error();
}
inline void resourceList_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& resourceList_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceList_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceList_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceList_Response.error)
}
inline std::string* resourceList_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceList_Response.error)
  return _s;
}
inline const std::string& resourceList_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void resourceList_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceList_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceList_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceList_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void resourceList_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceList_Response.error)
}

// repeated .com.wazuh.api.engine.content.ResourceSummary resources = 3;
inline int resourceList_Response::_internal_resources_size() const {
  return _impl_.resources_.size();
}
inline int resourceList_Response::resources_size() const {
  return _internal_resources_size();
}
inline void resourceList_Response::clear_resources() {
  _impl_.resources_.Clear();
}
inline ::com::wazuh::api::engine::content::ResourceSummary* resourceList_Response::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceList_Response.resources)
  return _impl_.resources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::wazuh::api::engine::content::ResourceSummary >*
resourceList_Response::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:com.wazuh.api.engine.content.resourceList_Response.resources)
  return &_impl_.resources_;
}
inline const ::com::wazuh::api::engine::content::ResourceSummary& resourceList_Response::_internal_resources(int index) const {
  return _impl_.resources_.Get(index);
}
inline const ::com::wazuh::api::engine::content::ResourceSummary& resourceList_Response::resources(int index) const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceList_Response.resources)
  return _internal_resources(index);
}
inline ::com::wazuh::api::engine::content::ResourceSummary* resourceList_Response::_internal_add_resources() {
  return _impl_.resources_.Add();
}
inline ::com::wazuh::api::engine::content::ResourceSummary* resourceList_Response::add_resources() {
  ::com::wazuh::api::engine::content::ResourceSummary* _add = _internal_add_resources();
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.content.resourceList_Response.resources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::com::wazuh::api::engine::content::ResourceSummary >&
resourceList_Response::resources() const {
  // @@protoc_insertion_point(field_list:com.wazuh.api.engine.content.resourceList_Response.resources)
  return _impl_.resources_;
}

// -------------------------------------------------------------------

// resourceGet_Request

// string space = 1;
inline void resourceGet_Request::clear_space() {
  _impl_.space_.ClearToEmpty();
}
inline const std::string& resourceGet_Request::space() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceGet_Request.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceGet_Request::set_space(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceGet_Request.space)
}
inline std::string* resourceGet_Request::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceGet_Request.space)
  return _s;
}
inline const std::string& resourceGet_Request::_internal_space() const {
  return _impl_.space_.Get();
}
inline void resourceGet_Request::_internal_set_space(const std::string& value) {
  
  _impl_.space_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceGet_Request::_internal_mutable_space() {
  
  return _impl_.space_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceGet_Request::release_space() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceGet_Request.space)
  return _impl_.space_.Release();
}
inline void resourceGet_Request::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  _impl_.space_.SetAllocated(space, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_.IsDefault()) {
    _impl_.space_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceGet_Request.space)
}

// string uuid = 2;
inline void resourceGet_Request::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& resourceGet_Request::uuid() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceGet_Request.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceGet_Request::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceGet_Request.uuid)
}
inline std::string* resourceGet_Request::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceGet_Request.uuid)
  return _s;
}
inline const std::string& resourceGet_Request::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void resourceGet_Request::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceGet_Request::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceGet_Request::release_uuid() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceGet_Request.uuid)
  return _impl_.uuid_.Release();
}
inline void resourceGet_Request::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceGet_Request.uuid)
}

// optional bool asJson = 3;
inline bool resourceGet_Request::_internal_has_asjson() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool resourceGet_Request::has_asjson() const {
  return _internal_has_asjson();
}
inline void resourceGet_Request::clear_asjson() {
  _impl_.asjson_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool resourceGet_Request::_internal_asjson() const {
  return _impl_.asjson_;
}
inline bool resourceGet_Request::asjson() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceGet_Request.asJson)
  return _internal_asjson();
}
inline void resourceGet_Request::_internal_set_asjson(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.asjson_ = value;
}
inline void resourceGet_Request::set_asjson(bool value) {
  _internal_set_asjson(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceGet_Request.asJson)
}

// -------------------------------------------------------------------

// resourceGet_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void resourceGet_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus resourceGet_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus resourceGet_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceGet_Response.status)
  return _internal_status();
}
inline void resourceGet_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void resourceGet_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceGet_Response.status)
}

// optional string error = 2;
inline bool resourceGet_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool resourceGet_Response::has_error() const {
  return _internal_has_error();
}
inline void resourceGet_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& resourceGet_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceGet_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceGet_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceGet_Response.error)
}
inline std::string* resourceGet_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceGet_Response.error)
  return _s;
}
inline const std::string& resourceGet_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void resourceGet_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceGet_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceGet_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceGet_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void resourceGet_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceGet_Response.error)
}

// optional string content = 3;
inline bool resourceGet_Response::_internal_has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool resourceGet_Response::has_content() const {
  return _internal_has_content();
}
inline void resourceGet_Response::clear_content() {
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& resourceGet_Response::content() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceGet_Response.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceGet_Response::set_content(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceGet_Response.content)
}
inline std::string* resourceGet_Response::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceGet_Response.content)
  return _s;
}
inline const std::string& resourceGet_Response::_internal_content() const {
  return _impl_.content_.Get();
}
inline void resourceGet_Response::_internal_set_content(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceGet_Response::_internal_mutable_content() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceGet_Response::release_content() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceGet_Response.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void resourceGet_Response::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceGet_Response.content)
}

// -------------------------------------------------------------------

// resourcePost_Request

// string space = 1;
inline void resourcePost_Request::clear_space() {
  _impl_.space_.ClearToEmpty();
}
inline const std::string& resourcePost_Request::space() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourcePost_Request.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourcePost_Request::set_space(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourcePost_Request.space)
}
inline std::string* resourcePost_Request::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourcePost_Request.space)
  return _s;
}
inline const std::string& resourcePost_Request::_internal_space() const {
  return _impl_.space_.Get();
}
inline void resourcePost_Request::_internal_set_space(const std::string& value) {
  
  _impl_.space_.Set(value, GetArenaForAllocation());
}
inline std::string* resourcePost_Request::_internal_mutable_space() {
  
  return _impl_.space_.Mutable(GetArenaForAllocation());
}
inline std::string* resourcePost_Request::release_space() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourcePost_Request.space)
  return _impl_.space_.Release();
}
inline void resourcePost_Request::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  _impl_.space_.SetAllocated(space, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_.IsDefault()) {
    _impl_.space_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourcePost_Request.space)
}

// string type = 2;
inline void resourcePost_Request::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& resourcePost_Request::type() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourcePost_Request.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourcePost_Request::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourcePost_Request.type)
}
inline std::string* resourcePost_Request::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourcePost_Request.type)
  return _s;
}
inline const std::string& resourcePost_Request::_internal_type() const {
  return _impl_.type_.Get();
}
inline void resourcePost_Request::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* resourcePost_Request::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* resourcePost_Request::release_type() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourcePost_Request.type)
  return _impl_.type_.Release();
}
inline void resourcePost_Request::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourcePost_Request.type)
}

// string ymlContent = 3;
inline void resourcePost_Request::clear_ymlcontent() {
  _impl_.ymlcontent_.ClearToEmpty();
}
inline const std::string& resourcePost_Request::ymlcontent() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourcePost_Request.ymlContent)
  return _internal_ymlcontent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourcePost_Request::set_ymlcontent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ymlcontent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourcePost_Request.ymlContent)
}
inline std::string* resourcePost_Request::mutable_ymlcontent() {
  std::string* _s = _internal_mutable_ymlcontent();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourcePost_Request.ymlContent)
  return _s;
}
inline const std::string& resourcePost_Request::_internal_ymlcontent() const {
  return _impl_.ymlcontent_.Get();
}
inline void resourcePost_Request::_internal_set_ymlcontent(const std::string& value) {
  
  _impl_.ymlcontent_.Set(value, GetArenaForAllocation());
}
inline std::string* resourcePost_Request::_internal_mutable_ymlcontent() {
  
  return _impl_.ymlcontent_.Mutable(GetArenaForAllocation());
}
inline std::string* resourcePost_Request::release_ymlcontent() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourcePost_Request.ymlContent)
  return _impl_.ymlcontent_.Release();
}
inline void resourcePost_Request::set_allocated_ymlcontent(std::string* ymlcontent) {
  if (ymlcontent != nullptr) {
    
  } else {
    
  }
  _impl_.ymlcontent_.SetAllocated(ymlcontent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ymlcontent_.IsDefault()) {
    _impl_.ymlcontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourcePost_Request.ymlContent)
}

// -------------------------------------------------------------------

// resourceDelete_Request

// string space = 1;
inline void resourceDelete_Request::clear_space() {
  _impl_.space_.ClearToEmpty();
}
inline const std::string& resourceDelete_Request::space() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceDelete_Request.space)
  return _internal_space();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceDelete_Request::set_space(ArgT0&& arg0, ArgT... args) {
 
 _impl_.space_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceDelete_Request.space)
}
inline std::string* resourceDelete_Request::mutable_space() {
  std::string* _s = _internal_mutable_space();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceDelete_Request.space)
  return _s;
}
inline const std::string& resourceDelete_Request::_internal_space() const {
  return _impl_.space_.Get();
}
inline void resourceDelete_Request::_internal_set_space(const std::string& value) {
  
  _impl_.space_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceDelete_Request::_internal_mutable_space() {
  
  return _impl_.space_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceDelete_Request::release_space() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceDelete_Request.space)
  return _impl_.space_.Release();
}
inline void resourceDelete_Request::set_allocated_space(std::string* space) {
  if (space != nullptr) {
    
  } else {
    
  }
  _impl_.space_.SetAllocated(space, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.space_.IsDefault()) {
    _impl_.space_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceDelete_Request.space)
}

// string uuid = 2;
inline void resourceDelete_Request::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& resourceDelete_Request::uuid() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceDelete_Request.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceDelete_Request::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceDelete_Request.uuid)
}
inline std::string* resourceDelete_Request::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceDelete_Request.uuid)
  return _s;
}
inline const std::string& resourceDelete_Request::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void resourceDelete_Request::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceDelete_Request::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceDelete_Request::release_uuid() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceDelete_Request.uuid)
  return _impl_.uuid_.Release();
}
inline void resourceDelete_Request::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceDelete_Request.uuid)
}

// -------------------------------------------------------------------

// resourceValidate_Request

// string type = 1;
inline void resourceValidate_Request::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& resourceValidate_Request::type() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceValidate_Request.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void resourceValidate_Request::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.content.resourceValidate_Request.type)
}
inline std::string* resourceValidate_Request::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceValidate_Request.type)
  return _s;
}
inline const std::string& resourceValidate_Request::_internal_type() const {
  return _impl_.type_.Get();
}
inline void resourceValidate_Request::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* resourceValidate_Request::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* resourceValidate_Request::release_type() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceValidate_Request.type)
  return _impl_.type_.Release();
}
inline void resourceValidate_Request::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceValidate_Request.type)
}

// .google.protobuf.Struct resource = 2;
inline bool resourceValidate_Request::_internal_has_resource() const {
  return this != internal_default_instance() && _impl_.resource_ != nullptr;
}
inline bool resourceValidate_Request::has_resource() const {
  return _internal_has_resource();
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& resourceValidate_Request::_internal_resource() const {
  const ::PROTOBUF_NAMESPACE_ID::Struct* p = _impl_.resource_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Struct&>(
      ::PROTOBUF_NAMESPACE_ID::_Struct_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Struct& resourceValidate_Request::resource() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.content.resourceValidate_Request.resource)
  return _internal_resource();
}
inline void resourceValidate_Request::unsafe_arena_set_allocated_resource(
    ::PROTOBUF_NAMESPACE_ID::Struct* resource) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  _impl_.resource_ = resource;
  if (resource) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:com.wazuh.api.engine.content.resourceValidate_Request.resource)
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* resourceValidate_Request::release_resource() {
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* resourceValidate_Request::unsafe_arena_release_resource() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.content.resourceValidate_Request.resource)
  
  ::PROTOBUF_NAMESPACE_ID::Struct* temp = _impl_.resource_;
  _impl_.resource_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* resourceValidate_Request::_internal_mutable_resource() {
  
  if (_impl_.resource_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Struct>(GetArenaForAllocation());
    _impl_.resource_ = p;
  }
  return _impl_.resource_;
}
inline ::PROTOBUF_NAMESPACE_ID::Struct* resourceValidate_Request::mutable_resource() {
  ::PROTOBUF_NAMESPACE_ID::Struct* _msg = _internal_mutable_resource();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.content.resourceValidate_Request.resource)
  return _msg;
}
inline void resourceValidate_Request::set_allocated_resource(::PROTOBUF_NAMESPACE_ID::Struct* resource) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.resource_);
  }
  if (resource) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resource));
    if (message_arena != submessage_arena) {
      resource = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.content.resourceValidate_Request.resource)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace content
}  // namespace engine
}  // namespace api
}  // namespace wazuh
}  // namespace com

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_crud_2eproto
