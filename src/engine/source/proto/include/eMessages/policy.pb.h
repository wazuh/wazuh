// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: policy.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_policy_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_policy_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "engine.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_policy_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_policy_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_policy_2eproto;
namespace com {
namespace wazuh {
namespace api {
namespace engine {
namespace policy {
class AssetCleanDeleted_Request;
struct AssetCleanDeleted_RequestDefaultTypeInternal;
extern AssetCleanDeleted_RequestDefaultTypeInternal _AssetCleanDeleted_Request_default_instance_;
class AssetCleanDeleted_Response;
struct AssetCleanDeleted_ResponseDefaultTypeInternal;
extern AssetCleanDeleted_ResponseDefaultTypeInternal _AssetCleanDeleted_Response_default_instance_;
class AssetDelete_Request;
struct AssetDelete_RequestDefaultTypeInternal;
extern AssetDelete_RequestDefaultTypeInternal _AssetDelete_Request_default_instance_;
class AssetDelete_Response;
struct AssetDelete_ResponseDefaultTypeInternal;
extern AssetDelete_ResponseDefaultTypeInternal _AssetDelete_Response_default_instance_;
class AssetGet_Request;
struct AssetGet_RequestDefaultTypeInternal;
extern AssetGet_RequestDefaultTypeInternal _AssetGet_Request_default_instance_;
class AssetGet_Response;
struct AssetGet_ResponseDefaultTypeInternal;
extern AssetGet_ResponseDefaultTypeInternal _AssetGet_Response_default_instance_;
class AssetPost_Request;
struct AssetPost_RequestDefaultTypeInternal;
extern AssetPost_RequestDefaultTypeInternal _AssetPost_Request_default_instance_;
class AssetPost_Response;
struct AssetPost_ResponseDefaultTypeInternal;
extern AssetPost_ResponseDefaultTypeInternal _AssetPost_Response_default_instance_;
class DefaultParentDelete_Request;
struct DefaultParentDelete_RequestDefaultTypeInternal;
extern DefaultParentDelete_RequestDefaultTypeInternal _DefaultParentDelete_Request_default_instance_;
class DefaultParentDelete_Response;
struct DefaultParentDelete_ResponseDefaultTypeInternal;
extern DefaultParentDelete_ResponseDefaultTypeInternal _DefaultParentDelete_Response_default_instance_;
class DefaultParentGet_Request;
struct DefaultParentGet_RequestDefaultTypeInternal;
extern DefaultParentGet_RequestDefaultTypeInternal _DefaultParentGet_Request_default_instance_;
class DefaultParentGet_Response;
struct DefaultParentGet_ResponseDefaultTypeInternal;
extern DefaultParentGet_ResponseDefaultTypeInternal _DefaultParentGet_Response_default_instance_;
class DefaultParentPost_Request;
struct DefaultParentPost_RequestDefaultTypeInternal;
extern DefaultParentPost_RequestDefaultTypeInternal _DefaultParentPost_Request_default_instance_;
class DefaultParentPost_Response;
struct DefaultParentPost_ResponseDefaultTypeInternal;
extern DefaultParentPost_ResponseDefaultTypeInternal _DefaultParentPost_Response_default_instance_;
class NamespacesGet_Request;
struct NamespacesGet_RequestDefaultTypeInternal;
extern NamespacesGet_RequestDefaultTypeInternal _NamespacesGet_Request_default_instance_;
class NamespacesGet_Response;
struct NamespacesGet_ResponseDefaultTypeInternal;
extern NamespacesGet_ResponseDefaultTypeInternal _NamespacesGet_Response_default_instance_;
class PoliciesGet_Request;
struct PoliciesGet_RequestDefaultTypeInternal;
extern PoliciesGet_RequestDefaultTypeInternal _PoliciesGet_Request_default_instance_;
class PoliciesGet_Response;
struct PoliciesGet_ResponseDefaultTypeInternal;
extern PoliciesGet_ResponseDefaultTypeInternal _PoliciesGet_Response_default_instance_;
class StoreDelete_Request;
struct StoreDelete_RequestDefaultTypeInternal;
extern StoreDelete_RequestDefaultTypeInternal _StoreDelete_Request_default_instance_;
class StoreGet_Request;
struct StoreGet_RequestDefaultTypeInternal;
extern StoreGet_RequestDefaultTypeInternal _StoreGet_Request_default_instance_;
class StoreGet_Response;
struct StoreGet_ResponseDefaultTypeInternal;
extern StoreGet_ResponseDefaultTypeInternal _StoreGet_Response_default_instance_;
class StorePost_Request;
struct StorePost_RequestDefaultTypeInternal;
extern StorePost_RequestDefaultTypeInternal _StorePost_Request_default_instance_;
}  // namespace policy
}  // namespace engine
}  // namespace api
}  // namespace wazuh
}  // namespace com
PROTOBUF_NAMESPACE_OPEN
template<> ::com::wazuh::api::engine::policy::AssetCleanDeleted_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::AssetCleanDeleted_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::AssetCleanDeleted_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::AssetCleanDeleted_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::AssetDelete_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::AssetDelete_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::AssetDelete_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::AssetDelete_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::AssetGet_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::AssetGet_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::AssetGet_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::AssetGet_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::AssetPost_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::AssetPost_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::AssetPost_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::AssetPost_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::DefaultParentDelete_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::DefaultParentDelete_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::DefaultParentDelete_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::DefaultParentDelete_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::DefaultParentGet_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::DefaultParentGet_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::DefaultParentGet_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::DefaultParentGet_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::DefaultParentPost_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::DefaultParentPost_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::DefaultParentPost_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::DefaultParentPost_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::NamespacesGet_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::NamespacesGet_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::NamespacesGet_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::NamespacesGet_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::PoliciesGet_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::PoliciesGet_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::PoliciesGet_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::PoliciesGet_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::StoreDelete_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::StoreDelete_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::StoreGet_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::StoreGet_Request>(Arena*);
template<> ::com::wazuh::api::engine::policy::StoreGet_Response* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::StoreGet_Response>(Arena*);
template<> ::com::wazuh::api::engine::policy::StorePost_Request* Arena::CreateMaybeMessage<::com::wazuh::api::engine::policy::StorePost_Request>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace com {
namespace wazuh {
namespace api {
namespace engine {
namespace policy {

// ===================================================================

class StorePost_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.StorePost_Request) */ {
 public:
  inline StorePost_Request() : StorePost_Request(nullptr) {}
  ~StorePost_Request() override;
  explicit PROTOBUF_CONSTEXPR StorePost_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StorePost_Request(const StorePost_Request& from);
  StorePost_Request(StorePost_Request&& from) noexcept
    : StorePost_Request() {
    *this = ::std::move(from);
  }

  inline StorePost_Request& operator=(const StorePost_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorePost_Request& operator=(StorePost_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorePost_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const StorePost_Request* internal_default_instance() {
    return reinterpret_cast<const StorePost_Request*>(
               &_StorePost_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StorePost_Request& a, StorePost_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(StorePost_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorePost_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorePost_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StorePost_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StorePost_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StorePost_Request& from) {
    StorePost_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StorePost_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.StorePost_Request";
  }
  protected:
  explicit StorePost_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.StorePost_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class StoreDelete_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.StoreDelete_Request) */ {
 public:
  inline StoreDelete_Request() : StoreDelete_Request(nullptr) {}
  ~StoreDelete_Request() override;
  explicit PROTOBUF_CONSTEXPR StoreDelete_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreDelete_Request(const StoreDelete_Request& from);
  StoreDelete_Request(StoreDelete_Request&& from) noexcept
    : StoreDelete_Request() {
    *this = ::std::move(from);
  }

  inline StoreDelete_Request& operator=(const StoreDelete_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreDelete_Request& operator=(StoreDelete_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreDelete_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreDelete_Request* internal_default_instance() {
    return reinterpret_cast<const StoreDelete_Request*>(
               &_StoreDelete_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StoreDelete_Request& a, StoreDelete_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreDelete_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreDelete_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreDelete_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreDelete_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreDelete_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreDelete_Request& from) {
    StoreDelete_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreDelete_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.StoreDelete_Request";
  }
  protected:
  explicit StoreDelete_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.StoreDelete_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class StoreGet_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.StoreGet_Request) */ {
 public:
  inline StoreGet_Request() : StoreGet_Request(nullptr) {}
  ~StoreGet_Request() override;
  explicit PROTOBUF_CONSTEXPR StoreGet_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreGet_Request(const StoreGet_Request& from);
  StoreGet_Request(StoreGet_Request&& from) noexcept
    : StoreGet_Request() {
    *this = ::std::move(from);
  }

  inline StoreGet_Request& operator=(const StoreGet_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreGet_Request& operator=(StoreGet_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreGet_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreGet_Request* internal_default_instance() {
    return reinterpret_cast<const StoreGet_Request*>(
               &_StoreGet_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StoreGet_Request& a, StoreGet_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreGet_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreGet_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreGet_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreGet_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreGet_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreGet_Request& from) {
    StoreGet_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreGet_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.StoreGet_Request";
  }
  protected:
  explicit StoreGet_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespacesFieldNumber = 2,
    kPolicyFieldNumber = 1,
  };
  // repeated string namespaces = 2;
  int namespaces_size() const;
  private:
  int _internal_namespaces_size() const;
  public:
  void clear_namespaces();
  const std::string& namespaces(int index) const;
  std::string* mutable_namespaces(int index);
  void set_namespaces(int index, const std::string& value);
  void set_namespaces(int index, std::string&& value);
  void set_namespaces(int index, const char* value);
  void set_namespaces(int index, const char* value, size_t size);
  std::string* add_namespaces();
  void add_namespaces(const std::string& value);
  void add_namespaces(std::string&& value);
  void add_namespaces(const char* value);
  void add_namespaces(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& namespaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_namespaces();
  private:
  const std::string& _internal_namespaces(int index) const;
  std::string* _internal_add_namespaces();
  public:

  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.StoreGet_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> namespaces_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class StoreGet_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.StoreGet_Response) */ {
 public:
  inline StoreGet_Response() : StoreGet_Response(nullptr) {}
  ~StoreGet_Response() override;
  explicit PROTOBUF_CONSTEXPR StoreGet_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreGet_Response(const StoreGet_Response& from);
  StoreGet_Response(StoreGet_Response&& from) noexcept
    : StoreGet_Response() {
    *this = ::std::move(from);
  }

  inline StoreGet_Response& operator=(const StoreGet_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreGet_Response& operator=(StoreGet_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreGet_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreGet_Response* internal_default_instance() {
    return reinterpret_cast<const StoreGet_Response*>(
               &_StoreGet_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StoreGet_Response& a, StoreGet_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreGet_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreGet_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreGet_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreGet_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreGet_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StoreGet_Response& from) {
    StoreGet_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreGet_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.StoreGet_Response";
  }
  protected:
  explicit StoreGet_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kDataFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // optional string data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.StoreGet_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class AssetPost_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.AssetPost_Request) */ {
 public:
  inline AssetPost_Request() : AssetPost_Request(nullptr) {}
  ~AssetPost_Request() override;
  explicit PROTOBUF_CONSTEXPR AssetPost_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetPost_Request(const AssetPost_Request& from);
  AssetPost_Request(AssetPost_Request&& from) noexcept
    : AssetPost_Request() {
    *this = ::std::move(from);
  }

  inline AssetPost_Request& operator=(const AssetPost_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetPost_Request& operator=(AssetPost_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetPost_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetPost_Request* internal_default_instance() {
    return reinterpret_cast<const AssetPost_Request*>(
               &_AssetPost_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AssetPost_Request& a, AssetPost_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetPost_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetPost_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetPost_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetPost_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetPost_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetPost_Request& from) {
    AssetPost_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetPost_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.AssetPost_Request";
  }
  protected:
  explicit AssetPost_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
    kAssetFieldNumber = 2,
    kNamespaceFieldNumber = 3,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // optional string asset = 2;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const std::string& asset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset();
  PROTOBUF_NODISCARD std::string* release_asset();
  void set_allocated_asset(std::string* asset);
  private:
  const std::string& _internal_asset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset(const std::string& value);
  std::string* _internal_mutable_asset();
  public:

  // optional string namespace = 3;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.AssetPost_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class AssetPost_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.AssetPost_Response) */ {
 public:
  inline AssetPost_Response() : AssetPost_Response(nullptr) {}
  ~AssetPost_Response() override;
  explicit PROTOBUF_CONSTEXPR AssetPost_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetPost_Response(const AssetPost_Response& from);
  AssetPost_Response(AssetPost_Response&& from) noexcept
    : AssetPost_Response() {
    *this = ::std::move(from);
  }

  inline AssetPost_Response& operator=(const AssetPost_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetPost_Response& operator=(AssetPost_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetPost_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetPost_Response* internal_default_instance() {
    return reinterpret_cast<const AssetPost_Response*>(
               &_AssetPost_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AssetPost_Response& a, AssetPost_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetPost_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetPost_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetPost_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetPost_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetPost_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetPost_Response& from) {
    AssetPost_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetPost_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.AssetPost_Response";
  }
  protected:
  explicit AssetPost_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kWarningFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // optional string warning = 3;
  bool has_warning() const;
  private:
  bool _internal_has_warning() const;
  public:
  void clear_warning();
  const std::string& warning() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warning(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warning();
  PROTOBUF_NODISCARD std::string* release_warning();
  void set_allocated_warning(std::string* warning);
  private:
  const std::string& _internal_warning() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warning(const std::string& value);
  std::string* _internal_mutable_warning();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.AssetPost_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warning_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class AssetDelete_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.AssetDelete_Request) */ {
 public:
  inline AssetDelete_Request() : AssetDelete_Request(nullptr) {}
  ~AssetDelete_Request() override;
  explicit PROTOBUF_CONSTEXPR AssetDelete_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetDelete_Request(const AssetDelete_Request& from);
  AssetDelete_Request(AssetDelete_Request&& from) noexcept
    : AssetDelete_Request() {
    *this = ::std::move(from);
  }

  inline AssetDelete_Request& operator=(const AssetDelete_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetDelete_Request& operator=(AssetDelete_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetDelete_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetDelete_Request* internal_default_instance() {
    return reinterpret_cast<const AssetDelete_Request*>(
               &_AssetDelete_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AssetDelete_Request& a, AssetDelete_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetDelete_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetDelete_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetDelete_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetDelete_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetDelete_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetDelete_Request& from) {
    AssetDelete_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetDelete_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.AssetDelete_Request";
  }
  protected:
  explicit AssetDelete_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
    kAssetFieldNumber = 2,
    kNamespaceFieldNumber = 3,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // optional string asset = 2;
  bool has_asset() const;
  private:
  bool _internal_has_asset() const;
  public:
  void clear_asset();
  const std::string& asset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset();
  PROTOBUF_NODISCARD std::string* release_asset();
  void set_allocated_asset(std::string* asset);
  private:
  const std::string& _internal_asset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset(const std::string& value);
  std::string* _internal_mutable_asset();
  public:

  // optional string namespace = 3;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.AssetDelete_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class AssetDelete_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.AssetDelete_Response) */ {
 public:
  inline AssetDelete_Response() : AssetDelete_Response(nullptr) {}
  ~AssetDelete_Response() override;
  explicit PROTOBUF_CONSTEXPR AssetDelete_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetDelete_Response(const AssetDelete_Response& from);
  AssetDelete_Response(AssetDelete_Response&& from) noexcept
    : AssetDelete_Response() {
    *this = ::std::move(from);
  }

  inline AssetDelete_Response& operator=(const AssetDelete_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetDelete_Response& operator=(AssetDelete_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetDelete_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetDelete_Response* internal_default_instance() {
    return reinterpret_cast<const AssetDelete_Response*>(
               &_AssetDelete_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AssetDelete_Response& a, AssetDelete_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetDelete_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetDelete_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetDelete_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetDelete_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetDelete_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetDelete_Response& from) {
    AssetDelete_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetDelete_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.AssetDelete_Response";
  }
  protected:
  explicit AssetDelete_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kWarningFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // optional string warning = 3;
  bool has_warning() const;
  private:
  bool _internal_has_warning() const;
  public:
  void clear_warning();
  const std::string& warning() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warning(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warning();
  PROTOBUF_NODISCARD std::string* release_warning();
  void set_allocated_warning(std::string* warning);
  private:
  const std::string& _internal_warning() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warning(const std::string& value);
  std::string* _internal_mutable_warning();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.AssetDelete_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warning_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class AssetGet_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.AssetGet_Request) */ {
 public:
  inline AssetGet_Request() : AssetGet_Request(nullptr) {}
  ~AssetGet_Request() override;
  explicit PROTOBUF_CONSTEXPR AssetGet_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetGet_Request(const AssetGet_Request& from);
  AssetGet_Request(AssetGet_Request&& from) noexcept
    : AssetGet_Request() {
    *this = ::std::move(from);
  }

  inline AssetGet_Request& operator=(const AssetGet_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetGet_Request& operator=(AssetGet_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetGet_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetGet_Request* internal_default_instance() {
    return reinterpret_cast<const AssetGet_Request*>(
               &_AssetGet_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AssetGet_Request& a, AssetGet_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetGet_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetGet_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetGet_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetGet_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetGet_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetGet_Request& from) {
    AssetGet_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetGet_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.AssetGet_Request";
  }
  protected:
  explicit AssetGet_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
    kNamespaceFieldNumber = 2,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // optional string namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.AssetGet_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class AssetGet_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.AssetGet_Response) */ {
 public:
  inline AssetGet_Response() : AssetGet_Response(nullptr) {}
  ~AssetGet_Response() override;
  explicit PROTOBUF_CONSTEXPR AssetGet_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetGet_Response(const AssetGet_Response& from);
  AssetGet_Response(AssetGet_Response&& from) noexcept
    : AssetGet_Response() {
    *this = ::std::move(from);
  }

  inline AssetGet_Response& operator=(const AssetGet_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetGet_Response& operator=(AssetGet_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetGet_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetGet_Response* internal_default_instance() {
    return reinterpret_cast<const AssetGet_Response*>(
               &_AssetGet_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AssetGet_Response& a, AssetGet_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetGet_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetGet_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetGet_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetGet_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetGet_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetGet_Response& from) {
    AssetGet_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetGet_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.AssetGet_Response";
  }
  protected:
  explicit AssetGet_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated string data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const char* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.AssetGet_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class AssetCleanDeleted_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.AssetCleanDeleted_Request) */ {
 public:
  inline AssetCleanDeleted_Request() : AssetCleanDeleted_Request(nullptr) {}
  ~AssetCleanDeleted_Request() override;
  explicit PROTOBUF_CONSTEXPR AssetCleanDeleted_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetCleanDeleted_Request(const AssetCleanDeleted_Request& from);
  AssetCleanDeleted_Request(AssetCleanDeleted_Request&& from) noexcept
    : AssetCleanDeleted_Request() {
    *this = ::std::move(from);
  }

  inline AssetCleanDeleted_Request& operator=(const AssetCleanDeleted_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetCleanDeleted_Request& operator=(AssetCleanDeleted_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetCleanDeleted_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetCleanDeleted_Request* internal_default_instance() {
    return reinterpret_cast<const AssetCleanDeleted_Request*>(
               &_AssetCleanDeleted_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AssetCleanDeleted_Request& a, AssetCleanDeleted_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetCleanDeleted_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetCleanDeleted_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetCleanDeleted_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetCleanDeleted_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetCleanDeleted_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetCleanDeleted_Request& from) {
    AssetCleanDeleted_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetCleanDeleted_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.AssetCleanDeleted_Request";
  }
  protected:
  explicit AssetCleanDeleted_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.AssetCleanDeleted_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class AssetCleanDeleted_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.AssetCleanDeleted_Response) */ {
 public:
  inline AssetCleanDeleted_Response() : AssetCleanDeleted_Response(nullptr) {}
  ~AssetCleanDeleted_Response() override;
  explicit PROTOBUF_CONSTEXPR AssetCleanDeleted_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetCleanDeleted_Response(const AssetCleanDeleted_Response& from);
  AssetCleanDeleted_Response(AssetCleanDeleted_Response&& from) noexcept
    : AssetCleanDeleted_Response() {
    *this = ::std::move(from);
  }

  inline AssetCleanDeleted_Response& operator=(const AssetCleanDeleted_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetCleanDeleted_Response& operator=(AssetCleanDeleted_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetCleanDeleted_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetCleanDeleted_Response* internal_default_instance() {
    return reinterpret_cast<const AssetCleanDeleted_Response*>(
               &_AssetCleanDeleted_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AssetCleanDeleted_Response& a, AssetCleanDeleted_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetCleanDeleted_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetCleanDeleted_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetCleanDeleted_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetCleanDeleted_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetCleanDeleted_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AssetCleanDeleted_Response& from) {
    AssetCleanDeleted_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetCleanDeleted_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.AssetCleanDeleted_Response";
  }
  protected:
  explicit AssetCleanDeleted_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kDataFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // optional string data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.AssetCleanDeleted_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class DefaultParentGet_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.DefaultParentGet_Request) */ {
 public:
  inline DefaultParentGet_Request() : DefaultParentGet_Request(nullptr) {}
  ~DefaultParentGet_Request() override;
  explicit PROTOBUF_CONSTEXPR DefaultParentGet_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultParentGet_Request(const DefaultParentGet_Request& from);
  DefaultParentGet_Request(DefaultParentGet_Request&& from) noexcept
    : DefaultParentGet_Request() {
    *this = ::std::move(from);
  }

  inline DefaultParentGet_Request& operator=(const DefaultParentGet_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultParentGet_Request& operator=(DefaultParentGet_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultParentGet_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefaultParentGet_Request* internal_default_instance() {
    return reinterpret_cast<const DefaultParentGet_Request*>(
               &_DefaultParentGet_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DefaultParentGet_Request& a, DefaultParentGet_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultParentGet_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultParentGet_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefaultParentGet_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefaultParentGet_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultParentGet_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefaultParentGet_Request& from) {
    DefaultParentGet_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultParentGet_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.DefaultParentGet_Request";
  }
  protected:
  explicit DefaultParentGet_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
    kNamespaceFieldNumber = 2,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // optional string namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.DefaultParentGet_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class DefaultParentGet_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.DefaultParentGet_Response) */ {
 public:
  inline DefaultParentGet_Response() : DefaultParentGet_Response(nullptr) {}
  ~DefaultParentGet_Response() override;
  explicit PROTOBUF_CONSTEXPR DefaultParentGet_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultParentGet_Response(const DefaultParentGet_Response& from);
  DefaultParentGet_Response(DefaultParentGet_Response&& from) noexcept
    : DefaultParentGet_Response() {
    *this = ::std::move(from);
  }

  inline DefaultParentGet_Response& operator=(const DefaultParentGet_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultParentGet_Response& operator=(DefaultParentGet_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultParentGet_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefaultParentGet_Response* internal_default_instance() {
    return reinterpret_cast<const DefaultParentGet_Response*>(
               &_DefaultParentGet_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DefaultParentGet_Response& a, DefaultParentGet_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultParentGet_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultParentGet_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefaultParentGet_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefaultParentGet_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultParentGet_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefaultParentGet_Response& from) {
    DefaultParentGet_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultParentGet_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.DefaultParentGet_Response";
  }
  protected:
  explicit DefaultParentGet_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated string data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const char* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.DefaultParentGet_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class DefaultParentPost_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.DefaultParentPost_Request) */ {
 public:
  inline DefaultParentPost_Request() : DefaultParentPost_Request(nullptr) {}
  ~DefaultParentPost_Request() override;
  explicit PROTOBUF_CONSTEXPR DefaultParentPost_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultParentPost_Request(const DefaultParentPost_Request& from);
  DefaultParentPost_Request(DefaultParentPost_Request&& from) noexcept
    : DefaultParentPost_Request() {
    *this = ::std::move(from);
  }

  inline DefaultParentPost_Request& operator=(const DefaultParentPost_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultParentPost_Request& operator=(DefaultParentPost_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultParentPost_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefaultParentPost_Request* internal_default_instance() {
    return reinterpret_cast<const DefaultParentPost_Request*>(
               &_DefaultParentPost_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DefaultParentPost_Request& a, DefaultParentPost_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultParentPost_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultParentPost_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefaultParentPost_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefaultParentPost_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultParentPost_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefaultParentPost_Request& from) {
    DefaultParentPost_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultParentPost_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.DefaultParentPost_Request";
  }
  protected:
  explicit DefaultParentPost_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kParentFieldNumber = 3,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // optional string namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // optional string parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.DefaultParentPost_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class DefaultParentPost_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.DefaultParentPost_Response) */ {
 public:
  inline DefaultParentPost_Response() : DefaultParentPost_Response(nullptr) {}
  ~DefaultParentPost_Response() override;
  explicit PROTOBUF_CONSTEXPR DefaultParentPost_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultParentPost_Response(const DefaultParentPost_Response& from);
  DefaultParentPost_Response(DefaultParentPost_Response&& from) noexcept
    : DefaultParentPost_Response() {
    *this = ::std::move(from);
  }

  inline DefaultParentPost_Response& operator=(const DefaultParentPost_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultParentPost_Response& operator=(DefaultParentPost_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultParentPost_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefaultParentPost_Response* internal_default_instance() {
    return reinterpret_cast<const DefaultParentPost_Response*>(
               &_DefaultParentPost_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DefaultParentPost_Response& a, DefaultParentPost_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultParentPost_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultParentPost_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefaultParentPost_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefaultParentPost_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultParentPost_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefaultParentPost_Response& from) {
    DefaultParentPost_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultParentPost_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.DefaultParentPost_Response";
  }
  protected:
  explicit DefaultParentPost_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kWarningFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // optional string warning = 3;
  bool has_warning() const;
  private:
  bool _internal_has_warning() const;
  public:
  void clear_warning();
  const std::string& warning() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warning(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warning();
  PROTOBUF_NODISCARD std::string* release_warning();
  void set_allocated_warning(std::string* warning);
  private:
  const std::string& _internal_warning() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warning(const std::string& value);
  std::string* _internal_mutable_warning();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.DefaultParentPost_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warning_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class DefaultParentDelete_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.DefaultParentDelete_Request) */ {
 public:
  inline DefaultParentDelete_Request() : DefaultParentDelete_Request(nullptr) {}
  ~DefaultParentDelete_Request() override;
  explicit PROTOBUF_CONSTEXPR DefaultParentDelete_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultParentDelete_Request(const DefaultParentDelete_Request& from);
  DefaultParentDelete_Request(DefaultParentDelete_Request&& from) noexcept
    : DefaultParentDelete_Request() {
    *this = ::std::move(from);
  }

  inline DefaultParentDelete_Request& operator=(const DefaultParentDelete_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultParentDelete_Request& operator=(DefaultParentDelete_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultParentDelete_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefaultParentDelete_Request* internal_default_instance() {
    return reinterpret_cast<const DefaultParentDelete_Request*>(
               &_DefaultParentDelete_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DefaultParentDelete_Request& a, DefaultParentDelete_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultParentDelete_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultParentDelete_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefaultParentDelete_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefaultParentDelete_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultParentDelete_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefaultParentDelete_Request& from) {
    DefaultParentDelete_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultParentDelete_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.DefaultParentDelete_Request";
  }
  protected:
  explicit DefaultParentDelete_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kParentFieldNumber = 3,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // optional string namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const std::string& namespace_() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_namespace_(ArgT0&& arg0, ArgT... args);
  std::string* mutable_namespace_();
  PROTOBUF_NODISCARD std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);
  private:
  const std::string& _internal_namespace_() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_namespace_(const std::string& value);
  std::string* _internal_mutable_namespace_();
  public:

  // optional string parent = 3;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.DefaultParentDelete_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class DefaultParentDelete_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.DefaultParentDelete_Response) */ {
 public:
  inline DefaultParentDelete_Response() : DefaultParentDelete_Response(nullptr) {}
  ~DefaultParentDelete_Response() override;
  explicit PROTOBUF_CONSTEXPR DefaultParentDelete_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DefaultParentDelete_Response(const DefaultParentDelete_Response& from);
  DefaultParentDelete_Response(DefaultParentDelete_Response&& from) noexcept
    : DefaultParentDelete_Response() {
    *this = ::std::move(from);
  }

  inline DefaultParentDelete_Response& operator=(const DefaultParentDelete_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline DefaultParentDelete_Response& operator=(DefaultParentDelete_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DefaultParentDelete_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const DefaultParentDelete_Response* internal_default_instance() {
    return reinterpret_cast<const DefaultParentDelete_Response*>(
               &_DefaultParentDelete_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DefaultParentDelete_Response& a, DefaultParentDelete_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(DefaultParentDelete_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DefaultParentDelete_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DefaultParentDelete_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DefaultParentDelete_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DefaultParentDelete_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DefaultParentDelete_Response& from) {
    DefaultParentDelete_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DefaultParentDelete_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.DefaultParentDelete_Response";
  }
  protected:
  explicit DefaultParentDelete_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kWarningFieldNumber = 3,
    kStatusFieldNumber = 1,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // optional string warning = 3;
  bool has_warning() const;
  private:
  bool _internal_has_warning() const;
  public:
  void clear_warning();
  const std::string& warning() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_warning(ArgT0&& arg0, ArgT... args);
  std::string* mutable_warning();
  PROTOBUF_NODISCARD std::string* release_warning();
  void set_allocated_warning(std::string* warning);
  private:
  const std::string& _internal_warning() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_warning(const std::string& value);
  std::string* _internal_mutable_warning();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.DefaultParentDelete_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr warning_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class PoliciesGet_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.PoliciesGet_Request) */ {
 public:
  inline PoliciesGet_Request() : PoliciesGet_Request(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PoliciesGet_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PoliciesGet_Request(const PoliciesGet_Request& from);
  PoliciesGet_Request(PoliciesGet_Request&& from) noexcept
    : PoliciesGet_Request() {
    *this = ::std::move(from);
  }

  inline PoliciesGet_Request& operator=(const PoliciesGet_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoliciesGet_Request& operator=(PoliciesGet_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PoliciesGet_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const PoliciesGet_Request* internal_default_instance() {
    return reinterpret_cast<const PoliciesGet_Request*>(
               &_PoliciesGet_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PoliciesGet_Request& a, PoliciesGet_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(PoliciesGet_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoliciesGet_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PoliciesGet_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PoliciesGet_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PoliciesGet_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PoliciesGet_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.PoliciesGet_Request";
  }
  protected:
  explicit PoliciesGet_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.PoliciesGet_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class PoliciesGet_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.PoliciesGet_Response) */ {
 public:
  inline PoliciesGet_Response() : PoliciesGet_Response(nullptr) {}
  ~PoliciesGet_Response() override;
  explicit PROTOBUF_CONSTEXPR PoliciesGet_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PoliciesGet_Response(const PoliciesGet_Response& from);
  PoliciesGet_Response(PoliciesGet_Response&& from) noexcept
    : PoliciesGet_Response() {
    *this = ::std::move(from);
  }

  inline PoliciesGet_Response& operator=(const PoliciesGet_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline PoliciesGet_Response& operator=(PoliciesGet_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PoliciesGet_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const PoliciesGet_Response* internal_default_instance() {
    return reinterpret_cast<const PoliciesGet_Response*>(
               &_PoliciesGet_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PoliciesGet_Response& a, PoliciesGet_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(PoliciesGet_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PoliciesGet_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PoliciesGet_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PoliciesGet_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PoliciesGet_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PoliciesGet_Response& from) {
    PoliciesGet_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoliciesGet_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.PoliciesGet_Response";
  }
  protected:
  explicit PoliciesGet_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated string data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const char* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.PoliciesGet_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class NamespacesGet_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.NamespacesGet_Request) */ {
 public:
  inline NamespacesGet_Request() : NamespacesGet_Request(nullptr) {}
  ~NamespacesGet_Request() override;
  explicit PROTOBUF_CONSTEXPR NamespacesGet_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamespacesGet_Request(const NamespacesGet_Request& from);
  NamespacesGet_Request(NamespacesGet_Request&& from) noexcept
    : NamespacesGet_Request() {
    *this = ::std::move(from);
  }

  inline NamespacesGet_Request& operator=(const NamespacesGet_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamespacesGet_Request& operator=(NamespacesGet_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamespacesGet_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamespacesGet_Request* internal_default_instance() {
    return reinterpret_cast<const NamespacesGet_Request*>(
               &_NamespacesGet_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(NamespacesGet_Request& a, NamespacesGet_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(NamespacesGet_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamespacesGet_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamespacesGet_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamespacesGet_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamespacesGet_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamespacesGet_Request& from) {
    NamespacesGet_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamespacesGet_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.NamespacesGet_Request";
  }
  protected:
  explicit NamespacesGet_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPolicyFieldNumber = 1,
  };
  // optional string policy = 1;
  bool has_policy() const;
  private:
  bool _internal_has_policy() const;
  public:
  void clear_policy();
  const std::string& policy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_policy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_policy();
  PROTOBUF_NODISCARD std::string* release_policy();
  void set_allocated_policy(std::string* policy);
  private:
  const std::string& _internal_policy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_policy(const std::string& value);
  std::string* _internal_mutable_policy();
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.NamespacesGet_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr policy_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// -------------------------------------------------------------------

class NamespacesGet_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:com.wazuh.api.engine.policy.NamespacesGet_Response) */ {
 public:
  inline NamespacesGet_Response() : NamespacesGet_Response(nullptr) {}
  ~NamespacesGet_Response() override;
  explicit PROTOBUF_CONSTEXPR NamespacesGet_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamespacesGet_Response(const NamespacesGet_Response& from);
  NamespacesGet_Response(NamespacesGet_Response&& from) noexcept
    : NamespacesGet_Response() {
    *this = ::std::move(from);
  }

  inline NamespacesGet_Response& operator=(const NamespacesGet_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamespacesGet_Response& operator=(NamespacesGet_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NamespacesGet_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamespacesGet_Response* internal_default_instance() {
    return reinterpret_cast<const NamespacesGet_Response*>(
               &_NamespacesGet_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(NamespacesGet_Response& a, NamespacesGet_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(NamespacesGet_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamespacesGet_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamespacesGet_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamespacesGet_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NamespacesGet_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NamespacesGet_Response& from) {
    NamespacesGet_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamespacesGet_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "com.wazuh.api.engine.policy.NamespacesGet_Response";
  }
  protected:
  explicit NamespacesGet_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kErrorFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated string data = 3;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const char* value, size_t size);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_data();
  private:
  const std::string& _internal_data(int index) const;
  std::string* _internal_add_data();
  public:

  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // .com.wazuh.api.engine.ReturnStatus status = 1;
  void clear_status();
  ::com::wazuh::api::engine::ReturnStatus status() const;
  void set_status(::com::wazuh::api::engine::ReturnStatus value);
  private:
  ::com::wazuh::api::engine::ReturnStatus _internal_status() const;
  void _internal_set_status(::com::wazuh::api::engine::ReturnStatus value);
  public:

  // @@protoc_insertion_point(class_scope:com.wazuh.api.engine.policy.NamespacesGet_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    int status_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_policy_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StorePost_Request

// optional string policy = 1;
inline bool StorePost_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StorePost_Request::has_policy() const {
  return _internal_has_policy();
}
inline void StorePost_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StorePost_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.StorePost_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StorePost_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.StorePost_Request.policy)
}
inline std::string* StorePost_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.StorePost_Request.policy)
  return _s;
}
inline const std::string& StorePost_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void StorePost_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* StorePost_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* StorePost_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.StorePost_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StorePost_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.StorePost_Request.policy)
}

// -------------------------------------------------------------------

// StoreDelete_Request

// optional string policy = 1;
inline bool StoreDelete_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreDelete_Request::has_policy() const {
  return _internal_has_policy();
}
inline void StoreDelete_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreDelete_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.StoreDelete_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreDelete_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.StoreDelete_Request.policy)
}
inline std::string* StoreDelete_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.StoreDelete_Request.policy)
  return _s;
}
inline const std::string& StoreDelete_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void StoreDelete_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreDelete_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreDelete_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.StoreDelete_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreDelete_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.StoreDelete_Request.policy)
}

// -------------------------------------------------------------------

// StoreGet_Request

// optional string policy = 1;
inline bool StoreGet_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreGet_Request::has_policy() const {
  return _internal_has_policy();
}
inline void StoreGet_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreGet_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.StoreGet_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreGet_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.StoreGet_Request.policy)
}
inline std::string* StoreGet_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.StoreGet_Request.policy)
  return _s;
}
inline const std::string& StoreGet_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void StoreGet_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreGet_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreGet_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.StoreGet_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreGet_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.StoreGet_Request.policy)
}

// repeated string namespaces = 2;
inline int StoreGet_Request::_internal_namespaces_size() const {
  return _impl_.namespaces_.size();
}
inline int StoreGet_Request::namespaces_size() const {
  return _internal_namespaces_size();
}
inline void StoreGet_Request::clear_namespaces() {
  _impl_.namespaces_.Clear();
}
inline std::string* StoreGet_Request::add_namespaces() {
  std::string* _s = _internal_add_namespaces();
  // @@protoc_insertion_point(field_add_mutable:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
  return _s;
}
inline const std::string& StoreGet_Request::_internal_namespaces(int index) const {
  return _impl_.namespaces_.Get(index);
}
inline const std::string& StoreGet_Request::namespaces(int index) const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
  return _internal_namespaces(index);
}
inline std::string* StoreGet_Request::mutable_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
  return _impl_.namespaces_.Mutable(index);
}
inline void StoreGet_Request::set_namespaces(int index, const std::string& value) {
  _impl_.namespaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
}
inline void StoreGet_Request::set_namespaces(int index, std::string&& value) {
  _impl_.namespaces_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
}
inline void StoreGet_Request::set_namespaces(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.namespaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
}
inline void StoreGet_Request::set_namespaces(int index, const char* value, size_t size) {
  _impl_.namespaces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
}
inline std::string* StoreGet_Request::_internal_add_namespaces() {
  return _impl_.namespaces_.Add();
}
inline void StoreGet_Request::add_namespaces(const std::string& value) {
  _impl_.namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
}
inline void StoreGet_Request::add_namespaces(std::string&& value) {
  _impl_.namespaces_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
}
inline void StoreGet_Request::add_namespaces(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
}
inline void StoreGet_Request::add_namespaces(const char* value, size_t size) {
  _impl_.namespaces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StoreGet_Request::namespaces() const {
  // @@protoc_insertion_point(field_list:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
  return _impl_.namespaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StoreGet_Request::mutable_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:com.wazuh.api.engine.policy.StoreGet_Request.namespaces)
  return &_impl_.namespaces_;
}

// -------------------------------------------------------------------

// StoreGet_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void StoreGet_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus StoreGet_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus StoreGet_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.StoreGet_Response.status)
  return _internal_status();
}
inline void StoreGet_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void StoreGet_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.StoreGet_Response.status)
}

// optional string error = 2;
inline bool StoreGet_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreGet_Response::has_error() const {
  return _internal_has_error();
}
inline void StoreGet_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreGet_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.StoreGet_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreGet_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.StoreGet_Response.error)
}
inline std::string* StoreGet_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.StoreGet_Response.error)
  return _s;
}
inline const std::string& StoreGet_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void StoreGet_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreGet_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreGet_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.StoreGet_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreGet_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.StoreGet_Response.error)
}

// optional string data = 3;
inline bool StoreGet_Response::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreGet_Response::has_data() const {
  return _internal_has_data();
}
inline void StoreGet_Response::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreGet_Response::data() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.StoreGet_Response.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreGet_Response::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.StoreGet_Response.data)
}
inline std::string* StoreGet_Response::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.StoreGet_Response.data)
  return _s;
}
inline const std::string& StoreGet_Response::_internal_data() const {
  return _impl_.data_.Get();
}
inline void StoreGet_Response::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* StoreGet_Response::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* StoreGet_Response::release_data() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.StoreGet_Response.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreGet_Response::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.StoreGet_Response.data)
}

// -------------------------------------------------------------------

// AssetPost_Request

// optional string policy = 1;
inline bool AssetPost_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AssetPost_Request::has_policy() const {
  return _internal_has_policy();
}
inline void AssetPost_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AssetPost_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetPost_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetPost_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetPost_Request.policy)
}
inline std::string* AssetPost_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetPost_Request.policy)
  return _s;
}
inline const std::string& AssetPost_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void AssetPost_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetPost_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetPost_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetPost_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetPost_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetPost_Request.policy)
}

// optional string asset = 2;
inline bool AssetPost_Request::_internal_has_asset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AssetPost_Request::has_asset() const {
  return _internal_has_asset();
}
inline void AssetPost_Request::clear_asset() {
  _impl_.asset_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AssetPost_Request::asset() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetPost_Request.asset)
  return _internal_asset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetPost_Request::set_asset(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.asset_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetPost_Request.asset)
}
inline std::string* AssetPost_Request::mutable_asset() {
  std::string* _s = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetPost_Request.asset)
  return _s;
}
inline const std::string& AssetPost_Request::_internal_asset() const {
  return _impl_.asset_.Get();
}
inline void AssetPost_Request::_internal_set_asset(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.asset_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetPost_Request::_internal_mutable_asset() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.asset_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetPost_Request::release_asset() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetPost_Request.asset)
  if (!_internal_has_asset()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.asset_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_.IsDefault()) {
    _impl_.asset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetPost_Request::set_allocated_asset(std::string* asset) {
  if (asset != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.asset_.SetAllocated(asset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_.IsDefault()) {
    _impl_.asset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetPost_Request.asset)
}

// optional string namespace = 3;
inline bool AssetPost_Request::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AssetPost_Request::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void AssetPost_Request::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AssetPost_Request::namespace_() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetPost_Request.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetPost_Request::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetPost_Request.namespace)
}
inline std::string* AssetPost_Request::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetPost_Request.namespace)
  return _s;
}
inline const std::string& AssetPost_Request::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void AssetPost_Request::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* AssetPost_Request::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* AssetPost_Request::release_namespace_() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetPost_Request.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetPost_Request::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetPost_Request.namespace)
}

// -------------------------------------------------------------------

// AssetPost_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void AssetPost_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus AssetPost_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus AssetPost_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetPost_Response.status)
  return _internal_status();
}
inline void AssetPost_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void AssetPost_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetPost_Response.status)
}

// optional string error = 2;
inline bool AssetPost_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AssetPost_Response::has_error() const {
  return _internal_has_error();
}
inline void AssetPost_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AssetPost_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetPost_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetPost_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetPost_Response.error)
}
inline std::string* AssetPost_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetPost_Response.error)
  return _s;
}
inline const std::string& AssetPost_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void AssetPost_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetPost_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetPost_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetPost_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetPost_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetPost_Response.error)
}

// optional string warning = 3;
inline bool AssetPost_Response::_internal_has_warning() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AssetPost_Response::has_warning() const {
  return _internal_has_warning();
}
inline void AssetPost_Response::clear_warning() {
  _impl_.warning_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AssetPost_Response::warning() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetPost_Response.warning)
  return _internal_warning();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetPost_Response::set_warning(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.warning_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetPost_Response.warning)
}
inline std::string* AssetPost_Response::mutable_warning() {
  std::string* _s = _internal_mutable_warning();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetPost_Response.warning)
  return _s;
}
inline const std::string& AssetPost_Response::_internal_warning() const {
  return _impl_.warning_.Get();
}
inline void AssetPost_Response::_internal_set_warning(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.warning_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetPost_Response::_internal_mutable_warning() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.warning_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetPost_Response::release_warning() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetPost_Response.warning)
  if (!_internal_has_warning()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.warning_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetPost_Response::set_allocated_warning(std::string* warning) {
  if (warning != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.warning_.SetAllocated(warning, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetPost_Response.warning)
}

// -------------------------------------------------------------------

// AssetDelete_Request

// optional string policy = 1;
inline bool AssetDelete_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AssetDelete_Request::has_policy() const {
  return _internal_has_policy();
}
inline void AssetDelete_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AssetDelete_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetDelete_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetDelete_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetDelete_Request.policy)
}
inline std::string* AssetDelete_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetDelete_Request.policy)
  return _s;
}
inline const std::string& AssetDelete_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void AssetDelete_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetDelete_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetDelete_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetDelete_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetDelete_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetDelete_Request.policy)
}

// optional string asset = 2;
inline bool AssetDelete_Request::_internal_has_asset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AssetDelete_Request::has_asset() const {
  return _internal_has_asset();
}
inline void AssetDelete_Request::clear_asset() {
  _impl_.asset_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AssetDelete_Request::asset() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetDelete_Request.asset)
  return _internal_asset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetDelete_Request::set_asset(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.asset_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetDelete_Request.asset)
}
inline std::string* AssetDelete_Request::mutable_asset() {
  std::string* _s = _internal_mutable_asset();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetDelete_Request.asset)
  return _s;
}
inline const std::string& AssetDelete_Request::_internal_asset() const {
  return _impl_.asset_.Get();
}
inline void AssetDelete_Request::_internal_set_asset(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.asset_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetDelete_Request::_internal_mutable_asset() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.asset_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetDelete_Request::release_asset() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetDelete_Request.asset)
  if (!_internal_has_asset()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.asset_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_.IsDefault()) {
    _impl_.asset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetDelete_Request::set_allocated_asset(std::string* asset) {
  if (asset != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.asset_.SetAllocated(asset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.asset_.IsDefault()) {
    _impl_.asset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetDelete_Request.asset)
}

// optional string namespace = 3;
inline bool AssetDelete_Request::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AssetDelete_Request::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void AssetDelete_Request::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AssetDelete_Request::namespace_() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetDelete_Request.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetDelete_Request::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetDelete_Request.namespace)
}
inline std::string* AssetDelete_Request::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetDelete_Request.namespace)
  return _s;
}
inline const std::string& AssetDelete_Request::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void AssetDelete_Request::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* AssetDelete_Request::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* AssetDelete_Request::release_namespace_() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetDelete_Request.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetDelete_Request::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetDelete_Request.namespace)
}

// -------------------------------------------------------------------

// AssetDelete_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void AssetDelete_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus AssetDelete_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus AssetDelete_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetDelete_Response.status)
  return _internal_status();
}
inline void AssetDelete_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void AssetDelete_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetDelete_Response.status)
}

// optional string error = 2;
inline bool AssetDelete_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AssetDelete_Response::has_error() const {
  return _internal_has_error();
}
inline void AssetDelete_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AssetDelete_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetDelete_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetDelete_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetDelete_Response.error)
}
inline std::string* AssetDelete_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetDelete_Response.error)
  return _s;
}
inline const std::string& AssetDelete_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void AssetDelete_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetDelete_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetDelete_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetDelete_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetDelete_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetDelete_Response.error)
}

// optional string warning = 3;
inline bool AssetDelete_Response::_internal_has_warning() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AssetDelete_Response::has_warning() const {
  return _internal_has_warning();
}
inline void AssetDelete_Response::clear_warning() {
  _impl_.warning_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AssetDelete_Response::warning() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetDelete_Response.warning)
  return _internal_warning();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetDelete_Response::set_warning(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.warning_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetDelete_Response.warning)
}
inline std::string* AssetDelete_Response::mutable_warning() {
  std::string* _s = _internal_mutable_warning();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetDelete_Response.warning)
  return _s;
}
inline const std::string& AssetDelete_Response::_internal_warning() const {
  return _impl_.warning_.Get();
}
inline void AssetDelete_Response::_internal_set_warning(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.warning_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetDelete_Response::_internal_mutable_warning() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.warning_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetDelete_Response::release_warning() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetDelete_Response.warning)
  if (!_internal_has_warning()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.warning_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetDelete_Response::set_allocated_warning(std::string* warning) {
  if (warning != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.warning_.SetAllocated(warning, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetDelete_Response.warning)
}

// -------------------------------------------------------------------

// AssetGet_Request

// optional string policy = 1;
inline bool AssetGet_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AssetGet_Request::has_policy() const {
  return _internal_has_policy();
}
inline void AssetGet_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AssetGet_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetGet_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetGet_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetGet_Request.policy)
}
inline std::string* AssetGet_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetGet_Request.policy)
  return _s;
}
inline const std::string& AssetGet_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void AssetGet_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetGet_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetGet_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetGet_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetGet_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetGet_Request.policy)
}

// optional string namespace = 2;
inline bool AssetGet_Request::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AssetGet_Request::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void AssetGet_Request::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AssetGet_Request::namespace_() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetGet_Request.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetGet_Request::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetGet_Request.namespace)
}
inline std::string* AssetGet_Request::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetGet_Request.namespace)
  return _s;
}
inline const std::string& AssetGet_Request::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void AssetGet_Request::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* AssetGet_Request::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* AssetGet_Request::release_namespace_() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetGet_Request.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetGet_Request::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetGet_Request.namespace)
}

// -------------------------------------------------------------------

// AssetGet_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void AssetGet_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus AssetGet_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus AssetGet_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetGet_Response.status)
  return _internal_status();
}
inline void AssetGet_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void AssetGet_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetGet_Response.status)
}

// optional string error = 2;
inline bool AssetGet_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AssetGet_Response::has_error() const {
  return _internal_has_error();
}
inline void AssetGet_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AssetGet_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetGet_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetGet_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetGet_Response.error)
}
inline std::string* AssetGet_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetGet_Response.error)
  return _s;
}
inline const std::string& AssetGet_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void AssetGet_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetGet_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetGet_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetGet_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetGet_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetGet_Response.error)
}

// repeated string data = 3;
inline int AssetGet_Response::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int AssetGet_Response::data_size() const {
  return _internal_data_size();
}
inline void AssetGet_Response::clear_data() {
  _impl_.data_.Clear();
}
inline std::string* AssetGet_Response::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:com.wazuh.api.engine.policy.AssetGet_Response.data)
  return _s;
}
inline const std::string& AssetGet_Response::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const std::string& AssetGet_Response::data(int index) const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetGet_Response.data)
  return _internal_data(index);
}
inline std::string* AssetGet_Response::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetGet_Response.data)
  return _impl_.data_.Mutable(index);
}
inline void AssetGet_Response::set_data(int index, const std::string& value) {
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetGet_Response.data)
}
inline void AssetGet_Response::set_data(int index, std::string&& value) {
  _impl_.data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetGet_Response.data)
}
inline void AssetGet_Response::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.wazuh.api.engine.policy.AssetGet_Response.data)
}
inline void AssetGet_Response::set_data(int index, const char* value, size_t size) {
  _impl_.data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.wazuh.api.engine.policy.AssetGet_Response.data)
}
inline std::string* AssetGet_Response::_internal_add_data() {
  return _impl_.data_.Add();
}
inline void AssetGet_Response::add_data(const std::string& value) {
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.AssetGet_Response.data)
}
inline void AssetGet_Response::add_data(std::string&& value) {
  _impl_.data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.AssetGet_Response.data)
}
inline void AssetGet_Response::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.wazuh.api.engine.policy.AssetGet_Response.data)
}
inline void AssetGet_Response::add_data(const char* value, size_t size) {
  _impl_.data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.wazuh.api.engine.policy.AssetGet_Response.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AssetGet_Response::data() const {
  // @@protoc_insertion_point(field_list:com.wazuh.api.engine.policy.AssetGet_Response.data)
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AssetGet_Response::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:com.wazuh.api.engine.policy.AssetGet_Response.data)
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// AssetCleanDeleted_Request

// optional string policy = 1;
inline bool AssetCleanDeleted_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AssetCleanDeleted_Request::has_policy() const {
  return _internal_has_policy();
}
inline void AssetCleanDeleted_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AssetCleanDeleted_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetCleanDeleted_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetCleanDeleted_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetCleanDeleted_Request.policy)
}
inline std::string* AssetCleanDeleted_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetCleanDeleted_Request.policy)
  return _s;
}
inline const std::string& AssetCleanDeleted_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void AssetCleanDeleted_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetCleanDeleted_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetCleanDeleted_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetCleanDeleted_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetCleanDeleted_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetCleanDeleted_Request.policy)
}

// -------------------------------------------------------------------

// AssetCleanDeleted_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void AssetCleanDeleted_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus AssetCleanDeleted_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus AssetCleanDeleted_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.status)
  return _internal_status();
}
inline void AssetCleanDeleted_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void AssetCleanDeleted_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.status)
}

// optional string error = 2;
inline bool AssetCleanDeleted_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AssetCleanDeleted_Response::has_error() const {
  return _internal_has_error();
}
inline void AssetCleanDeleted_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AssetCleanDeleted_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetCleanDeleted_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.error)
}
inline std::string* AssetCleanDeleted_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.error)
  return _s;
}
inline const std::string& AssetCleanDeleted_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void AssetCleanDeleted_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetCleanDeleted_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetCleanDeleted_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetCleanDeleted_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.error)
}

// optional string data = 3;
inline bool AssetCleanDeleted_Response::_internal_has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AssetCleanDeleted_Response::has_data() const {
  return _internal_has_data();
}
inline void AssetCleanDeleted_Response::clear_data() {
  _impl_.data_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AssetCleanDeleted_Response::data() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AssetCleanDeleted_Response::set_data(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.data)
}
inline std::string* AssetCleanDeleted_Response::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.data)
  return _s;
}
inline const std::string& AssetCleanDeleted_Response::_internal_data() const {
  return _impl_.data_.Get();
}
inline void AssetCleanDeleted_Response::_internal_set_data(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* AssetCleanDeleted_Response::_internal_mutable_data() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* AssetCleanDeleted_Response::release_data() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AssetCleanDeleted_Response::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.AssetCleanDeleted_Response.data)
}

// -------------------------------------------------------------------

// DefaultParentGet_Request

// optional string policy = 1;
inline bool DefaultParentGet_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DefaultParentGet_Request::has_policy() const {
  return _internal_has_policy();
}
inline void DefaultParentGet_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefaultParentGet_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentGet_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentGet_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentGet_Request.policy)
}
inline std::string* DefaultParentGet_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentGet_Request.policy)
  return _s;
}
inline const std::string& DefaultParentGet_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void DefaultParentGet_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentGet_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentGet_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentGet_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentGet_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentGet_Request.policy)
}

// optional string namespace = 2;
inline bool DefaultParentGet_Request::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DefaultParentGet_Request::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void DefaultParentGet_Request::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DefaultParentGet_Request::namespace_() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentGet_Request.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentGet_Request::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentGet_Request.namespace)
}
inline std::string* DefaultParentGet_Request::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentGet_Request.namespace)
  return _s;
}
inline const std::string& DefaultParentGet_Request::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void DefaultParentGet_Request::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentGet_Request::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentGet_Request::release_namespace_() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentGet_Request.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentGet_Request::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentGet_Request.namespace)
}

// -------------------------------------------------------------------

// DefaultParentGet_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void DefaultParentGet_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus DefaultParentGet_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus DefaultParentGet_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentGet_Response.status)
  return _internal_status();
}
inline void DefaultParentGet_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void DefaultParentGet_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentGet_Response.status)
}

// optional string error = 2;
inline bool DefaultParentGet_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DefaultParentGet_Response::has_error() const {
  return _internal_has_error();
}
inline void DefaultParentGet_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefaultParentGet_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentGet_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentGet_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentGet_Response.error)
}
inline std::string* DefaultParentGet_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentGet_Response.error)
  return _s;
}
inline const std::string& DefaultParentGet_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void DefaultParentGet_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentGet_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentGet_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentGet_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentGet_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentGet_Response.error)
}

// repeated string data = 3;
inline int DefaultParentGet_Response::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int DefaultParentGet_Response::data_size() const {
  return _internal_data_size();
}
inline void DefaultParentGet_Response::clear_data() {
  _impl_.data_.Clear();
}
inline std::string* DefaultParentGet_Response::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
  return _s;
}
inline const std::string& DefaultParentGet_Response::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const std::string& DefaultParentGet_Response::data(int index) const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
  return _internal_data(index);
}
inline std::string* DefaultParentGet_Response::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
  return _impl_.data_.Mutable(index);
}
inline void DefaultParentGet_Response::set_data(int index, const std::string& value) {
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
}
inline void DefaultParentGet_Response::set_data(int index, std::string&& value) {
  _impl_.data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
}
inline void DefaultParentGet_Response::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
}
inline void DefaultParentGet_Response::set_data(int index, const char* value, size_t size) {
  _impl_.data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
}
inline std::string* DefaultParentGet_Response::_internal_add_data() {
  return _impl_.data_.Add();
}
inline void DefaultParentGet_Response::add_data(const std::string& value) {
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
}
inline void DefaultParentGet_Response::add_data(std::string&& value) {
  _impl_.data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
}
inline void DefaultParentGet_Response::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
}
inline void DefaultParentGet_Response::add_data(const char* value, size_t size) {
  _impl_.data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DefaultParentGet_Response::data() const {
  // @@protoc_insertion_point(field_list:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DefaultParentGet_Response::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:com.wazuh.api.engine.policy.DefaultParentGet_Response.data)
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// DefaultParentPost_Request

// optional string policy = 1;
inline bool DefaultParentPost_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DefaultParentPost_Request::has_policy() const {
  return _internal_has_policy();
}
inline void DefaultParentPost_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefaultParentPost_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentPost_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentPost_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentPost_Request.policy)
}
inline std::string* DefaultParentPost_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentPost_Request.policy)
  return _s;
}
inline const std::string& DefaultParentPost_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void DefaultParentPost_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentPost_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentPost_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentPost_Request.policy)
}

// optional string namespace = 2;
inline bool DefaultParentPost_Request::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DefaultParentPost_Request::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void DefaultParentPost_Request::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DefaultParentPost_Request::namespace_() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentPost_Request.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentPost_Request::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentPost_Request.namespace)
}
inline std::string* DefaultParentPost_Request::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentPost_Request.namespace)
  return _s;
}
inline const std::string& DefaultParentPost_Request::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void DefaultParentPost_Request::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Request::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Request::release_namespace_() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentPost_Request.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentPost_Request::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentPost_Request.namespace)
}

// optional string parent = 3;
inline bool DefaultParentPost_Request::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DefaultParentPost_Request::has_parent() const {
  return _internal_has_parent();
}
inline void DefaultParentPost_Request::clear_parent() {
  _impl_.parent_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DefaultParentPost_Request::parent() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentPost_Request.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentPost_Request::set_parent(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentPost_Request.parent)
}
inline std::string* DefaultParentPost_Request::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentPost_Request.parent)
  return _s;
}
inline const std::string& DefaultParentPost_Request::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void DefaultParentPost_Request::_internal_set_parent(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Request::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Request::release_parent() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentPost_Request.parent)
  if (!_internal_has_parent()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.parent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentPost_Request::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentPost_Request.parent)
}

// -------------------------------------------------------------------

// DefaultParentPost_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void DefaultParentPost_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus DefaultParentPost_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus DefaultParentPost_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentPost_Response.status)
  return _internal_status();
}
inline void DefaultParentPost_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void DefaultParentPost_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentPost_Response.status)
}

// optional string error = 2;
inline bool DefaultParentPost_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DefaultParentPost_Response::has_error() const {
  return _internal_has_error();
}
inline void DefaultParentPost_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefaultParentPost_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentPost_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentPost_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentPost_Response.error)
}
inline std::string* DefaultParentPost_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentPost_Response.error)
  return _s;
}
inline const std::string& DefaultParentPost_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void DefaultParentPost_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentPost_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentPost_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentPost_Response.error)
}

// optional string warning = 3;
inline bool DefaultParentPost_Response::_internal_has_warning() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DefaultParentPost_Response::has_warning() const {
  return _internal_has_warning();
}
inline void DefaultParentPost_Response::clear_warning() {
  _impl_.warning_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DefaultParentPost_Response::warning() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentPost_Response.warning)
  return _internal_warning();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentPost_Response::set_warning(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.warning_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentPost_Response.warning)
}
inline std::string* DefaultParentPost_Response::mutable_warning() {
  std::string* _s = _internal_mutable_warning();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentPost_Response.warning)
  return _s;
}
inline const std::string& DefaultParentPost_Response::_internal_warning() const {
  return _impl_.warning_.Get();
}
inline void DefaultParentPost_Response::_internal_set_warning(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.warning_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Response::_internal_mutable_warning() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.warning_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentPost_Response::release_warning() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentPost_Response.warning)
  if (!_internal_has_warning()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.warning_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentPost_Response::set_allocated_warning(std::string* warning) {
  if (warning != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.warning_.SetAllocated(warning, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentPost_Response.warning)
}

// -------------------------------------------------------------------

// DefaultParentDelete_Request

// optional string policy = 1;
inline bool DefaultParentDelete_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DefaultParentDelete_Request::has_policy() const {
  return _internal_has_policy();
}
inline void DefaultParentDelete_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefaultParentDelete_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentDelete_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentDelete_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentDelete_Request.policy)
}
inline std::string* DefaultParentDelete_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentDelete_Request.policy)
  return _s;
}
inline const std::string& DefaultParentDelete_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void DefaultParentDelete_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentDelete_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentDelete_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentDelete_Request.policy)
}

// optional string namespace = 2;
inline bool DefaultParentDelete_Request::_internal_has_namespace_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DefaultParentDelete_Request::has_namespace_() const {
  return _internal_has_namespace_();
}
inline void DefaultParentDelete_Request::clear_namespace_() {
  _impl_.namespace__.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DefaultParentDelete_Request::namespace_() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentDelete_Request.namespace)
  return _internal_namespace_();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentDelete_Request::set_namespace_(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.namespace__.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentDelete_Request.namespace)
}
inline std::string* DefaultParentDelete_Request::mutable_namespace_() {
  std::string* _s = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentDelete_Request.namespace)
  return _s;
}
inline const std::string& DefaultParentDelete_Request::_internal_namespace_() const {
  return _impl_.namespace__.Get();
}
inline void DefaultParentDelete_Request::_internal_set_namespace_(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.namespace__.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Request::_internal_mutable_namespace_() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.namespace__.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Request::release_namespace_() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentDelete_Request.namespace)
  if (!_internal_has_namespace_()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.namespace__.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentDelete_Request::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.namespace__.SetAllocated(namespace_, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.namespace__.IsDefault()) {
    _impl_.namespace__.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentDelete_Request.namespace)
}

// optional string parent = 3;
inline bool DefaultParentDelete_Request::_internal_has_parent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DefaultParentDelete_Request::has_parent() const {
  return _internal_has_parent();
}
inline void DefaultParentDelete_Request::clear_parent() {
  _impl_.parent_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DefaultParentDelete_Request::parent() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentDelete_Request.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentDelete_Request::set_parent(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000004u;
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentDelete_Request.parent)
}
inline std::string* DefaultParentDelete_Request::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentDelete_Request.parent)
  return _s;
}
inline const std::string& DefaultParentDelete_Request::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void DefaultParentDelete_Request::_internal_set_parent(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Request::_internal_mutable_parent() {
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Request::release_parent() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentDelete_Request.parent)
  if (!_internal_has_parent()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* p = _impl_.parent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentDelete_Request::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentDelete_Request.parent)
}

// -------------------------------------------------------------------

// DefaultParentDelete_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void DefaultParentDelete_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus DefaultParentDelete_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus DefaultParentDelete_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentDelete_Response.status)
  return _internal_status();
}
inline void DefaultParentDelete_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void DefaultParentDelete_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentDelete_Response.status)
}

// optional string error = 2;
inline bool DefaultParentDelete_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DefaultParentDelete_Response::has_error() const {
  return _internal_has_error();
}
inline void DefaultParentDelete_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DefaultParentDelete_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentDelete_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentDelete_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentDelete_Response.error)
}
inline std::string* DefaultParentDelete_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentDelete_Response.error)
  return _s;
}
inline const std::string& DefaultParentDelete_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void DefaultParentDelete_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentDelete_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentDelete_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentDelete_Response.error)
}

// optional string warning = 3;
inline bool DefaultParentDelete_Response::_internal_has_warning() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DefaultParentDelete_Response::has_warning() const {
  return _internal_has_warning();
}
inline void DefaultParentDelete_Response::clear_warning() {
  _impl_.warning_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DefaultParentDelete_Response::warning() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.DefaultParentDelete_Response.warning)
  return _internal_warning();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DefaultParentDelete_Response::set_warning(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.warning_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.DefaultParentDelete_Response.warning)
}
inline std::string* DefaultParentDelete_Response::mutable_warning() {
  std::string* _s = _internal_mutable_warning();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.DefaultParentDelete_Response.warning)
  return _s;
}
inline const std::string& DefaultParentDelete_Response::_internal_warning() const {
  return _impl_.warning_.Get();
}
inline void DefaultParentDelete_Response::_internal_set_warning(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.warning_.Set(value, GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Response::_internal_mutable_warning() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.warning_.Mutable(GetArenaForAllocation());
}
inline std::string* DefaultParentDelete_Response::release_warning() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.DefaultParentDelete_Response.warning)
  if (!_internal_has_warning()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.warning_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DefaultParentDelete_Response::set_allocated_warning(std::string* warning) {
  if (warning != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.warning_.SetAllocated(warning, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.warning_.IsDefault()) {
    _impl_.warning_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.DefaultParentDelete_Response.warning)
}

// -------------------------------------------------------------------

// PoliciesGet_Request

// -------------------------------------------------------------------

// PoliciesGet_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void PoliciesGet_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus PoliciesGet_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus PoliciesGet_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.PoliciesGet_Response.status)
  return _internal_status();
}
inline void PoliciesGet_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void PoliciesGet_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.PoliciesGet_Response.status)
}

// optional string error = 2;
inline bool PoliciesGet_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PoliciesGet_Response::has_error() const {
  return _internal_has_error();
}
inline void PoliciesGet_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PoliciesGet_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.PoliciesGet_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PoliciesGet_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.PoliciesGet_Response.error)
}
inline std::string* PoliciesGet_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.PoliciesGet_Response.error)
  return _s;
}
inline const std::string& PoliciesGet_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void PoliciesGet_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* PoliciesGet_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* PoliciesGet_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.PoliciesGet_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PoliciesGet_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.PoliciesGet_Response.error)
}

// repeated string data = 3;
inline int PoliciesGet_Response::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int PoliciesGet_Response::data_size() const {
  return _internal_data_size();
}
inline void PoliciesGet_Response::clear_data() {
  _impl_.data_.Clear();
}
inline std::string* PoliciesGet_Response::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
  return _s;
}
inline const std::string& PoliciesGet_Response::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const std::string& PoliciesGet_Response::data(int index) const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
  return _internal_data(index);
}
inline std::string* PoliciesGet_Response::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
  return _impl_.data_.Mutable(index);
}
inline void PoliciesGet_Response::set_data(int index, const std::string& value) {
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
}
inline void PoliciesGet_Response::set_data(int index, std::string&& value) {
  _impl_.data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
}
inline void PoliciesGet_Response::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
}
inline void PoliciesGet_Response::set_data(int index, const char* value, size_t size) {
  _impl_.data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
}
inline std::string* PoliciesGet_Response::_internal_add_data() {
  return _impl_.data_.Add();
}
inline void PoliciesGet_Response::add_data(const std::string& value) {
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
}
inline void PoliciesGet_Response::add_data(std::string&& value) {
  _impl_.data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
}
inline void PoliciesGet_Response::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
}
inline void PoliciesGet_Response::add_data(const char* value, size_t size) {
  _impl_.data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PoliciesGet_Response::data() const {
  // @@protoc_insertion_point(field_list:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PoliciesGet_Response::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:com.wazuh.api.engine.policy.PoliciesGet_Response.data)
  return &_impl_.data_;
}

// -------------------------------------------------------------------

// NamespacesGet_Request

// optional string policy = 1;
inline bool NamespacesGet_Request::_internal_has_policy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NamespacesGet_Request::has_policy() const {
  return _internal_has_policy();
}
inline void NamespacesGet_Request::clear_policy() {
  _impl_.policy_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NamespacesGet_Request::policy() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.NamespacesGet_Request.policy)
  return _internal_policy();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamespacesGet_Request::set_policy(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.policy_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.NamespacesGet_Request.policy)
}
inline std::string* NamespacesGet_Request::mutable_policy() {
  std::string* _s = _internal_mutable_policy();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.NamespacesGet_Request.policy)
  return _s;
}
inline const std::string& NamespacesGet_Request::_internal_policy() const {
  return _impl_.policy_.Get();
}
inline void NamespacesGet_Request::_internal_set_policy(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.policy_.Set(value, GetArenaForAllocation());
}
inline std::string* NamespacesGet_Request::_internal_mutable_policy() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.policy_.Mutable(GetArenaForAllocation());
}
inline std::string* NamespacesGet_Request::release_policy() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.NamespacesGet_Request.policy)
  if (!_internal_has_policy()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.policy_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NamespacesGet_Request::set_allocated_policy(std::string* policy) {
  if (policy != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.policy_.SetAllocated(policy, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.policy_.IsDefault()) {
    _impl_.policy_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.NamespacesGet_Request.policy)
}

// -------------------------------------------------------------------

// NamespacesGet_Response

// .com.wazuh.api.engine.ReturnStatus status = 1;
inline void NamespacesGet_Response::clear_status() {
  _impl_.status_ = 0;
}
inline ::com::wazuh::api::engine::ReturnStatus NamespacesGet_Response::_internal_status() const {
  return static_cast< ::com::wazuh::api::engine::ReturnStatus >(_impl_.status_);
}
inline ::com::wazuh::api::engine::ReturnStatus NamespacesGet_Response::status() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.NamespacesGet_Response.status)
  return _internal_status();
}
inline void NamespacesGet_Response::_internal_set_status(::com::wazuh::api::engine::ReturnStatus value) {
  
  _impl_.status_ = value;
}
inline void NamespacesGet_Response::set_status(::com::wazuh::api::engine::ReturnStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.NamespacesGet_Response.status)
}

// optional string error = 2;
inline bool NamespacesGet_Response::_internal_has_error() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NamespacesGet_Response::has_error() const {
  return _internal_has_error();
}
inline void NamespacesGet_Response::clear_error() {
  _impl_.error_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NamespacesGet_Response::error() const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.NamespacesGet_Response.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamespacesGet_Response::set_error(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.NamespacesGet_Response.error)
}
inline std::string* NamespacesGet_Response::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.NamespacesGet_Response.error)
  return _s;
}
inline const std::string& NamespacesGet_Response::_internal_error() const {
  return _impl_.error_.Get();
}
inline void NamespacesGet_Response::_internal_set_error(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* NamespacesGet_Response::_internal_mutable_error() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* NamespacesGet_Response::release_error() {
  // @@protoc_insertion_point(field_release:com.wazuh.api.engine.policy.NamespacesGet_Response.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.error_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NamespacesGet_Response::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:com.wazuh.api.engine.policy.NamespacesGet_Response.error)
}

// repeated string data = 3;
inline int NamespacesGet_Response::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int NamespacesGet_Response::data_size() const {
  return _internal_data_size();
}
inline void NamespacesGet_Response::clear_data() {
  _impl_.data_.Clear();
}
inline std::string* NamespacesGet_Response::add_data() {
  std::string* _s = _internal_add_data();
  // @@protoc_insertion_point(field_add_mutable:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
  return _s;
}
inline const std::string& NamespacesGet_Response::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const std::string& NamespacesGet_Response::data(int index) const {
  // @@protoc_insertion_point(field_get:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
  return _internal_data(index);
}
inline std::string* NamespacesGet_Response::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
  return _impl_.data_.Mutable(index);
}
inline void NamespacesGet_Response::set_data(int index, const std::string& value) {
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
}
inline void NamespacesGet_Response::set_data(int index, std::string&& value) {
  _impl_.data_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
}
inline void NamespacesGet_Response::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
}
inline void NamespacesGet_Response::set_data(int index, const char* value, size_t size) {
  _impl_.data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
}
inline std::string* NamespacesGet_Response::_internal_add_data() {
  return _impl_.data_.Add();
}
inline void NamespacesGet_Response::add_data(const std::string& value) {
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
}
inline void NamespacesGet_Response::add_data(std::string&& value) {
  _impl_.data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
}
inline void NamespacesGet_Response::add_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
}
inline void NamespacesGet_Response::add_data(const char* value, size_t size) {
  _impl_.data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NamespacesGet_Response::data() const {
  // @@protoc_insertion_point(field_list:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
  return _impl_.data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NamespacesGet_Response::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:com.wazuh.api.engine.policy.NamespacesGet_Response.data)
  return &_impl_.data_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace policy
}  // namespace engine
}  // namespace api
}  // namespace wazuh
}  // namespace com

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_policy_2eproto
