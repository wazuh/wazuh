{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "fields_rule.json",
  "name": "schema/fields-rule/0",
  "type": "object",
  "additionalProperties": false,
  "patternProperties": {
    "^_.+": {
      "description": "Custom variable.",
      "ecs_type": null
    }
  },
  "properties": {
    "event.risk_score": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nRisk score or priority of the event (e.g. security solutions). Use your system's original value here.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "event.risk_score_norm": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nNormalized risk score or priority of the event, on a scale of 0 to 100.\nThis is mainly useful if you use more than one system that assigns risk scores, and you want to see a normalized value across all systems.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "host.risk.calculated_level": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA risk classification level calculated by an internal system as part of entity analytics and entity risk scoring.",
      "type": [
        "string"
      ]
    },
    "host.risk.calculated_score": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nA risk classification score calculated by an internal system as part of entity analytics and entity risk scoring.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "host.risk.calculated_score_norm": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nA risk classification score calculated by an internal system as part of entity analytics and entity risk scoring, and normalized to a range of 0 to 100.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "host.risk.static_level": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA risk classification level obtained from outside the system, such as from some external Threat Intelligence Platform.",
      "type": [
        "string"
      ]
    },
    "host.risk.static_score": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nA risk classification score obtained from outside the system, such as from some external Threat Intelligence Platform.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "host.risk.static_score_norm": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nA risk classification score obtained from outside the system, such as from some external Threat Intelligence Platform, and normalized to a range of 0 to 100.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "rule.author": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nName, organization, or pseudonym of the author or authors who created the rule used to generate this event.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "rule.category": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA categorization value keyword used by the entity using the rule for detection of this event.",
      "type": [
        "string"
      ]
    },
    "rule.description": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe description of the rule generating the event.",
      "type": [
        "string"
      ]
    },
    "rule.id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA rule ID that is unique within the scope of an agent, observer, or other entity using the rule for detection of this event.",
      "type": [
        "string"
      ]
    },
    "rule.license": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nName of the license under which the rule used to generate this event is made available.",
      "type": [
        "string"
      ]
    },
    "rule.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe name of the rule or signature generating the event.",
      "type": [
        "string"
      ]
    },
    "rule.reference": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nReference URL to additional information about the rule used to generate this event.\nThe URL can point to the vendor's documentation about the rule. If that's not available, it can also be a link to a more general page describing this type of alert.",
      "type": [
        "string"
      ]
    },
    "rule.ruleset": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nName of the ruleset, policy, group, or parent category in which the rule used to generate this event is a member.",
      "type": [
        "string"
      ]
    },
    "rule.uuid": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA rule ID that is unique within the scope of a set or group of agents, observers, or other entities using the rule for detection of this event.",
      "type": [
        "string"
      ]
    },
    "rule.version": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe version / revision of the rule being used for analysis.",
      "type": [
        "string"
      ]
    },
    "threat.enrichments": {
      "description": "Module: ecs\nIndexerType: nested\nArray: True\n\nA list of associated indicators objects enriching the event, and the context of that association/enrichment.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "object",
          "string"
        ],
        "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
        "additionalProperties": false,
        "properties": {
          "indicator": {
            "description": "Module: ecs\nIndexerType: object\nArray: False\n\nObject containing associated indicators enriching the event.",
            "type": [
              "object",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
            "additionalProperties": false,
            "properties": {
              "as.number": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nUnique number allocated to the autonomous system. The autonomous system number (ASN) uniquely identifies each network on the Internet.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "as.organization.name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nOrganization name.",
                "type": [
                  "string"
                ]
              },
              "confidence": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifies the vendor-neutral confidence rating using the None/Low/Medium/High scale defined in Appendix A of the STIX 2.1 framework. Vendor-specific confidence scales may be added as custom fields.",
                "type": [
                  "string"
                ]
              },
              "description": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDescribes the type of action conducted by the threat.",
                "type": [
                  "string"
                ]
              },
              "email.address": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifies a threat indicator as an email address (irrespective of direction).",
                "type": [
                  "string"
                ]
              },
              "file.accessed": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nLast time the file was accessed.\nNote that not all filesystems keep track of access time.",
                "type": [
                  "string"
                ]
              },
              "file.attributes": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nArray of file attributes.\nAttributes names will vary by platform. Here's a non-exhaustive list of values that are expected in this field: archive, compressed, directory, encrypted, execute, hidden, read, readonly, system, write.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.code_signature.digest_algorithm": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe hashing algorithm used to sign the process.\nThis value can distinguish signatures when a file is signed multiple times by the same signer but with a different digest algorithm.",
                "type": [
                  "string"
                ]
              },
              "file.code_signature.exists": {
                "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nBoolean to capture if a signature is present.",
                "type": [
                  "boolean",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.code_signature.flags": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe flags used to sign the process.",
                "type": [
                  "string"
                ]
              },
              "file.code_signature.signing_id": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe identifier used to sign the process.\nThis is used to identify the application manufactured by a software vendor. The field is relevant to Apple *OS only.",
                "type": [
                  "string"
                ]
              },
              "file.code_signature.status": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nAdditional information about the certificate status.\nThis is useful for logging cryptographic errors with the certificate validity or trust status. Leave unpopulated if the validity or trust of the certificate was unchecked.",
                "type": [
                  "string"
                ]
              },
              "file.code_signature.subject_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSubject name of the code signer",
                "type": [
                  "string"
                ]
              },
              "file.code_signature.team_id": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe team identifier used to sign the process.\nThis is used to identify the team or vendor of a software product. The field is relevant to Apple *OS only.",
                "type": [
                  "string"
                ]
              },
              "file.code_signature.timestamp": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nDate and time when the code signature was generated and signed.",
                "type": [
                  "string"
                ]
              },
              "file.code_signature.trusted": {
                "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nStores the trust status of the certificate chain.\nValidating the trust of the certificate chain may be complicated, and this field should only be populated by tools that actively check the status.",
                "type": [
                  "boolean",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.code_signature.valid": {
                "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nBoolean to capture if the digital signature is verified against the binary content.\nLeave unpopulated if a certificate was unchecked.",
                "type": [
                  "boolean",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.created": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nFile creation time.\nNote that not all filesystems store the creation time.",
                "type": [
                  "string"
                ]
              },
              "file.ctime": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nLast time the file attributes or metadata changed.\nNote that changes to the file content will update `mtime`. This implies `ctime` will be adjusted at the same time, since `mtime` is an attribute of the file.",
                "type": [
                  "string"
                ]
              },
              "file.device": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDevice that is the source of the file.",
                "type": [
                  "string"
                ]
              },
              "file.directory": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDirectory where the file is located. It should include the drive letter, when appropriate.",
                "type": [
                  "string"
                ]
              },
              "file.drive_letter": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDrive letter where the file is located. This field is only relevant on Windows.\nThe value should be uppercase, and not include the colon.",
                "type": [
                  "string"
                ]
              },
              "file.elf.architecture": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nMachine architecture of the ELF file.",
                "type": [
                  "string"
                ]
              },
              "file.elf.byte_order": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nByte sequence of ELF file.",
                "type": [
                  "string"
                ]
              },
              "file.elf.cpu_type": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCPU type of the ELF file.",
                "type": [
                  "string"
                ]
              },
              "file.elf.creation_date": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nExtracted when possible from the file's metadata. Indicates when it was built or compiled. It can also be faked by malware creators.",
                "type": [
                  "string"
                ]
              },
              "file.elf.exports": {
                "description": "Module: ecs\nIndexerType: object\nArray: True\n\nList of exported element names and types.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "object",
                    "string"
                  ],
                  "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                }
              },
              "file.elf.go_import_hash": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the Go language imports in an ELF file excluding standard library imports. An import hash can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nThe algorithm used to calculate the Go symbol hash and a reference implementation are available here: https://github.com/elastic/toutoumomoma",
                "type": [
                  "string"
                ]
              },
              "file.elf.go_imports": {
                "description": "Module: ecs\nIndexerType: object\nArray: False\n\nList of imported Go language element names and types.",
                "type": [
                  "object",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.elf.go_imports_names_entropy": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the list of Go imports.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.elf.go_imports_names_var_entropy": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the list of Go imports.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.elf.go_stripped": {
                "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nSet to true if the file is a Go executable that has had its symbols stripped or obfuscated and false if an unobfuscated Go executable.",
                "type": [
                  "boolean",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.elf.header.abi_version": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nVersion of the ELF Application Binary Interface (ABI).",
                "type": [
                  "string"
                ]
              },
              "file.elf.header.class": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nHeader class of the ELF file.",
                "type": [
                  "string"
                ]
              },
              "file.elf.header.data": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nData table of the ELF header.",
                "type": [
                  "string"
                ]
              },
              "file.elf.header.entrypoint": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nHeader entrypoint of the ELF file.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.elf.header.object_version": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\n\"0x1\" for original ELF files.",
                "type": [
                  "string"
                ]
              },
              "file.elf.header.os_abi": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nApplication Binary Interface (ABI) of the Linux OS.",
                "type": [
                  "string"
                ]
              },
              "file.elf.header.type": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nHeader type of the ELF file.",
                "type": [
                  "string"
                ]
              },
              "file.elf.header.version": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nVersion of the ELF header.",
                "type": [
                  "string"
                ]
              },
              "file.elf.import_hash": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the imports in an ELF file. An import hash can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nThis is an ELF implementation of the Windows PE imphash.",
                "type": [
                  "string"
                ]
              },
              "file.elf.imports": {
                "description": "Module: ecs\nIndexerType: object\nArray: True\n\nList of imported element names and types.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "object",
                    "string"
                  ],
                  "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                }
              },
              "file.elf.imports_names_entropy": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the list of imported element names and types.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.elf.imports_names_var_entropy": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the list of imported element names and types.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.elf.sections": {
                "description": "Module: ecs\nIndexerType: nested\nArray: True\n\nAn array containing an object for each section of the ELF file.\nThe keys that should be present in these objects are defined by sub-fields underneath `elf.sections.*`.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "object",
                    "string"
                  ],
                  "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                  "additionalProperties": false,
                  "properties": {
                    "chi2": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nChi-square probability distribution of the section.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    },
                    "entropy": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the section.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    },
                    "flags": {
                      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF Section List flags.",
                      "type": [
                        "string"
                      ]
                    },
                    "name": {
                      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF Section List name.",
                      "type": [
                        "string"
                      ]
                    },
                    "physical_offset": {
                      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF Section List offset.",
                      "type": [
                        "string"
                      ]
                    },
                    "physical_size": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nELF Section List physical size.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    },
                    "type": {
                      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF Section List type.",
                      "type": [
                        "string"
                      ]
                    },
                    "var_entropy": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the section.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    },
                    "virtual_address": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nELF Section List virtual address.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    },
                    "virtual_size": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nELF Section List virtual size.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    }
                  }
                }
              },
              "file.elf.segments": {
                "description": "Module: ecs\nIndexerType: nested\nArray: True\n\nAn array containing an object for each segment of the ELF file.\nThe keys that should be present in these objects are defined by sub-fields underneath `elf.segments.*`.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "object",
                    "string"
                  ],
                  "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                  "additionalProperties": false,
                  "properties": {
                    "sections": {
                      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF object segment sections.",
                      "type": [
                        "string"
                      ]
                    },
                    "type": {
                      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF object segment type.",
                      "type": [
                        "string"
                      ]
                    }
                  }
                }
              },
              "file.elf.shared_libraries": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of shared libraries used by this ELF object.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.elf.telfhash": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\ntelfhash symbol hash for ELF file.",
                "type": [
                  "string"
                ]
              },
              "file.extension": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFile extension, excluding the leading dot.\nNote that when the file name has multiple extensions (example.tar.gz), only the last one should be captured (\"gz\", not \"tar.gz\").",
                "type": [
                  "string"
                ]
              },
              "file.fork_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA fork is additional data associated with a filesystem object.\nOn Linux, a resource fork is used to store additional data with a filesystem object. A file always has at least one fork for the data portion, and additional forks may exist.\nOn NTFS, this is analogous to an Alternate Data Stream (ADS), and the default data stream for a file is just called $DATA. Zone.Identifier is commonly used by Windows to track contents downloaded from the Internet. An ADS is typically of the form: `C:\\path\\to\\filename.extension:some_fork_name`, and `some_fork_name` is the value that should populate `fork_name`. `filename.extension` should populate `file.name`, and `extension` should populate `file.extension`. The full path, `file.path`, will include the fork name.",
                "type": [
                  "string"
                ]
              },
              "file.gid": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPrimary group ID (GID) of the file.",
                "type": [
                  "string"
                ]
              },
              "file.group": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPrimary group name of the file.",
                "type": [
                  "string"
                ]
              },
              "file.hash.cdhash": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCode directory hash, utilized to uniquely identify and authenticate the integrity of the executable code.",
                "type": [
                  "string"
                ]
              },
              "file.hash.md5": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nMD5 hash.",
                "type": [
                  "string"
                ]
              },
              "file.hash.sha1": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSHA1 hash.",
                "type": [
                  "string"
                ]
              },
              "file.hash.sha256": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSHA256 hash.",
                "type": [
                  "string"
                ]
              },
              "file.hash.sha384": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSHA384 hash.",
                "type": [
                  "string"
                ]
              },
              "file.hash.sha512": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSHA512 hash.",
                "type": [
                  "string"
                ]
              },
              "file.hash.ssdeep": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSSDEEP hash.",
                "type": [
                  "string"
                ]
              },
              "file.hash.tlsh": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTLSH hash.",
                "type": [
                  "string"
                ]
              },
              "file.inode": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInode representing the file in the filesystem.",
                "type": [
                  "string"
                ]
              },
              "file.mime_type": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nMIME type should identify the format of the file or stream of bytes using https://www.iana.org/assignments/media-types/media-types.xhtml[IANA official types], where possible. When more than one type is applicable, the most specific type should be used.",
                "type": [
                  "string"
                ]
              },
              "file.mode": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nMode of the file in octal representation.",
                "type": [
                  "string"
                ]
              },
              "file.mtime": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nLast time the file content was modified.",
                "type": [
                  "string"
                ]
              },
              "file.name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nName of the file including the extension, without the directory.",
                "type": [
                  "string"
                ]
              },
              "file.owner": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFile owner's username.",
                "type": [
                  "string"
                ]
              },
              "file.path": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFull path to the file, including the file name. It should include the drive letter, when appropriate.",
                "type": [
                  "string"
                ]
              },
              "file.pe.architecture": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCPU architecture target for the file.",
                "type": [
                  "string"
                ]
              },
              "file.pe.company": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal company name of the file, provided at compile-time.",
                "type": [
                  "string"
                ]
              },
              "file.pe.description": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal description of the file, provided at compile-time.",
                "type": [
                  "string"
                ]
              },
              "file.pe.file_version": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal version of the file, provided at compile-time.",
                "type": [
                  "string"
                ]
              },
              "file.pe.go_import_hash": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the Go language imports in a PE file excluding standard library imports. An import hash can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nThe algorithm used to calculate the Go symbol hash and a reference implementation are available here: https://github.com/elastic/toutoumomoma",
                "type": [
                  "string"
                ]
              },
              "file.pe.go_imports": {
                "description": "Module: ecs\nIndexerType: object\nArray: False\n\nList of imported Go language element names and types.",
                "type": [
                  "object",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.pe.go_imports_names_entropy": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the list of Go imports.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.pe.go_imports_names_var_entropy": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the list of Go imports.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.pe.go_stripped": {
                "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nSet to true if the file is a Go executable that has had its symbols stripped or obfuscated and false if an unobfuscated Go executable.",
                "type": [
                  "boolean",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.pe.imphash": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the imports in a PE file. An imphash -- or import hash -- can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nLearn more at https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html.",
                "type": [
                  "string"
                ]
              },
              "file.pe.import_hash": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the imports in a PE file. An import hash can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nThis is a synonym for imphash.",
                "type": [
                  "string"
                ]
              },
              "file.pe.imports": {
                "description": "Module: ecs\nIndexerType: object\nArray: True\n\nList of imported element names and types.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "object",
                    "string"
                  ],
                  "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                }
              },
              "file.pe.imports_names_entropy": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the list of imported element names and types.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.pe.imports_names_var_entropy": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the list of imported element names and types.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.pe.original_file_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal name of the file, provided at compile-time.",
                "type": [
                  "string"
                ]
              },
              "file.pe.pehash": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the PE header and data from one or more PE sections. An pehash can be used to cluster files by transforming structural information about a file into a hash value.\nLearn more at https://www.usenix.org/legacy/events/leet09/tech/full_papers/wicherski/wicherski_html/index.html.",
                "type": [
                  "string"
                ]
              },
              "file.pe.product": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal product name of the file, provided at compile-time.",
                "type": [
                  "string"
                ]
              },
              "file.pe.sections": {
                "description": "Module: ecs\nIndexerType: nested\nArray: True\n\nAn array containing an object for each section of the PE file.\nThe keys that should be present in these objects are defined by sub-fields underneath `pe.sections.*`.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "object",
                    "string"
                  ],
                  "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                  "additionalProperties": false,
                  "properties": {
                    "entropy": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the section.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    },
                    "name": {
                      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPE Section List name.",
                      "type": [
                        "string"
                      ]
                    },
                    "physical_size": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nPE Section List physical size.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    },
                    "var_entropy": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the section.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    },
                    "virtual_size": {
                      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nPE Section List virtual size. This is always the same as `physical_size`.",
                      "type": [
                        "number",
                        "string"
                      ],
                      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
                    }
                  }
                }
              },
              "file.size": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nFile size in bytes.\nOnly relevant when `file.type` is \"file\".",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.target_path": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTarget path for symlinks.",
                "type": [
                  "string"
                ]
              },
              "file.type": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFile type (file, dir, or symlink).",
                "type": [
                  "string"
                ]
              },
              "file.uid": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe user ID (UID) or security identifier (SID) of the file owner.",
                "type": [
                  "string"
                ]
              },
              "file.x509.alternative_names": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of subject alternative names (SAN). Name types vary by certificate authority and certificate type but commonly contain IP addresses, DNS names (and wildcards), and email addresses.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.issuer.common_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of common name (CN) of issuing certificate authority.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.issuer.country": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of country \\(C) codes",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.issuer.distinguished_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDistinguished name (DN) of issuing certificate authority.",
                "type": [
                  "string"
                ]
              },
              "file.x509.issuer.locality": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of locality names (L)",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.issuer.organization": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizations (O) of issuing certificate authority.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.issuer.organizational_unit": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizational units (OU) of issuing certificate authority.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.issuer.state_or_province": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of state or province names (ST, S, or P)",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.not_after": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nTime at which the certificate is no longer considered valid.",
                "type": [
                  "string"
                ]
              },
              "file.x509.not_before": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nTime at which the certificate is first considered valid.",
                "type": [
                  "string"
                ]
              },
              "file.x509.public_key_algorithm": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nAlgorithm used to generate the public key.",
                "type": [
                  "string"
                ]
              },
              "file.x509.public_key_curve": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe curve used by the elliptic curve public key algorithm. This is algorithm specific.",
                "type": [
                  "string"
                ]
              },
              "file.x509.public_key_exponent": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nExponent used to derive the public key. This is algorithm specific.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.x509.public_key_size": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nThe size of the public key space in bits.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "file.x509.serial_number": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nUnique serial number issued by the certificate authority. For consistency, this should be encoded in base 16 and formatted without colons and uppercase characters.",
                "type": [
                  "string"
                ]
              },
              "file.x509.signature_algorithm": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifier for certificate signature algorithm. We recommend using names found in Go Lang Crypto library. See https://github.com/golang/go/blob/go1.14/src/crypto/x509/x509.go#L337-L353.",
                "type": [
                  "string"
                ]
              },
              "file.x509.subject.common_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of common names (CN) of subject.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.subject.country": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of country \\(C) code",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.subject.distinguished_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDistinguished name (DN) of the certificate subject entity.",
                "type": [
                  "string"
                ]
              },
              "file.x509.subject.locality": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of locality names (L)",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.subject.organization": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizations (O) of subject.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.subject.organizational_unit": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizational units (OU) of subject.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.subject.state_or_province": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of state or province names (ST, S, or P)",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "file.x509.version_number": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nVersion of x509 format.",
                "type": [
                  "string"
                ]
              },
              "first_seen": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nThe date and time when intelligence source first reported sighting this indicator.",
                "type": [
                  "string"
                ]
              },
              "geo.city_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCity name.",
                "type": [
                  "string"
                ]
              },
              "geo.continent_code": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTwo-letter code representing continent's name.",
                "type": [
                  "string"
                ]
              },
              "geo.continent_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nName of the continent.",
                "type": [
                  "string"
                ]
              },
              "geo.country_iso_code": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCountry ISO code.",
                "type": [
                  "string"
                ]
              },
              "geo.country_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCountry name.",
                "type": [
                  "string"
                ]
              },
              "geo.location": {
                "description": "Module: ecs\nIndexerType: geo_point\nArray: False\n\nLongitude and latitude.",
                "type": [
                  "string"
                ]
              },
              "geo.name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nUser-defined description of a location, at the level of granularity they care about.\nCould be the name of their data centers, the floor number, if this describes a local physical entity, city names.\nNot typically used in automated geolocation.",
                "type": [
                  "string"
                ]
              },
              "geo.postal_code": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPostal code associated with the location.\nValues appropriate for this field may also be known as a postcode or ZIP code and will vary widely from country to country.",
                "type": [
                  "string"
                ]
              },
              "geo.region_iso_code": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nRegion ISO code.",
                "type": [
                  "string"
                ]
              },
              "geo.region_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nRegion name.",
                "type": [
                  "string"
                ]
              },
              "geo.timezone": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe time zone of the location, such as IANA time zone name.",
                "type": [
                  "string"
                ]
              },
              "ip": {
                "description": "Module: ecs\nIndexerType: ip\nArray: False\n\nIdentifies a threat indicator as an IP address (irrespective of direction).",
                "type": [
                  "string"
                ]
              },
              "last_seen": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nThe date and time when intelligence source last reported sighting this indicator.",
                "type": [
                  "string"
                ]
              },
              "marking.tlp": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTraffic Light Protocol sharing markings.",
                "type": [
                  "string"
                ]
              },
              "marking.tlp_version": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTraffic Light Protocol version.",
                "type": [
                  "string"
                ]
              },
              "modified_at": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nThe date and time when intelligence source last modified information for this indicator.",
                "type": [
                  "string"
                ]
              },
              "name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe display name indicator in an UI friendly format\nURL, IP address, email address, registry key, port number, hash value, or other relevant name can serve as the display name.",
                "type": [
                  "string"
                ]
              },
              "port": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nIdentifies a threat indicator as a port number (irrespective of direction).",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "provider": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe name of the indicator's provider.",
                "type": [
                  "string"
                ]
              },
              "reference": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nReference URL linking to additional information about this indicator.",
                "type": [
                  "string"
                ]
              },
              "registry.data.bytes": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nOriginal bytes written with base64 encoding.\nFor Windows registry operations, such as SetValueEx and RegQueryValueEx, this corresponds to the data pointed by `lp_data`. This is optional but provides better recoverability and should be populated for REG_BINARY encoded values.",
                "type": [
                  "string"
                ]
              },
              "registry.data.strings": {
                "description": "Module: ecs\nIndexerType: wildcard\nArray: True\n\nContent when writing string types.\nPopulated as an array when writing string data to the registry. For single string registry types (REG_SZ, REG_EXPAND_SZ), this should be an array with one string. For sequences of string with REG_MULTI_SZ, this array will be variable length. For numeric data, such as REG_DWORD and REG_QWORD, this should be populated with the decimal representation (e.g `\"1\"`).",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "registry.data.type": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nStandard registry type for encoding contents",
                "type": [
                  "string"
                ]
              },
              "registry.hive": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nAbbreviated name for the hive.",
                "type": [
                  "string"
                ]
              },
              "registry.key": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nHive-relative path of keys.",
                "type": [
                  "string"
                ]
              },
              "registry.path": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFull path, including hive, key and value",
                "type": [
                  "string"
                ]
              },
              "registry.value": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nName of the value written.",
                "type": [
                  "string"
                ]
              },
              "scanner_stats": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nCount of AV/EDR vendors that successfully detected malicious file or URL.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "sightings": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nNumber of times this indicator was observed conducting threat activity.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "type": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nType of indicator as represented by Cyber Observable in STIX 2.0.",
                "type": [
                  "string"
                ]
              },
              "url.domain": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDomain of the url, such as \"www.elastic.co\".\nIn some cases a URL may refer to an IP and/or port directly, without a domain name. In this case, the IP address would go to the `domain` field.\nIf the URL contains a literal IPv6 address enclosed by `[` and `]` (IETF RFC 2732), the `[` and `]` characters should also be captured in the `domain` field.",
                "type": [
                  "string"
                ]
              },
              "url.extension": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe field contains the file extension from the original request url, excluding the leading dot.\nThe file extension is only set if it exists, as not every url has a file extension.\nThe leading period must not be included. For example, the value must be \"png\", not \".png\".\nNote that when the file name has multiple extensions (example.tar.gz), only the last one should be captured (\"gz\", not \"tar.gz\").",
                "type": [
                  "string"
                ]
              },
              "url.fragment": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPortion of the url after the `#`, such as \"top\".\nThe `#` is not part of the fragment.",
                "type": [
                  "string"
                ]
              },
              "url.full": {
                "description": "Module: ecs\nIndexerType: wildcard\nArray: False\n\nIf full URLs are important to your use case, they should be stored in `url.full`, whether this field is reconstructed or present in the event source.",
                "type": [
                  "string"
                ]
              },
              "url.original": {
                "description": "Module: ecs\nIndexerType: wildcard\nArray: False\n\nUnmodified original url as seen in the event source.\nNote that in network monitoring, the observed URL may be a full URL, whereas in access logs, the URL is often just represented as a path.\nThis field is meant to represent the URL as it was observed, complete or not.",
                "type": [
                  "string"
                ]
              },
              "url.password": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPassword of the request.",
                "type": [
                  "string"
                ]
              },
              "url.path": {
                "description": "Module: ecs\nIndexerType: wildcard\nArray: False\n\nPath of the request, such as \"/search\".",
                "type": [
                  "string"
                ]
              },
              "url.port": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nPort of the request, such as 443.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "url.query": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe query field describes the query string of the request, such as \"q=elasticsearch\".\nThe `?` is excluded from the query string. If a URL contains no `?`, there is no query field. If there is a `?` but no query, the query field exists with an empty string. The `exists` query can be used to differentiate between the two cases.",
                "type": [
                  "string"
                ]
              },
              "url.registered_domain": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe highest registered url domain, stripped of the subdomain.\nFor example, the registered domain for \"foo.example.com\" is \"example.com\".\nThis value can be determined precisely with a list like the public suffix list (https://publicsuffix.org). Trying to approximate this by simply taking the last two labels will not work well for TLDs such as \"co.uk\".",
                "type": [
                  "string"
                ]
              },
              "url.scheme": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nScheme of the request, such as \"https\".\nNote: The `:` is not part of the scheme.",
                "type": [
                  "string"
                ]
              },
              "url.subdomain": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe subdomain portion of a fully qualified domain name includes all of the names except the host name under the registered_domain.  In a partially qualified domain, or if the the qualification level of the full name cannot be determined, subdomain contains all of the names below the registered domain.\nFor example the subdomain portion of \"www.east.mydomain.co.uk\" is \"east\". If the domain has multiple levels of subdomain, such as \"sub2.sub1.example.com\", the subdomain field should contain \"sub2.sub1\", with no trailing period.",
                "type": [
                  "string"
                ]
              },
              "url.top_level_domain": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe effective top level domain (eTLD), also known as the domain suffix, is the last part of the domain name. For example, the top level domain for example.com is \"com\".\nThis value can be determined precisely with a list like the public suffix list (https://publicsuffix.org). Trying to approximate this by simply taking the last label will not work well for effective TLDs such as \"co.uk\".",
                "type": [
                  "string"
                ]
              },
              "url.username": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nUsername of the request.",
                "type": [
                  "string"
                ]
              },
              "x509.alternative_names": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of subject alternative names (SAN). Name types vary by certificate authority and certificate type but commonly contain IP addresses, DNS names (and wildcards), and email addresses.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.issuer.common_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of common name (CN) of issuing certificate authority.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.issuer.country": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of country \\(C) codes",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.issuer.distinguished_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDistinguished name (DN) of issuing certificate authority.",
                "type": [
                  "string"
                ]
              },
              "x509.issuer.locality": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of locality names (L)",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.issuer.organization": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizations (O) of issuing certificate authority.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.issuer.organizational_unit": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizational units (OU) of issuing certificate authority.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.issuer.state_or_province": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of state or province names (ST, S, or P)",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.not_after": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nTime at which the certificate is no longer considered valid.",
                "type": [
                  "string"
                ]
              },
              "x509.not_before": {
                "description": "Module: ecs\nIndexerType: date\nArray: False\n\nTime at which the certificate is first considered valid.",
                "type": [
                  "string"
                ]
              },
              "x509.public_key_algorithm": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nAlgorithm used to generate the public key.",
                "type": [
                  "string"
                ]
              },
              "x509.public_key_curve": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe curve used by the elliptic curve public key algorithm. This is algorithm specific.",
                "type": [
                  "string"
                ]
              },
              "x509.public_key_exponent": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nExponent used to derive the public key. This is algorithm specific.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "x509.public_key_size": {
                "description": "Module: ecs\nIndexerType: long\nArray: False\n\nThe size of the public key space in bits.",
                "type": [
                  "number",
                  "string"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
              },
              "x509.serial_number": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nUnique serial number issued by the certificate authority. For consistency, this should be encoded in base 16 and formatted without colons and uppercase characters.",
                "type": [
                  "string"
                ]
              },
              "x509.signature_algorithm": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifier for certificate signature algorithm. We recommend using names found in Go Lang Crypto library. See https://github.com/golang/go/blob/go1.14/src/crypto/x509/x509.go#L337-L353.",
                "type": [
                  "string"
                ]
              },
              "x509.subject.common_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of common names (CN) of subject.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.subject.country": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of country \\(C) code",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.subject.distinguished_name": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDistinguished name (DN) of the certificate subject entity.",
                "type": [
                  "string"
                ]
              },
              "x509.subject.locality": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of locality names (L)",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.subject.organization": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizations (O) of subject.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.subject.organizational_unit": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizational units (OU) of subject.",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.subject.state_or_province": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of state or province names (ST, S, or P)",
                "type": [
                  "string",
                  "array"
                ],
                "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
                "items": {
                  "type": [
                    "string"
                  ]
                }
              },
              "x509.version_number": {
                "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nVersion of x509 format.",
                "type": [
                  "string"
                ]
              }
            }
          },
          "matched.atomic": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifies the atomic indicator value that matched a local environment endpoint or network event.",
            "type": [
              "string"
            ]
          },
          "matched.field": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifies the field of the atomic indicator that matched a local environment endpoint or network event.",
            "type": [
              "string"
            ]
          },
          "matched.id": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifies the _id of the indicator document enriching the event.",
            "type": [
              "string"
            ]
          },
          "matched.index": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifies the _index of the indicator document enriching the event.",
            "type": [
              "string"
            ]
          },
          "matched.occurred": {
            "description": "Module: ecs\nIndexerType: date\nArray: False\n\nIndicates when the indicator match was generated",
            "type": [
              "string"
            ]
          },
          "matched.type": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifies the type of match that caused the event to be enriched with the given indicator",
            "type": [
              "string"
            ]
          }
        }
      }
    },
    "threat.feed.dashboard_id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe saved object ID of the dashboard belonging to the threat feed for displaying dashboard links to threat feeds in Kibana.",
      "type": [
        "string"
      ]
    },
    "threat.feed.description": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDescription of the threat feed in a UI friendly format.",
      "type": [
        "string"
      ]
    },
    "threat.feed.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe name of the threat feed in UI friendly format.",
      "type": [
        "string"
      ]
    },
    "threat.feed.reference": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nReference information for the threat feed in a UI friendly format.",
      "type": [
        "string"
      ]
    },
    "threat.framework": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nName of the threat framework used to further categorize and classify the tactic and technique of the reported threat. Framework classification can be provided by detecting systems, evaluated at ingest time, or retrospectively tagged to events.",
      "type": [
        "string"
      ]
    },
    "threat.group.alias": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe alias(es) of the group for a set of related intrusion activity that are tracked by a common name in the security community.\nWhile not required, you can use a MITRE ATT&CK\u00ae group alias(es).",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.group.id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe id of the group for a set of related intrusion activity that are tracked by a common name in the security community.\nWhile not required, you can use a MITRE ATT&CK\u00ae group id.",
      "type": [
        "string"
      ]
    },
    "threat.group.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe name of the group for a set of related intrusion activity that are tracked by a common name in the security community.\nWhile not required, you can use a MITRE ATT&CK\u00ae group name.",
      "type": [
        "string"
      ]
    },
    "threat.group.reference": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe reference URL of the group for a set of related intrusion activity that are tracked by a common name in the security community.\nWhile not required, you can use a MITRE ATT&CK\u00ae group reference URL.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.as.number": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nUnique number allocated to the autonomous system. The autonomous system number (ASN) uniquely identifies each network on the Internet.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.as.organization.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nOrganization name.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.confidence": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifies the vendor-neutral confidence rating using the None/Low/Medium/High scale defined in Appendix A of the STIX 2.1 framework. Vendor-specific confidence scales may be added as custom fields.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.description": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDescribes the type of action conducted by the threat.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.email.address": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifies a threat indicator as an email address (irrespective of direction).",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.accessed": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nLast time the file was accessed.\nNote that not all filesystems keep track of access time.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.attributes": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nArray of file attributes.\nAttributes names will vary by platform. Here's a non-exhaustive list of values that are expected in this field: archive, compressed, directory, encrypted, execute, hidden, read, readonly, system, write.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.code_signature.digest_algorithm": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe hashing algorithm used to sign the process.\nThis value can distinguish signatures when a file is signed multiple times by the same signer but with a different digest algorithm.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.code_signature.exists": {
      "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nBoolean to capture if a signature is present.",
      "type": [
        "boolean",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.code_signature.flags": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe flags used to sign the process.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.code_signature.signing_id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe identifier used to sign the process.\nThis is used to identify the application manufactured by a software vendor. The field is relevant to Apple *OS only.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.code_signature.status": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nAdditional information about the certificate status.\nThis is useful for logging cryptographic errors with the certificate validity or trust status. Leave unpopulated if the validity or trust of the certificate was unchecked.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.code_signature.subject_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSubject name of the code signer",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.code_signature.team_id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe team identifier used to sign the process.\nThis is used to identify the team or vendor of a software product. The field is relevant to Apple *OS only.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.code_signature.timestamp": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nDate and time when the code signature was generated and signed.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.code_signature.trusted": {
      "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nStores the trust status of the certificate chain.\nValidating the trust of the certificate chain may be complicated, and this field should only be populated by tools that actively check the status.",
      "type": [
        "boolean",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.code_signature.valid": {
      "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nBoolean to capture if the digital signature is verified against the binary content.\nLeave unpopulated if a certificate was unchecked.",
      "type": [
        "boolean",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.created": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nFile creation time.\nNote that not all filesystems store the creation time.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.ctime": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nLast time the file attributes or metadata changed.\nNote that changes to the file content will update `mtime`. This implies `ctime` will be adjusted at the same time, since `mtime` is an attribute of the file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.device": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDevice that is the source of the file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.directory": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDirectory where the file is located. It should include the drive letter, when appropriate.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.drive_letter": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDrive letter where the file is located. This field is only relevant on Windows.\nThe value should be uppercase, and not include the colon.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.architecture": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nMachine architecture of the ELF file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.byte_order": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nByte sequence of ELF file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.cpu_type": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCPU type of the ELF file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.creation_date": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nExtracted when possible from the file's metadata. Indicates when it was built or compiled. It can also be faked by malware creators.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.exports": {
      "description": "Module: ecs\nIndexerType: object\nArray: True\n\nList of exported element names and types.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "object",
          "string"
        ],
        "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
      }
    },
    "threat.indicator.file.elf.go_import_hash": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the Go language imports in an ELF file excluding standard library imports. An import hash can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nThe algorithm used to calculate the Go symbol hash and a reference implementation are available here: https://github.com/elastic/toutoumomoma",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.go_imports": {
      "description": "Module: ecs\nIndexerType: object\nArray: False\n\nList of imported Go language element names and types.",
      "type": [
        "object",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.elf.go_imports_names_entropy": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the list of Go imports.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.elf.go_imports_names_var_entropy": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the list of Go imports.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.elf.go_stripped": {
      "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nSet to true if the file is a Go executable that has had its symbols stripped or obfuscated and false if an unobfuscated Go executable.",
      "type": [
        "boolean",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.elf.header.abi_version": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nVersion of the ELF Application Binary Interface (ABI).",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.header.class": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nHeader class of the ELF file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.header.data": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nData table of the ELF header.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.header.entrypoint": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nHeader entrypoint of the ELF file.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.elf.header.object_version": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\n\"0x1\" for original ELF files.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.header.os_abi": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nApplication Binary Interface (ABI) of the Linux OS.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.header.type": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nHeader type of the ELF file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.header.version": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nVersion of the ELF header.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.import_hash": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the imports in an ELF file. An import hash can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nThis is an ELF implementation of the Windows PE imphash.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.elf.imports": {
      "description": "Module: ecs\nIndexerType: object\nArray: True\n\nList of imported element names and types.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "object",
          "string"
        ],
        "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
      }
    },
    "threat.indicator.file.elf.imports_names_entropy": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the list of imported element names and types.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.elf.imports_names_var_entropy": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the list of imported element names and types.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.elf.sections": {
      "description": "Module: ecs\nIndexerType: nested\nArray: True\n\nAn array containing an object for each section of the ELF file.\nThe keys that should be present in these objects are defined by sub-fields underneath `elf.sections.*`.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "object",
          "string"
        ],
        "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
        "additionalProperties": false,
        "properties": {
          "chi2": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nChi-square probability distribution of the section.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          },
          "entropy": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the section.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          },
          "flags": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF Section List flags.",
            "type": [
              "string"
            ]
          },
          "name": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF Section List name.",
            "type": [
              "string"
            ]
          },
          "physical_offset": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF Section List offset.",
            "type": [
              "string"
            ]
          },
          "physical_size": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nELF Section List physical size.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          },
          "type": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF Section List type.",
            "type": [
              "string"
            ]
          },
          "var_entropy": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the section.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          },
          "virtual_address": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nELF Section List virtual address.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          },
          "virtual_size": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nELF Section List virtual size.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          }
        }
      }
    },
    "threat.indicator.file.elf.segments": {
      "description": "Module: ecs\nIndexerType: nested\nArray: True\n\nAn array containing an object for each segment of the ELF file.\nThe keys that should be present in these objects are defined by sub-fields underneath `elf.segments.*`.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "object",
          "string"
        ],
        "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
        "additionalProperties": false,
        "properties": {
          "sections": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF object segment sections.",
            "type": [
              "string"
            ]
          },
          "type": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nELF object segment type.",
            "type": [
              "string"
            ]
          }
        }
      }
    },
    "threat.indicator.file.elf.shared_libraries": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of shared libraries used by this ELF object.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.elf.telfhash": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\ntelfhash symbol hash for ELF file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.extension": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFile extension, excluding the leading dot.\nNote that when the file name has multiple extensions (example.tar.gz), only the last one should be captured (\"gz\", not \"tar.gz\").",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.fork_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA fork is additional data associated with a filesystem object.\nOn Linux, a resource fork is used to store additional data with a filesystem object. A file always has at least one fork for the data portion, and additional forks may exist.\nOn NTFS, this is analogous to an Alternate Data Stream (ADS), and the default data stream for a file is just called $DATA. Zone.Identifier is commonly used by Windows to track contents downloaded from the Internet. An ADS is typically of the form: `C:\\path\\to\\filename.extension:some_fork_name`, and `some_fork_name` is the value that should populate `fork_name`. `filename.extension` should populate `file.name`, and `extension` should populate `file.extension`. The full path, `file.path`, will include the fork name.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.gid": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPrimary group ID (GID) of the file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.group": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPrimary group name of the file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.hash.cdhash": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCode directory hash, utilized to uniquely identify and authenticate the integrity of the executable code.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.hash.md5": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nMD5 hash.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.hash.sha1": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSHA1 hash.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.hash.sha256": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSHA256 hash.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.hash.sha384": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSHA384 hash.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.hash.sha512": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSHA512 hash.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.hash.ssdeep": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nSSDEEP hash.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.hash.tlsh": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTLSH hash.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.inode": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInode representing the file in the filesystem.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.mime_type": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nMIME type should identify the format of the file or stream of bytes using https://www.iana.org/assignments/media-types/media-types.xhtml[IANA official types], where possible. When more than one type is applicable, the most specific type should be used.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.mode": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nMode of the file in octal representation.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.mtime": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nLast time the file content was modified.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nName of the file including the extension, without the directory.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.owner": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFile owner's username.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.path": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFull path to the file, including the file name. It should include the drive letter, when appropriate.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.architecture": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCPU architecture target for the file.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.company": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal company name of the file, provided at compile-time.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.description": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal description of the file, provided at compile-time.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.file_version": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal version of the file, provided at compile-time.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.go_import_hash": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the Go language imports in a PE file excluding standard library imports. An import hash can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nThe algorithm used to calculate the Go symbol hash and a reference implementation are available here: https://github.com/elastic/toutoumomoma",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.go_imports": {
      "description": "Module: ecs\nIndexerType: object\nArray: False\n\nList of imported Go language element names and types.",
      "type": [
        "object",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.pe.go_imports_names_entropy": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the list of Go imports.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.pe.go_imports_names_var_entropy": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the list of Go imports.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.pe.go_stripped": {
      "description": "Module: ecs\nIndexerType: boolean\nArray: False\n\nSet to true if the file is a Go executable that has had its symbols stripped or obfuscated and false if an unobfuscated Go executable.",
      "type": [
        "boolean",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.pe.imphash": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the imports in a PE file. An imphash -- or import hash -- can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nLearn more at https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.import_hash": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the imports in a PE file. An import hash can be used to fingerprint binaries even after recompilation or other code-level transformations have occurred, which would change more traditional hash values.\nThis is a synonym for imphash.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.imports": {
      "description": "Module: ecs\nIndexerType: object\nArray: True\n\nList of imported element names and types.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "object",
          "string"
        ],
        "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
      }
    },
    "threat.indicator.file.pe.imports_names_entropy": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the list of imported element names and types.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.pe.imports_names_var_entropy": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the list of imported element names and types.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.pe.original_file_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal name of the file, provided at compile-time.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.pehash": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA hash of the PE header and data from one or more PE sections. An pehash can be used to cluster files by transforming structural information about a file into a hash value.\nLearn more at https://www.usenix.org/legacy/events/leet09/tech/full_papers/wicherski/wicherski_html/index.html.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.product": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nInternal product name of the file, provided at compile-time.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.pe.sections": {
      "description": "Module: ecs\nIndexerType: nested\nArray: True\n\nAn array containing an object for each section of the PE file.\nThe keys that should be present in these objects are defined by sub-fields underneath `pe.sections.*`.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "object",
          "string"
        ],
        "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
        "additionalProperties": false,
        "properties": {
          "entropy": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nShannon entropy calculation from the section.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          },
          "name": {
            "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPE Section List name.",
            "type": [
              "string"
            ]
          },
          "physical_size": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nPE Section List physical size.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          },
          "var_entropy": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nVariance for Shannon entropy calculation from the section.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          },
          "virtual_size": {
            "description": "Module: ecs\nIndexerType: long\nArray: False\n\nPE Section List virtual size. This is always the same as `physical_size`.",
            "type": [
              "number",
              "string"
            ],
            "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
          }
        }
      }
    },
    "threat.indicator.file.size": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nFile size in bytes.\nOnly relevant when `file.type` is \"file\".",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.target_path": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTarget path for symlinks.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.type": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFile type (file, dir, or symlink).",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.uid": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe user ID (UID) or security identifier (SID) of the file owner.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.x509.alternative_names": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of subject alternative names (SAN). Name types vary by certificate authority and certificate type but commonly contain IP addresses, DNS names (and wildcards), and email addresses.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.issuer.common_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of common name (CN) of issuing certificate authority.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.issuer.country": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of country \\(C) codes",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.issuer.distinguished_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDistinguished name (DN) of issuing certificate authority.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.x509.issuer.locality": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of locality names (L)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.issuer.organization": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizations (O) of issuing certificate authority.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.issuer.organizational_unit": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizational units (OU) of issuing certificate authority.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.issuer.state_or_province": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of state or province names (ST, S, or P)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.not_after": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nTime at which the certificate is no longer considered valid.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.x509.not_before": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nTime at which the certificate is first considered valid.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.x509.public_key_algorithm": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nAlgorithm used to generate the public key.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.x509.public_key_curve": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe curve used by the elliptic curve public key algorithm. This is algorithm specific.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.x509.public_key_exponent": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nExponent used to derive the public key. This is algorithm specific.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.x509.public_key_size": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nThe size of the public key space in bits.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.file.x509.serial_number": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nUnique serial number issued by the certificate authority. For consistency, this should be encoded in base 16 and formatted without colons and uppercase characters.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.x509.signature_algorithm": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifier for certificate signature algorithm. We recommend using names found in Go Lang Crypto library. See https://github.com/golang/go/blob/go1.14/src/crypto/x509/x509.go#L337-L353.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.x509.subject.common_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of common names (CN) of subject.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.subject.country": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of country \\(C) code",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.subject.distinguished_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDistinguished name (DN) of the certificate subject entity.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.file.x509.subject.locality": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of locality names (L)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.subject.organization": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizations (O) of subject.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.subject.organizational_unit": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizational units (OU) of subject.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.subject.state_or_province": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of state or province names (ST, S, or P)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.file.x509.version_number": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nVersion of x509 format.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.first_seen": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nThe date and time when intelligence source first reported sighting this indicator.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.city_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCity name.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.continent_code": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTwo-letter code representing continent's name.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.continent_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nName of the continent.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.country_iso_code": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCountry ISO code.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.country_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nCountry name.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.location": {
      "description": "Module: ecs\nIndexerType: geo_point\nArray: False\n\nLongitude and latitude.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nUser-defined description of a location, at the level of granularity they care about.\nCould be the name of their data centers, the floor number, if this describes a local physical entity, city names.\nNot typically used in automated geolocation.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.postal_code": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPostal code associated with the location.\nValues appropriate for this field may also be known as a postcode or ZIP code and will vary widely from country to country.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.region_iso_code": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nRegion ISO code.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.region_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nRegion name.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.geo.timezone": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe time zone of the location, such as IANA time zone name.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe ID of the indicator used by this threat to conduct behavior commonly modeled using MITRE ATT&CK\u00ae. This field can have multiple values to allow for the identification of the same indicator across systems that use different ID formats.\nWhile not required, a common approach is to use a STIX 2.x indicator ID.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.ip": {
      "description": "Module: ecs\nIndexerType: ip\nArray: False\n\nIdentifies a threat indicator as an IP address (irrespective of direction).",
      "type": [
        "string"
      ]
    },
    "threat.indicator.last_seen": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nThe date and time when intelligence source last reported sighting this indicator.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.marking.tlp": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTraffic Light Protocol sharing markings.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.marking.tlp_version": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nTraffic Light Protocol version.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.modified_at": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nThe date and time when intelligence source last modified information for this indicator.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe display name indicator in an UI friendly format\nURL, IP address, email address, registry key, port number, hash value, or other relevant name can serve as the display name.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.port": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nIdentifies a threat indicator as a port number (irrespective of direction).",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.provider": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe name of the indicator's provider.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.reference": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nReference URL linking to additional information about this indicator.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.registry.data.bytes": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nOriginal bytes written with base64 encoding.\nFor Windows registry operations, such as SetValueEx and RegQueryValueEx, this corresponds to the data pointed by `lp_data`. This is optional but provides better recoverability and should be populated for REG_BINARY encoded values.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.registry.data.strings": {
      "description": "Module: ecs\nIndexerType: wildcard\nArray: True\n\nContent when writing string types.\nPopulated as an array when writing string data to the registry. For single string registry types (REG_SZ, REG_EXPAND_SZ), this should be an array with one string. For sequences of string with REG_MULTI_SZ, this array will be variable length. For numeric data, such as REG_DWORD and REG_QWORD, this should be populated with the decimal representation (e.g `\"1\"`).",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.registry.data.type": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nStandard registry type for encoding contents",
      "type": [
        "string"
      ]
    },
    "threat.indicator.registry.hive": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nAbbreviated name for the hive.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.registry.key": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nHive-relative path of keys.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.registry.path": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nFull path, including hive, key and value",
      "type": [
        "string"
      ]
    },
    "threat.indicator.registry.value": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nName of the value written.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.scanner_stats": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nCount of AV/EDR vendors that successfully detected malicious file or URL.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.sightings": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nNumber of times this indicator was observed conducting threat activity.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.type": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nType of indicator as represented by Cyber Observable in STIX 2.0.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.domain": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDomain of the url, such as \"www.elastic.co\".\nIn some cases a URL may refer to an IP and/or port directly, without a domain name. In this case, the IP address would go to the `domain` field.\nIf the URL contains a literal IPv6 address enclosed by `[` and `]` (IETF RFC 2732), the `[` and `]` characters should also be captured in the `domain` field.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.extension": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe field contains the file extension from the original request url, excluding the leading dot.\nThe file extension is only set if it exists, as not every url has a file extension.\nThe leading period must not be included. For example, the value must be \"png\", not \".png\".\nNote that when the file name has multiple extensions (example.tar.gz), only the last one should be captured (\"gz\", not \"tar.gz\").",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.fragment": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPortion of the url after the `#`, such as \"top\".\nThe `#` is not part of the fragment.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.full": {
      "description": "Module: ecs\nIndexerType: wildcard\nArray: False\n\nIf full URLs are important to your use case, they should be stored in `url.full`, whether this field is reconstructed or present in the event source.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.original": {
      "description": "Module: ecs\nIndexerType: wildcard\nArray: False\n\nUnmodified original url as seen in the event source.\nNote that in network monitoring, the observed URL may be a full URL, whereas in access logs, the URL is often just represented as a path.\nThis field is meant to represent the URL as it was observed, complete or not.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.password": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nPassword of the request.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.path": {
      "description": "Module: ecs\nIndexerType: wildcard\nArray: False\n\nPath of the request, such as \"/search\".",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.port": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nPort of the request, such as 443.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.url.query": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe query field describes the query string of the request, such as \"q=elasticsearch\".\nThe `?` is excluded from the query string. If a URL contains no `?`, there is no query field. If there is a `?` but no query, the query field exists with an empty string. The `exists` query can be used to differentiate between the two cases.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.registered_domain": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe highest registered url domain, stripped of the subdomain.\nFor example, the registered domain for \"foo.example.com\" is \"example.com\".\nThis value can be determined precisely with a list like the public suffix list (https://publicsuffix.org). Trying to approximate this by simply taking the last two labels will not work well for TLDs such as \"co.uk\".",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.scheme": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nScheme of the request, such as \"https\".\nNote: The `:` is not part of the scheme.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.subdomain": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe subdomain portion of a fully qualified domain name includes all of the names except the host name under the registered_domain.  In a partially qualified domain, or if the the qualification level of the full name cannot be determined, subdomain contains all of the names below the registered domain.\nFor example the subdomain portion of \"www.east.mydomain.co.uk\" is \"east\". If the domain has multiple levels of subdomain, such as \"sub2.sub1.example.com\", the subdomain field should contain \"sub2.sub1\", with no trailing period.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.top_level_domain": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe effective top level domain (eTLD), also known as the domain suffix, is the last part of the domain name. For example, the top level domain for example.com is \"com\".\nThis value can be determined precisely with a list like the public suffix list (https://publicsuffix.org). Trying to approximate this by simply taking the last label will not work well for effective TLDs such as \"co.uk\".",
      "type": [
        "string"
      ]
    },
    "threat.indicator.url.username": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nUsername of the request.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.x509.alternative_names": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of subject alternative names (SAN). Name types vary by certificate authority and certificate type but commonly contain IP addresses, DNS names (and wildcards), and email addresses.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.issuer.common_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of common name (CN) of issuing certificate authority.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.issuer.country": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of country \\(C) codes",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.issuer.distinguished_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDistinguished name (DN) of issuing certificate authority.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.x509.issuer.locality": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of locality names (L)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.issuer.organization": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizations (O) of issuing certificate authority.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.issuer.organizational_unit": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizational units (OU) of issuing certificate authority.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.issuer.state_or_province": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of state or province names (ST, S, or P)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.not_after": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nTime at which the certificate is no longer considered valid.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.x509.not_before": {
      "description": "Module: ecs\nIndexerType: date\nArray: False\n\nTime at which the certificate is first considered valid.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.x509.public_key_algorithm": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nAlgorithm used to generate the public key.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.x509.public_key_curve": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe curve used by the elliptic curve public key algorithm. This is algorithm specific.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.x509.public_key_exponent": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nExponent used to derive the public key. This is algorithm specific.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.x509.public_key_size": {
      "description": "Module: ecs\nIndexerType: long\nArray: False\n\nThe size of the public key space in bits.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "threat.indicator.x509.serial_number": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nUnique serial number issued by the certificate authority. For consistency, this should be encoded in base 16 and formatted without colons and uppercase characters.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.x509.signature_algorithm": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nIdentifier for certificate signature algorithm. We recommend using names found in Go Lang Crypto library. See https://github.com/golang/go/blob/go1.14/src/crypto/x509/x509.go#L337-L353.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.x509.subject.common_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of common names (CN) of subject.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.subject.country": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of country \\(C) code",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.subject.distinguished_name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nDistinguished name (DN) of the certificate subject entity.",
      "type": [
        "string"
      ]
    },
    "threat.indicator.x509.subject.locality": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of locality names (L)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.subject.organization": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizations (O) of subject.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.subject.organizational_unit": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of organizational units (OU) of subject.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.subject.state_or_province": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nList of state or province names (ST, S, or P)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.indicator.x509.version_number": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nVersion of x509 format.",
      "type": [
        "string"
      ]
    },
    "threat.software.alias": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe alias(es) of the software for a set of related intrusion activity that are tracked by a common name in the security community.\nWhile not required, you can use a MITRE ATT&CK\u00ae associated software description.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.software.id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe id of the software used by this threat to conduct behavior commonly modeled using MITRE ATT&CK\u00ae.\nWhile not required, you can use a MITRE ATT&CK\u00ae software id.",
      "type": [
        "string"
      ]
    },
    "threat.software.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe name of the software used by this threat to conduct behavior commonly modeled using MITRE ATT&CK\u00ae.\nWhile not required, you can use a MITRE ATT&CK\u00ae software name.",
      "type": [
        "string"
      ]
    },
    "threat.software.platforms": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe platforms of the software used by this threat to conduct behavior commonly modeled using MITRE ATT&CK\u00ae.\nWhile not required, you can use MITRE ATT&CK\u00ae software platform values.",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.software.reference": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe reference URL of the software used by this threat to conduct behavior commonly modeled using MITRE ATT&CK\u00ae.\nWhile not required, you can use a MITRE ATT&CK\u00ae software reference URL.",
      "type": [
        "string"
      ]
    },
    "threat.software.type": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe type of software used by this threat to conduct behavior commonly modeled using MITRE ATT&CK\u00ae.\nWhile not required, you can use a MITRE ATT&CK\u00ae software type.",
      "type": [
        "string"
      ]
    },
    "threat.tactic.id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe id of tactic used by this threat. You can use a MITRE ATT&CK\u00ae tactic, for example. (ex. https://attack.mitre.org/tactics/TA0002/ )",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.tactic.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nName of the type of tactic used by this threat. You can use a MITRE ATT&CK\u00ae tactic, for example. (ex. https://attack.mitre.org/tactics/TA0002/)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.tactic.reference": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe reference url of tactic used by this threat. You can use a MITRE ATT&CK\u00ae tactic, for example. (ex. https://attack.mitre.org/tactics/TA0002/ )",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.technique.id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe id of technique used by this threat. You can use a MITRE ATT&CK\u00ae technique, for example. (ex. https://attack.mitre.org/techniques/T1059/)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.technique.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe name of technique used by this threat. You can use a MITRE ATT&CK\u00ae technique, for example. (ex. https://attack.mitre.org/techniques/T1059/)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.technique.reference": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe reference url of technique used by this threat. You can use a MITRE ATT&CK\u00ae technique, for example. (ex. https://attack.mitre.org/techniques/T1059/)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.technique.subtechnique.id": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe full id of subtechnique used by this threat. You can use a MITRE ATT&CK\u00ae subtechnique, for example. (ex. https://attack.mitre.org/techniques/T1059/001/)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.technique.subtechnique.name": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe name of subtechnique used by this threat. You can use a MITRE ATT&CK\u00ae subtechnique, for example. (ex. https://attack.mitre.org/techniques/T1059/001/)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "threat.technique.subtechnique.reference": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: True\n\nThe reference url of subtechnique used by this threat. You can use a MITRE ATT&CK\u00ae subtechnique, for example. (ex. https://attack.mitre.org/techniques/T1059/001/)",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    },
    "user.risk.calculated_level": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA risk classification level calculated by an internal system as part of entity analytics and entity risk scoring.",
      "type": [
        "string"
      ]
    },
    "user.risk.calculated_score": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nA risk classification score calculated by an internal system as part of entity analytics and entity risk scoring.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "user.risk.calculated_score_norm": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nA risk classification score calculated by an internal system as part of entity analytics and entity risk scoring, and normalized to a range of 0 to 100.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "user.risk.static_level": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nA risk classification level obtained from outside the system, such as from some external Threat Intelligence Platform.",
      "type": [
        "string"
      ]
    },
    "user.risk.static_score": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nA risk classification score obtained from outside the system, such as from some external Threat Intelligence Platform.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "user.risk.static_score_norm": {
      "description": "Module: ecs\nIndexerType: float\nArray: False\n\nA risk classification score obtained from outside the system, such as from some external Threat Intelligence Platform, and normalized to a range of 0 to 100.",
      "type": [
        "number",
        "string"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$"
    },
    "vulnerability.severity": {
      "description": "Module: ecs\nIndexerType: keyword\nArray: False\n\nThe severity of the vulnerability can help with metrics and internal prioritization regarding remediation. For example (https://nvd.nist.gov/vuln-metrics/cvss)",
      "type": [
        "string"
      ]
    },
    "wazuh.rules": {
      "description": "Module: schemas\nIndexerType: keyword\nArray: True\n\nTrace of the rules that matched for the event in order",
      "type": [
        "string",
        "array"
      ],
      "pattern": "^\\$[\\w\\.]+$|^[\\w]+\\(.*\\)$",
      "items": {
        "type": [
          "string"
        ]
      }
    }
  }
}
