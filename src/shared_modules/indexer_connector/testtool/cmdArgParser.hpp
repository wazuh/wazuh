/*
 * Wazuh cmdLineParser
 * Copyright (C) 2015, Wazuh Inc.
 * September 12, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _CMD_ARGS_PARSER_HPP_
#define _CMD_ARGS_PARSER_HPP_

#include "json.hpp"
#include <fstream>
#include <iostream>
#include <string>
#include <vector>

/**
 * @brief Class to parse command line arguments.
 */
class CmdLineArgs
{
public:
    /**
     * @brief Constructor for CmdLineArgs.
     * @param argc Number of arguments.
     * @param argv Arguments.
     */
    explicit CmdLineArgs(const int argc, const char* argv[])
        : m_configurationFilePath {paramValueOf(argc, argv, "-c")}
        , m_templateFilePath {paramValueOf(argc, argv, "-t", std::make_pair(false, ""))}
        , m_updateMappingsFilePath {paramValueOf(argc, argv, "-u", std::make_pair(false, ""))}
        , m_eventsFilePath {paramValueOf(argc, argv, "-e", std::make_pair(false, ""))}
        , m_autoGenerated {paramValueOf(argc, argv, "-a", std::make_pair(false, ""))}
        , m_agentForSyncEvent {paramValueOf(argc, argv, "-s", std::make_pair(false, ""))}
        , m_numberOfEvents {paramValueOf(argc, argv, "-n", std::make_pair(false, ""))}
        , m_waitTime {paramValueOf(argc, argv, "-w", std::make_pair(false, "0"))}
        , m_logFilePath {paramValueOf(argc, argv, "-l", std::make_pair(false, ""))}
        , m_loopSyncCount {paramValueOf(argc, argv, "-L", std::make_pair(false, "0"))}
        , m_loopDelaySeconds {paramValueOf(argc, argv, "-D", std::make_pair(false, "0"))}
    {
    }

    /**
     * @brief Gets the configuration file path.
     * @return Configuration file path.
     */
    const std::string& getConfigurationFilePath() const
    {
        return m_configurationFilePath;
    }

    /**
     * @brief Gets the template file path.
     * @return Template file path.
     */
    const std::string& getTemplateFilePath() const
    {
        return m_templateFilePath;
    }

    /**
     * @brief Gets the update mappings file path.
     * @return Update mappings file path.
     */
    const std::string& getUpdateMappingsFilePath() const
    {
        return m_updateMappingsFilePath;
    }

    /**
     * @brief Gets the events file path.
     * @return Events file path.
     */
    const std::string& getEventsFilePath() const
    {
        return m_eventsFilePath;
    }

    /**
     * @brief Gets the auto generated flag.
     * @return Auto generated flag.
     */
    bool getAutoGenerated() const
    {
        return m_autoGenerated.compare("true") == 0;
    }

    /**
     * @brief Gets the number of events.
     * @return Number of events.
     */

    uint64_t getNumberOfEvents() const
    {
        return std::stoull(m_numberOfEvents);
    }

    /**
     * @brief Gets the agent id to sync event.
     * @return Agent to sync event.
     */
    const std::string& getAgentIdSyncEvent() const
    {
        return m_agentForSyncEvent;
    }

    /**
     * @brief Gets the wait time.
     * @return Wait time.
     */
    uint64_t getWaitTime() const
    {
        return std::stoull(m_waitTime);
    }

    /**
     * @brief Gets the log file path.
     * @return Log file path.
     */
    const std::string& getLogFilePath() const
    {
        return m_logFilePath;
    }

    /**
     * @brief Gets the loop sync count.
     * @return Loop sync count.
     */
    uint64_t getLoopSyncCount() const
    {
        return !m_loopSyncCount.empty() ? std::stoull(m_loopSyncCount) : 0;
    }

    /**
     * @brief Gets the loop delay in seconds.
     * @return Loop delay in seconds.
     */
    uint64_t getLoopDelaySeconds() const
    {
        return !m_loopDelaySeconds.empty() ? std::stoull(m_loopDelaySeconds) : 0;
    }

    /**
     * @brief Shows the help to the user.
     */
    static void showHelp()
    {
        std::cout << "\nUsage: indexer_connector_tool <option(s)>\n"
                  << "Options:\n"
                  << "\t-h \t\t\tShow this help message\n"
                  << "\t-c CONFIG_FILE\t\tSpecifies the configuration file (required).\n"
                  << "\t-e EVENTS_FILE\t\tSpecifies the events file to publish.\n"
                  << "\t-a AUTO_GENERATED\tAuto-generate random events (true/false).\n"
                  << "\t-n NUMBER_OF_EVENTS\tNumber of events to generate (requires -a true).\n"
                  << "\t-t TEMPLATE_FILE\tTemplate file for auto-generation (deprecated, optional).\n"
                  << "\t-L LOOP_COUNT\t\tNumber of times to call flush().\n"
                  << "\t-D DELAY_SECONDS\tDelay in seconds between flush calls (default: 0).\n"
                  << "\t-w WAIT_TIME\t\tWait time in seconds before closing (0 = wait for enter).\n"
                  << "\t-l LOG_FILE\t\tLog file path.\n"
                  << "\nExamples:"
                  << "\n\t# Index events from file:\n"
                  << "\t./indexer_connector_tool -c config.json -e events.json\n"
                  << "\n\t# Auto-generate and index 1000 random events:\n"
                  << "\t./indexer_connector_tool -c config.json -e template.json -a true -n 1000\n"
                  << "\n\t# Index events and run 30 flush cycles:\n"
                  << "\t./indexer_connector_tool -c config.json -e events.json -L 30 -D 1\n\n";
    }

private:
    static std::string paramValueOf(const int argc,
                                    const char* argv[],
                                    const std::string& switchValue,
                                    const std::pair<bool, std::string>& required = std::make_pair(true, ""))
    {
        for (int i = 1; i < argc; ++i)
        {
            const std::string currentValue {argv[i]};

            if (currentValue == switchValue && i + 1 < argc)
            {
                // Switch found
                return argv[i + 1];
            }
        }

        if (required.first)
        {
            throw std::runtime_error {"Switch value: " + switchValue + " not found."};
        }

        return required.second;
    }
    const std::string m_templateFilePath;
    const std::string m_updateMappingsFilePath;
    const std::string m_configurationFilePath;
    const std::string m_eventsFilePath;
    const std::string m_numberOfEvents;
    const std::string m_autoGenerated;
    const std::string m_agentForSyncEvent;
    const std::string m_waitTime;
    const std::string m_logFilePath;
    const std::string m_loopSyncCount;
    const std::string m_loopDelaySeconds;
};

#endif // _CMD_ARGS_PARSER_HPP_
