#include "../wmodules.h"
#include "wm_vuln_detector_db.h"
#include <os_net/os_net.h>

static void wm_vuldet_free_cpe(cpe *node);
static cpe *wm_vuldet_decode_cpe(char *raw_cpe);
static char *wm_vuldet_decode_cpe_term(char *term);
static int wm_vuldet_extract_agent_cpes(agent_software *agent, sqlite3 *db);
static int wm_vuldet_update_agent_cpes(agent_software *agent, sqlite3 *db);
static void wm_vuldet_free_search_terms(vu_search_terms *s_terms);
static vu_search_terms * wm_vuldet_extract_search_terms(char *vendor, char *product, char *version, char *arch);
static int wm_vuldet_insert_nvd_metadata(sqlite3 *db, int year, char *size, char *zip_size, char *g_size, char *sha256, char *last_mod);
static int wm_vuldet_parse_nvd_configuration(cJSON *configuration, nvd_vulnerability *data);
static int wm_vuldet_parse_nvd_configuration_node(cJSON *config, nvd_configuration **data);
static int wm_vuldet_parse_nvd_impact(cJSON *impact, nvd_vulnerability *data);
static int wm_vuldet_parse_nvd_cve(cJSON *node, nvd_vulnerability *data);
static int wm_vuldet_insert_nvd_cve_metric_cvss(sqlite3 *db, cv_scoring_system *nvd_data, int node_id);
static int wm_vuldet_insert_nvd_cve_configuration(sqlite3 *db, nvd_configuration *nvd_data, int node_id, int parent);
static int wm_vuldet_insert_nvd_cve_references(sqlite3 *db, nvd_references *nvd_data, int node_id);
static int wm_vuldet_insert_nvd_cve_match(sqlite3 *db, nvd_conf_cpe_match *nvd_data, int conf_id);
static int wm_vuldet_insert_nvd_cve_cpe(sqlite3 *db, cpe *cpe_data);
static void wm_vuldet_free_nvd_references(nvd_references *data);
static void wm_vuldet_free_nvd_conf_cpe_match(nvd_conf_cpe_match *data);
static void wm_vuldet_free_nvd_configuration(nvd_configuration *data);
static void wm_vuldet_free_cv_scoring_system(cv_scoring_system *data);
nvd_report *wm_vulndet_find_nvd_vulnerabilites(sqlite3 *db, char *agent_id);
int wm_vuldet_get_vuln_nvd_cpe(sqlite3 *db, char *vendor, char *product, char *version, nvd_report **nvd_report_list);
static nvd_report *wm_vuldet_check_nvd_vulnerability(int vulnerable, char *operator, char *version, char *v_start_inc, char *v_start_exc, char *v_end_inc, char *v_end_exc);

int wm_vuldet_nvd_cpe_parser(char *path, wm_vuldet_db *parsed_vulnerabilities) {
    FILE *fp;
    char buffer[OS_MAXSTR + 1];
    static char *cpe_header = "-item name=\"cpe:2.";
    size_t cpe_header_size = strlen(cpe_header);
    char *cpe_found;
    cpe_list *node_list;

    if (fp = fopen(path, "r"), !fp) {
        return OS_INVALID;
    }

    os_calloc(1, sizeof(cpe_list), node_list);
    while (fgets(buffer, OS_MAXSTR, fp)) {
        if (cpe_found = strstr(buffer, cpe_header), cpe_found) {
            char *cpe_end;
            cpe_found += cpe_header_size;
            if (cpe_found = strchr(cpe_found, ':'), cpe_found) {
                if (cpe_end = wstr_chr(++cpe_found, '"'), cpe_end) {
                    *cpe_end = '\0';
                    wm_vuldet_add_cpe(cpe_found, node_list, 0);
                }
            }
        }
    }

    fclose(fp);
    parsed_vulnerabilities->nvd_cpes = node_list;

    return 0;
}

int wm_vuldet_add_cpe(char *cpe_raw, cpe_list *node_list, int index) {
    cpe_node *item;

    os_calloc(1, sizeof(cpe_node), item);
    if (item->node = wm_vuldet_decode_cpe(cpe_raw), !item->node) {
        os_free(item);
        return OS_INVALID;
    }
    item->node->id = index;

    if(node_list->first == NULL) {
        node_list->first = item;
    } else {
        item->prev = node_list->last;
        node_list->last->next = item;
    }

    node_list->last = item;
    return 0;
}

int wm_vuldet_insert_cpe_db(sqlite3 *db, cpe_list *node_list, char overwrite) {
    sqlite3_stmt *stmt = NULL;
    cpe_node *node_it;
    cpe_node *node_aux;
    cpe *node;
    int result;

    if (overwrite) {
        sqlite3_exec(db, vu_queries[VU_REMOVE_CPE], NULL, NULL, NULL);

        if (sqlite3_prepare_v2(db, vu_queries[VU_REMOVE_SQUENCE], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }

        sqlite3_bind_text(stmt, 1, "CPE_INDEX", -1, NULL);

        if (result = wm_vuldet_step(stmt), result != SQLITE_DONE) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_finalize(stmt);
    }


    node_it = node_list->first;
    while(node_it) {
        node = node_it->node;
        if (sqlite3_prepare_v2(db, vu_queries[VU_INSERT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }
        if (node->id) {
            sqlite3_bind_int(stmt, 1, node->id);
        } else {
            sqlite3_bind_null(stmt, 1);
        }
        sqlite3_bind_text(stmt, 2, node->part, -1, NULL);
        sqlite3_bind_text(stmt, 3, node->vendor, -1, NULL);
        sqlite3_bind_text(stmt, 4, node->product, -1, NULL);
        sqlite3_bind_text(stmt, 5, node->version, -1, NULL);
        sqlite3_bind_text(stmt, 6, node->update, -1, NULL);
        sqlite3_bind_text(stmt, 7, node->edition, -1, NULL);
        sqlite3_bind_text(stmt, 8, node->language, -1, NULL);
        sqlite3_bind_text(stmt, 9, node->sw_edition, -1, NULL);
        sqlite3_bind_text(stmt, 10, node->target_sw, -1, NULL);
        sqlite3_bind_text(stmt, 11, node->target_hw, -1, NULL);
        sqlite3_bind_text(stmt, 12, node->other, -1, NULL);
        if (result = wm_vuldet_step(stmt), result != SQLITE_DONE) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_finalize(stmt);
        wm_vuldet_free_cpe(node);
        os_free(node);
        node_aux = node_it->next;
        os_free(node_it);
        node_it = node_aux;
    }

    return 0;
}


char *wm_vuldet_decode_cpe_term(char *term) {
    char *decoded_term;

    term = os_strip_char(term, '\\');
    decoded_term = wstr_replace(term, "&amp;", "&");
    free(term);
    term = wstr_replace(decoded_term, "&quot;", "\"");
    free(decoded_term);

    return term;
}

cpe *wm_vuldet_decode_cpe(char *raw_cpe) {
    cpe *decoded_cpe;
    char *cpeuri;
    char *cpe_str;
    char *cpe_strnext;
    int success = 0;

    os_calloc(1, sizeof(cpe), decoded_cpe);
    os_strdup(raw_cpe, cpeuri);
    //{part}:{vendor}:{product}:{version}:{update}:{edition}:{language}:{sw_edition}:{target_sw}:{target_hw}:{other}

    if (cpe_str = wstr_chr(cpeuri, ':'), cpe_str == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "vendor", raw_cpe);
        goto end;
    }
    *cpe_str++ = '\0';
    os_strdup(cpeuri, decoded_cpe->part);

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_strnext == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "product", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->vendor);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_strnext == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "version", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    decoded_cpe->product = wm_vuldet_decode_cpe_term(cpe_str);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_strnext == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "update", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    decoded_cpe->version = wm_vuldet_decode_cpe_term(cpe_str);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_strnext == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "edition", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->update);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_strnext == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "language", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->edition);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_strnext == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "target_sw", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->language);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_strnext == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "sw_edition", raw_cpe);
        goto end; //For cpe version 2.2
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->sw_edition);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_strnext == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "target_hw", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->target_sw);
    cpe_str = cpe_strnext;

    if (cpe_strnext = wstr_chr(cpe_str, ':'), cpe_strnext == NULL) {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_CPE_PARSING_ERROR, "other", raw_cpe);
        goto end;
    }
    *cpe_strnext++ = '\0';
    os_strdup(cpe_str, decoded_cpe->target_hw);
    os_strdup(cpe_strnext, decoded_cpe->other);

    success = 1;
end:
    os_free(cpeuri);
    if (!success) {
        wm_vuldet_free_cpe(decoded_cpe);
        os_free(decoded_cpe);
    }
    return decoded_cpe;
}

void wm_vuldet_free_cpe(cpe *node) {
    os_free(node->part);
    os_free(node->vendor);
    os_free(node->product);
    os_free(node->version);
    os_free(node->update);
    os_free(node->edition);
    os_free(node->language);
    os_free(node->sw_edition);
    os_free(node->target_sw);
    os_free(node->target_hw);
    os_free(node->other);
}

int wm_vuldet_get_min_cpe_index(sqlite3 *db, int *min_index) {
    sqlite3_stmt *stmt = NULL;
    int success = 0;
    char close_db = 0;

    if (!db) {
        if (sqlite3_open_v2(CVE_DB, &db, SQLITE_OPEN_READONLY, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }
        close_db = 1;
    }

    if (sqlite3_prepare_v2(db, vu_queries[VU_MIN_CPEINDEX], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }
    if (wm_vuldet_step(stmt) == SQLITE_ROW) {
        if (*min_index = sqlite3_column_int(stmt, 0), *min_index >= 0) {
            *min_index = -1;
        } else {
            (*min_index)--;
        }
    } else {
        goto end;
    }
    success = 1;
end:
    sqlite3_finalize(stmt);
    if (close_db) {
        sqlite3_close_v2(db);
    }
    return !success;
}

int wm_vuldet_extract_agent_cpes(agent_software *agent, sqlite3 *db) {
    sqlite3_stmt *stmt = NULL;
    vu_search_terms *s_terms = NULL;
    vu_search_terms *pkg_terms = NULL;
    int pkg_count, cpes_count;
    char generated_cpe[OS_SIZE_128 + 1];
    int min_cpe_index;
    int success = 0;
    vu_search_terms *f_pkg_terms;
    cpe_list *node_list = NULL;

    if (sqlite3_prepare_v2(db, vu_queries[VU_GET_PACK_WITHOUT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    sqlite3_bind_text(stmt, 1, agent->agent_id, -1, NULL);

    // Get the search terms for each package
    while (wm_vuldet_step(stmt) == SQLITE_ROW) {
        char *vendor = (char *) sqlite3_column_text(stmt, 0);
        char *product = (char *) sqlite3_column_text(stmt, 1);
        char *version = (char *) sqlite3_column_text(stmt, 2);
        char *arch = (char *) sqlite3_column_text(stmt, 3);

        if (pkg_terms = wm_vuldet_extract_search_terms(vendor, product, version, arch), !pkg_terms) {
            mterror(WM_VULNDETECTOR_LOGTAG, VU_GEN_SEARCH_TERMS_ERROR, vendor, product, version, arch, agent->agent_id);
            continue;
        }

        if (s_terms) {
            s_terms->next = pkg_terms;
            pkg_terms->prev = s_terms;
        }
        s_terms = pkg_terms;
    }
    sqlite3_finalize(stmt);

    // Use the search terms to find a valid CPE for each package
    for (pkg_count = 0, cpes_count = 0, pkg_terms = s_terms; pkg_terms;) {
        int v_index, p_index;
        pkg_count++;
        for (v_index = 0; pkg_terms->vendor_terms[v_index]; v_index++) {
            char *part = NULL;
            for (p_index = 0; pkg_terms->product_terms[p_index]; p_index++) {
                if (sqlite3_prepare_v2(db, vu_queries[VU_SEARCH_AGENT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
                    return wm_vuldet_sql_error(db, stmt);
                }

                sqlite3_bind_text(stmt, 1, pkg_terms->vendor_terms[v_index], -1, NULL);
                sqlite3_bind_text(stmt, 2, pkg_terms->product_terms[p_index], -1, NULL);

                if (wm_vuldet_step(stmt) == SQLITE_ROW) {
                    part = (char *) sqlite3_column_text(stmt, 0);
                    snprintf(generated_cpe, OS_SIZE_128, "%c:%s:%s:%s:*:*:*:*:*:%s:*", *part,
                        pkg_terms->vendor_terms[v_index], pkg_terms->product_terms[p_index],
                        pkg_terms->o_version, pkg_terms->o_arch);
                    str_lowercase(generated_cpe);
                    sqlite3_finalize(stmt);
                    mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_CPE_GENERATED, pkg_terms->o_vendor, pkg_terms->o_product, generated_cpe);
                    mtinfo(WM_VULNDETECTOR_LOGTAG, VU_CPE_GENERATED, pkg_terms->o_vendor, pkg_terms->o_product, generated_cpe); // Remove this ~~~~~~~~
                    os_strdup(generated_cpe, pkg_terms->generated_cpe);
                    cpes_count++;
                    break;
                }

                sqlite3_finalize(stmt);
            }
            if (part) {
                break;
            }
        }
        pkg_terms = pkg_terms->prev;
    }

    if (wm_vuldet_get_min_cpe_index(db, &min_cpe_index)) {
        mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_CPE_INDEX_GET_ERROR);
        goto end;
    }

    os_calloc(1, sizeof(cpe_list), node_list);
    // Link the CPEs with its packages
    for (pkg_terms = s_terms; pkg_terms;) {
        if (pkg_terms->generated_cpe) {
            if (sqlite3_prepare_v2(db, vu_queries[VU_UPDATE_AGENT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
                goto end;
            }

            sqlite3_bind_int(stmt, 1, min_cpe_index);
            sqlite3_bind_int(stmt, 2, atoi(agent->agent_id));
            sqlite3_bind_text(stmt, 3,pkg_terms->o_vendor, -1, NULL);
            sqlite3_bind_text(stmt, 4, pkg_terms->o_product, -1, NULL);
            sqlite3_bind_text(stmt, 5, pkg_terms->o_version, -1, NULL);
            sqlite3_bind_text(stmt, 6, pkg_terms->o_arch, -1, NULL);

            if (wm_vuldet_step(stmt) != SQLITE_DONE) {
                wm_vuldet_sql_error(db, stmt);
                db = NULL;
                stmt = NULL;
                goto end;
            }
            sqlite3_finalize(stmt);

            if (wm_vuldet_add_cpe(pkg_terms->generated_cpe, node_list, min_cpe_index)) {
                mterror(WM_VULNDETECTOR_LOGTAG, VU_PARSING_ERROR, pkg_terms->generated_cpe, agent->agent_id);
                goto end;
            }

            min_cpe_index--;
        }

        f_pkg_terms = pkg_terms;
        pkg_terms = pkg_terms->prev;
        wm_vuldet_free_search_terms(f_pkg_terms);
        free(f_pkg_terms);
    }

    stmt = NULL;
    if (wm_vuldet_insert_cpe_db(db, node_list, 0)) {
        goto end;
    }

    mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_GEN_CPE_COUNT, agent->agent_id, cpes_count, pkg_count);
    mtinfo(WM_VULNDETECTOR_LOGTAG, VU_GEN_CPE_COUNT, agent->agent_id, cpes_count, pkg_count); // Remove this ~~~~~~~~~~~~~~

    s_terms = NULL;
    success = 1;
end:
    if (node_list) {
        free(node_list);
    }

    if (stmt) {
        sqlite3_finalize(stmt);
    }
    if (pkg_terms) {
        while (pkg_terms) {
            f_pkg_terms = pkg_terms;
            pkg_terms = pkg_terms->prev;
            wm_vuldet_free_search_terms(f_pkg_terms);
            free(f_pkg_terms);
        }
    }
    if (!success) {
        sqlite3_close_v2(db);
        return OS_INVALID;
    }
    return 0;
}


int wm_vuldet_update_agent_cpes(agent_software *agent, sqlite3 *db) {
    int i;
    char buffer[OS_SIZE_6144 + 1];
    size_t size;
    int sock;
    sqlite3_stmt *stmt = NULL;
    int success = 0;

    for (i = 0; i < 5 && (sock = OS_ConnectUnixDomain(WDB_LOCAL_SOCK_PATH, SOCK_STREAM, OS_SIZE_6144)) < 0; i++) {
        sleep(i);
    }

    if (i == 5) {
        return OS_INVALID;
    }

    if (sqlite3_prepare_v2(db, vu_queries[VU_GET_AGENT_CPES], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

        sqlite3_bind_text(stmt, 1, agent->agent_id, -1, NULL);

    // Get the search terms for each package
    while (wm_vuldet_step(stmt) == SQLITE_ROW) {
        const char *cpe_part = (const char *) sqlite3_column_text(stmt, 0);
        const char *cpe_vendor = (const char *) sqlite3_column_text(stmt, 1);
        const char *cpe_product = (const char *) sqlite3_column_text(stmt, 2);
        const char *cpe_version = (const char *) sqlite3_column_text(stmt, 3);
        const char *cpe_updatev = (const char *) sqlite3_column_text(stmt, 4);
        const char *cpe_edition = (const char *) sqlite3_column_text(stmt, 5);
        const char *cpe_language = (const char *) sqlite3_column_text(stmt, 6);
        const char *cpe_sw_edition = (const char *) sqlite3_column_text(stmt, 7);
        const char *cpe_target_sw = (const char *) sqlite3_column_text(stmt, 8);
        const char *cpe_target_hw = (const char *) sqlite3_column_text(stmt, 9);
        const char *cpe_other = (const char *) sqlite3_column_text(stmt, 10);
        const char *vendor = (const char *) sqlite3_column_text(stmt, 11);
        const char *package = (const char *) sqlite3_column_text(stmt, 12);
        const char *version = (const char *) sqlite3_column_text(stmt, 13);
        const char *arch = (const char *) sqlite3_column_text(stmt, 14);

        size = snprintf(buffer, OS_SIZE_6144, vu_queries[VU_SYSC_UPDATE_CPE],
            agent->agent_id, cpe_part, cpe_vendor, cpe_product, cpe_version, cpe_updatev,
            cpe_edition, cpe_language, cpe_sw_edition, cpe_target_sw, cpe_target_hw, cpe_other,
            vendor, package, version, arch);
        if (OS_SendSecureTCP(sock, size + 1, buffer) || (size = OS_RecvSecureTCP(sock, buffer, OS_SIZE_6144)) < 1) {
            close(sock);
            goto end;
        }

        // Check the wazuh-db answer
        buffer[size] = '\0';
        if (strncmp(buffer, "ok", 2)) {
            mterror(WM_VULNDETECTOR_LOGTAG, VU_INV_WAZUHDB_RES, buffer);
            goto end;
        }
    }

    success = 1;
end:
    if (stmt) {
        sqlite3_finalize(stmt);
    }
    if (!success) {
        sqlite3_close_v2(db);
        return OS_INVALID;
    }
    return 0;
}

int wm_vuldet_generate_agent_cpes(agent_software *agent) {
    sqlite3 *db;

    if (sqlite3_open_v2(CVE_DB, &db, SQLITE_OPEN_READWRITE, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, NULL);
    }

    sqlite3_exec(db, vu_queries[BEGIN_T], NULL, NULL, NULL);

    if (wm_vuldet_extract_agent_cpes(agent, db)) {
        mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_AGENT_CPE_EXT_ERROR, agent->agent_id);
        return OS_INVALID;
    }

    if (wm_vuldet_update_agent_cpes(agent, db)) {
        mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_AGENT_CPE_UPD_ERROR, agent->agent_id);
        return OS_INVALID;
    }

    sqlite3_exec(db, vu_queries[END_T], NULL, NULL, NULL);
    sqlite3_close_v2(db);
    return 0;
}

vu_search_terms * wm_vuldet_extract_search_terms(char *vendor, char *product, char *version, char *arch) {
    vu_search_terms *s_terms = NULL;
    char *vendor_found;
    int vendor_words = w_word_counter(vendor);
    int product_words = w_word_counter(product);
    int fit_product_words = 0;
    char *vendor_cpy;
    char *product_cpy;

    os_calloc(1, sizeof(vu_search_terms), s_terms);

    os_strdup(vendor, s_terms->o_vendor);
    os_strdup(vendor, vendor_cpy);
    os_strdup(product, s_terms->o_product);
    os_strdup(product, product_cpy);
    os_strdup(version, s_terms->o_version);
    os_strdup(arch, s_terms->o_arch);

    str_lowercase(vendor_cpy);
    str_lowercase(product_cpy);
    //str_lowercase(s_terms->o_version);
    //str_lowercase(s_terms->o_arch);

    os_calloc(2, sizeof(char *), s_terms->vendor_terms);
    os_calloc(3, sizeof(char *), s_terms->product_terms);
    os_strdup(vendor_cpy, *s_terms->vendor_terms);
    os_strdup(product_cpy, *s_terms->product_terms);
    wchr_replace(*s_terms->vendor_terms, ' ', '_');
    wchr_replace(*s_terms->product_terms, ' ', '_');

    // If the vendor appears inside the product, it will be taken into account separately
    if (vendor_found = strstr(product_cpy, vendor_cpy), vendor_found) {
        vendor_found += strlen(vendor_cpy);
        vendor_found += *vendor_found == ' ' ? 1 : 0;
        if (*vendor_found != '\0') {
            os_strdup(vendor_found, s_terms->product_terms[1]);
            wchr_replace(*s_terms->product_terms, ' ', '_');
            fit_product_words = w_word_counter(vendor_found);
        } else {
            vendor_found = NULL;
        }
    }

    if (vendor_words != 3) wstr_split(vendor_cpy, " ", "_", 3, &s_terms->vendor_terms);
    if (vendor_words != 2) wstr_split(vendor_cpy, " ", "_", 2, &s_terms->vendor_terms);
    if (vendor_words != 1) wstr_split(vendor_cpy, " ", "_", 1, &s_terms->vendor_terms);

    if (product_words != 4) wstr_split(product_cpy, " ", "_", 4, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 4) wstr_split(vendor_found, " ", "_", 4, &s_terms->product_terms);
    if (product_words != 3 ) wstr_split(product_cpy, " ", "_", 3, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 3) wstr_split(vendor_found, " ", "_", 3, &s_terms->product_terms);
    if (product_words != 2) wstr_split(product_cpy, " ", "_", 2, &s_terms->product_terms);
    if (vendor_found && fit_product_words != 2) wstr_split(vendor_found, " ", "_", 2, &s_terms->product_terms);
    if (product_words != 1) wstr_split(product_cpy, " ", "_", 1, &s_terms->product_terms);

    free(vendor_cpy);
    free(product_cpy);

    return s_terms;
}

void wm_vuldet_free_search_terms(vu_search_terms *s_terms) {
    int i;
    os_free(s_terms->o_vendor);
    os_free(s_terms->o_product);
    os_free(s_terms->o_version);
    os_free(s_terms->o_arch);
    os_free(s_terms->generated_cpe)

    if (s_terms->vendor_terms) {
        for (i = 0; s_terms->vendor_terms[i]; i++) {
            os_free(s_terms->vendor_terms[i]);
        }
        os_free(s_terms->vendor_terms);
    }

    if (s_terms->product_terms) {
        for (i = 0; s_terms->product_terms[i]; i++) {
            os_free(s_terms->product_terms[i]);
        }
        os_free(s_terms->product_terms);
    }

    if (s_terms->version_terms) {
        for (i = 0; s_terms->version_terms[i]; i++) {
            os_free(s_terms->version_terms[i]);
        }
        os_free(s_terms->version_terms);
    }

    if (s_terms->arch_terms) {
        for (i = 0; s_terms->arch_terms[i]; i++) {
            os_free(s_terms->arch_terms[i]);
        }
        os_free(s_terms->arch_terms);
    }
}

int wm_vuldet_fetch_nvd_cpe(char *repo) {
    if (*repo == '\0') {
        snprintf(repo, OS_SIZE_256, NVD_CPE_REPO);
    }

    if (wstr_end(repo, ".gz")) {
        if (wurl_request_gz(repo, VU_TEMP_FILE)) {
            return OS_INVALID;
        }
    } else {
        if (wurl_request(repo, VU_TEMP_FILE)) {
            return OS_INVALID;
        }
    }

    return 0;
}

int wm_vuldet_fetch_nvd_cve(update_node *update, char *repo) {
    int attempt;
    int retval = VU_INV_FEED;
    char buffer[OS_MAXSTR + 1];
    FILE *fp;
    char *found;
    sqlite3_stmt *stmt = NULL;
    sqlite3 *db = NULL;
    static char *feed_last_mod = "lastModifiedDate:";
    static char *feed_size = "size:";
    static char *feed_zsize = "zipSize:";
    static char *feed_gsize = "gzSize:";
    static char *feed_sha256 = "sha256:";
    char *last_mod = NULL;
    char *size = NULL;
    char *zip_size = NULL;
    char *g_size = NULL;
    char *sha256 = NULL;

    if (*repo != '\0') {
        if (wurl_request(repo, VU_FIT_TEMP_FILE)) {
            goto end;
        }
    } else {
        // Check the metadata feed
        snprintf(repo, OS_SIZE_2048, NVD_CVE_REPO_META, update->update_it);
        for (attempt = 0; attempt < NVD_REPO_MAX_ATTEMPTS; attempt++) {
            if (wurl_request(repo, VU_TEMP_FILE)) {
                mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_API_REQ_INV, repo, attempt * DOWNLOAD_SLEEP_FACTOR);
                sleep(attempt * DOWNLOAD_SLEEP_FACTOR);
                continue;
            }
            break;
        }
        if (attempt == NVD_REPO_MAX_ATTEMPTS) {
            mterror(WM_VULNDETECTOR_LOGTAG, VU_API_REQ_INV, repo, NVD_REPO_MAX_ATTEMPTS);
            goto end;
        }

        if (fp = fopen(VU_TEMP_FILE, "r"), !fp) {
            goto end;
        }

        if (sqlite3_open_v2(CVE_DB, &db, SQLITE_OPEN_READWRITE, NULL)) {
            wm_vuldet_sql_error(db, stmt);
            db = NULL;
            return VU_INV_FEED;
        }

        while (fgets(buffer, OS_MAXSTR, fp)) {
            if (found = strstr(buffer, feed_last_mod), found) {
                os_strdup(found + strlen(feed_last_mod), last_mod);

                if (sqlite3_prepare_v2(db, vu_queries[VU_GET_NVD_LASTMOD], -1, &stmt, NULL) != SQLITE_OK) {
                    wm_vuldet_sql_error(db, stmt);
                    db = NULL;
                    return VU_INV_FEED;
                }
                sqlite3_bind_int(stmt, 1, update->update_it);

                if (wm_vuldet_step(stmt) == SQLITE_ROW) {
                    found = (char *)sqlite3_column_text(stmt, 0);

                    // Check if our feed is outdated
                    if (!strcmp(last_mod, found)) {
                        sqlite3_finalize(stmt);
                        retval = VU_NOT_NEED_UPDATE;
                        goto end;
                    }
                }
                sqlite3_finalize(stmt);
            } else if (found = strstr(buffer, feed_size), found) {
                os_strdup(found + strlen(feed_size), size);
            } else if (found = strstr(buffer, feed_zsize), found) {
                os_strdup(found + strlen(feed_zsize), zip_size);
            } else if (found = strstr(buffer, feed_gsize), found) {
                os_strdup(found + strlen(feed_gsize), g_size);
            } else if (found = strstr(buffer, feed_sha256), found) {
                os_strdup(found + strlen(feed_sha256), sha256);
            }
        }
        w_fclose(fp);

        // At this point we know that we must update the feed for this year
        snprintf(repo, OS_SIZE_2048, NVD_CVE_REPO, update->update_it);
        for (attempt = 0; attempt < NVD_REPO_MAX_ATTEMPTS; attempt++) {
            if (wurl_request_gz(repo, VU_FIT_TEMP_FILE)) {
                mtdebug1(WM_VULNDETECTOR_LOGTAG, VU_API_REQ_INV, repo, attempt * DOWNLOAD_SLEEP_FACTOR);
                sleep(attempt * DOWNLOAD_SLEEP_FACTOR);
                continue;
            }
            break;
        }

        if (attempt == NVD_REPO_MAX_ATTEMPTS) {
            mterror(WM_VULNDETECTOR_LOGTAG, VU_API_REQ_INV, repo, NVD_REPO_MAX_ATTEMPTS);
            goto end;
        }

        // Update the metadata entry
        // This entry will be removed if the nvd_vulnerability feed udpate fails
        if (wm_vuldet_insert_nvd_metadata(db, update->update_it, size, zip_size, g_size, sha256, last_mod)) {
            db = NULL;
            goto end;
        }
    }

    retval = 0;
end:
    free(size);
    if (db) {
        sqlite3_close_v2(db);
    }
    if (fp) {
        fclose(fp);
        if (remove(VU_TEMP_FILE) < 0 && errno != ENOENT) {
            mtdebug2(WM_VULNDETECTOR_LOGTAG, "remove(%s): %s", VU_TEMP_FILE, strerror(errno));
        }
    }
    return retval;
}

int wm_vuldet_insert_nvd_metadata(sqlite3 *db, int year, char *size, char *zip_size, char *g_size, char *sha256, char *last_mod) {
    sqlite3_stmt *stmt;

    if (sqlite3_prepare_v2(db, vu_queries[VU_REP_NVD_METADATA], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    sqlite3_bind_int(stmt, 1, year);
    sqlite3_bind_text(stmt, 2, size, -1, NULL);
    sqlite3_bind_text(stmt, 3, zip_size, -1, NULL);
    sqlite3_bind_text(stmt, 4, g_size, -1, NULL);
    sqlite3_bind_text(stmt, 5, sha256, -1, NULL);
    sqlite3_bind_text(stmt, 6, last_mod, -1, NULL);
    sqlite3_bind_int(stmt, 7, -1);

    if (wm_vuldet_step(stmt) != SQLITE_DONE) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_finalize(stmt);

    return 0;
}

int wm_vuldet_remove_nvd_metadata(int year) {
    sqlite3_stmt *stmt = NULL;
    sqlite3 *db;

    if (sqlite3_open_v2(CVE_DB, &db, SQLITE_OPEN_READWRITE, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    if (sqlite3_prepare_v2(db, vu_queries[VU_REMOVE_NVD_METADATA], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    sqlite3_bind_int(stmt, 1, year);

    if (wm_vuldet_step(stmt) != SQLITE_DONE) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_finalize(stmt);
    sqlite3_close_v2(db);
    return 0;
}

int wm_vuldet_json_nvd_parser(cJSON *json_feed, wm_vuldet_db *parsed_vulnerabilities) {
    cJSON *cve_list;
    cJSON *cve_content;
    nvd_vulnerability *nvd_it = NULL;
    static char *JSON_CVE_ITEMS = "CVE_Items";
    static char *JSON_CVE = "cve";
    static char *JSON_CONFIGURATIONS = "configurations";
    static char *JSON_IMPACT = "impact";
    static char *JSON_PUBLISHED = "publishedDate";
    static char *JSON_LAST_MOD = "lastModifiedDate";
    static char *JSON_DATA_TYPE = "data_type";
    static char *JSON_DATA_FORMAT = "data_format";
    static char *JSON_DATA_VERSION = "data_version";

    for (json_feed = json_feed->child; json_feed; json_feed = json_feed->next) {
        if (!strcmp(json_feed->string, JSON_CVE_ITEMS)) {
            for (cve_list = json_feed->child; cve_list; cve_list = cve_list->next) {
                if (nvd_it) {
                    os_calloc(1, sizeof(nvd_vulnerability), nvd_it->next);
                    nvd_it = nvd_it->next;
                } else {
                    os_calloc(1, sizeof(nvd_vulnerability), parsed_vulnerabilities->nvd_vulnerabilities);
                    nvd_it = parsed_vulnerabilities->nvd_vulnerabilities;
                }
                for (cve_content = cve_list->child; cve_content; cve_content = cve_content->next) {
                    if (!strcmp(cve_content->string, JSON_CVE)) {
                        wm_vuldet_parse_nvd_cve(cve_content, nvd_it);
                    } else if (!strcmp(cve_content->string, JSON_CONFIGURATIONS)) {
                        wm_vuldet_parse_nvd_configuration(cve_content, nvd_it);
                    } else if (!strcmp(cve_content->string, JSON_IMPACT)) {
                        wm_vuldet_parse_nvd_impact(cve_content, nvd_it);
                    } else if (!strcmp(cve_content->string, JSON_PUBLISHED)) {
                        os_strdup(cve_content->valuestring, nvd_it->published);
                    } else if (!strcmp(cve_content->string, JSON_LAST_MOD)) {
                        os_strdup(cve_content->valuestring, nvd_it->last_modified);
                    } else if (strcmp(cve_content->string, JSON_DATA_TYPE) &&
                               strcmp(cve_content->string, JSON_DATA_FORMAT) &&
                               strcmp(cve_content->string, JSON_DATA_VERSION)) {
                        mtwarn(WM_VULNDETECTOR_LOGTAG, VU_UNKNOWN_NVD_CVE_TAG, cve_content->string);
                    } else {
                        mtwarn(WM_VULNDETECTOR_LOGTAG, VU_UNKNOWN_NVD_TAG, cve_content->string);
                    }
                }
            }
        }
    }

    return 0;
}

int wm_vuldet_parse_nvd_cve(cJSON *node, nvd_vulnerability *data) {
    cJSON *cve_data;
    cJSON *cve_data_it;
    static char *JSON_DESCRIPTION_DATA = "description_data";
    static char *JSON_LANG = "lang";
    static char *JSON_VALUE = "value";
    static char *JSON_EN_LANG = "en";
    static char *JSON_CVE_DATA_META = "CVE_data_meta";
    static char *JSON_PROBLEM_TYPE = "problemtype";
    static char *JSON_PROBLEM_TYPE_DATA = "problemtype_data";
    static char *JSON_REFERENCES = "references";
    static char *JSON_REFERENCE_DATA = "reference_data";
    static char *JSON_URL = "url";
    static char *JSON_REFERENCE_SOURCE = "refsource";
    static char *JSON_DESCRIPTION = "description";

    for (cve_data = node->child; cve_data; cve_data = cve_data->next) {
        if (!strcmp(cve_data->string, JSON_CVE_DATA_META)) {
            os_strdup(cve_data->child->valuestring, data->id);
        } else if (!strcmp(cve_data->string, JSON_PROBLEM_TYPE)) {
            if ((cve_data_it = cve_data->child) && !strcmp(cve_data_it->string, JSON_PROBLEM_TYPE_DATA)) {
                if ((cve_data_it = cve_data_it->child ? cve_data_it->child->child : NULL) && !strcmp(cve_data_it->string, JSON_DESCRIPTION)) {
                    for (cve_data_it = cve_data_it->child ? cve_data_it->child->child : NULL; cve_data_it; cve_data_it = cve_data_it->next) {
                        if (!strcmp(cve_data_it->string, JSON_VALUE)) {
                            os_strdup(cve_data_it->valuestring, data->cwe);
                            break;
                        }
                    }
                }
            }
        } else if (!strcmp(cve_data->string, JSON_REFERENCES)) {
            if ((cve_data_it = cve_data->child) && !strcmp(cve_data_it->string, JSON_REFERENCE_DATA)) {
                nvd_references *ref_node = NULL;
                for (cve_data_it = cve_data_it->child; cve_data_it; cve_data_it = cve_data_it->next) {
                    cJSON *reference_it;
                    if (ref_node) {
                        os_calloc(1, sizeof(nvd_references), ref_node->next);
                        ref_node = ref_node->next;
                    } else {
                        os_calloc(1, sizeof(nvd_references), data->references);
                        ref_node = data->references;
                    }
                    for (reference_it = cve_data_it->child; reference_it; reference_it = reference_it->next) {
                        if (!strcmp(reference_it->string, JSON_URL)) {
                            os_strdup(reference_it->valuestring, ref_node->url);
                        } else if (!strcmp(reference_it->string, JSON_REFERENCE_SOURCE)) {
                            os_strdup(reference_it->valuestring, ref_node->refsource);
                        }
                    }
                }
            }
        } else if (!strcmp(cve_data->string, JSON_DESCRIPTION) && cve_data->child) {
            if ((cve_data_it = cve_data->child) && !strcmp(cve_data_it->string, JSON_DESCRIPTION_DATA)) {
                char valid_desc;
                cJSON *desc_it;
                for (; cve_data_it; cve_data_it = cve_data_it->next) {
                    valid_desc = 0;
                    for (desc_it = cve_data_it->child ? cve_data_it->child->child : NULL; desc_it; desc_it = desc_it->next) {
                        if (!strcmp(desc_it->string, JSON_VALUE)) {
                            os_strdup(desc_it->valuestring, data->description);
                        } else if (!strcmp(desc_it->string, JSON_LANG) && !strcmp(desc_it->valuestring, JSON_EN_LANG)) {
                            valid_desc = 1;
                        }
                    }
                    if (valid_desc) {
                        break;
                    } else {
                        os_free(data->description);
                    }
                }
            }
        }
    }

    return 0;
}

int wm_vuldet_parse_nvd_configuration(cJSON *nvd_item, nvd_vulnerability *data) {
    static char *JSON_NODES = "nodes";

    for (nvd_item = nvd_item->child; nvd_item; nvd_item = nvd_item->next) {
        if (!strcmp(nvd_item->string, JSON_NODES)) {
            wm_vuldet_parse_nvd_configuration_node(nvd_item, &data->configuration);
            break;
        }
    }

    return 0;
}

int wm_vuldet_parse_nvd_configuration_node(cJSON *config, nvd_configuration **data) {
    cJSON *config_it;
    cJSON *cpe_match_item;
    cJSON *cpe_match_element;
    nvd_configuration *data_config_it = NULL;
    nvd_conf_cpe_match *cpe_match_node = NULL;
    static char *CPE_VER_TAG = "cpe:2.3:";
    static char *JSON_OPERATOR = "operator";
    static char *JSON_CHILDREN = "children";
    static char *JSON_CPE_MATCH = "cpe_match";
    static char *JSON_VULNERABLE = "vulnerable";
    static char *JSON_CPE23URI = "cpe23Uri";
    static char *JSON_START_INC = "versionStartIncluding";
    static char *JSON_END_INC = "versionEndIncluding";
    static char *JSON_START_EXC = "versionStartExcluding";
    static char *JSON_END_EXC = "versionEndExcluding";

    for (config = config->child; config; config = config->next) {
        if (data_config_it) {
            os_calloc(1, sizeof(nvd_configuration), data_config_it->next);
            data_config_it = data_config_it->next;
            cpe_match_node = data_config_it->cpe_matches;
        } else {
            os_calloc(1, sizeof(nvd_configuration), *data);
            data_config_it = *data;
            cpe_match_node = data_config_it->cpe_matches;
        }

        for (config_it = config->child; config_it; config_it = config_it->next) {
            if (!strcmp(config_it->string, JSON_OPERATOR)) {
                os_strdup(config_it->valuestring, data_config_it->operator);
            } else if (!strcmp(config_it->string, JSON_CHILDREN)) {
                wm_vuldet_parse_nvd_configuration_node(config_it, &data_config_it->children);
            } else if (!strcmp(config_it->string, JSON_CPE_MATCH)) {
                for (cpe_match_item = config_it->child; cpe_match_item; cpe_match_item = cpe_match_item->next) {
                    if (cpe_match_node) {
                        os_calloc(1, sizeof(nvd_conf_cpe_match), cpe_match_node->next);
                        cpe_match_node = cpe_match_node->next;
                    } else {
                        os_calloc(1, sizeof(nvd_conf_cpe_match), data_config_it->cpe_matches);
                        cpe_match_node = data_config_it->cpe_matches;
                    }
                    for(cpe_match_element = cpe_match_item->child; cpe_match_element; cpe_match_element = cpe_match_element->next) {
                        if (!strcmp(cpe_match_element->string, JSON_VULNERABLE)) {
                            cpe_match_node->vulnerable = cpe_match_element->valueint;
                        } else if (!strcmp(cpe_match_element->string, JSON_CPE23URI)) {
                            os_strdup(cpe_match_element->valuestring, cpe_match_node->cpe_uri23);
                            cpe_match_node->cpe_node = wm_vuldet_decode_cpe(cpe_match_node->cpe_uri23 + strlen(CPE_VER_TAG));
                        } else if (!strcmp(cpe_match_element->string, JSON_START_INC)) {
                            os_strdup(cpe_match_element->valuestring, cpe_match_node->version_start_including);
                        } else if (!strcmp(cpe_match_element->string, JSON_END_INC)) {
                            os_strdup(cpe_match_element->valuestring, cpe_match_node->version_end_including);
                        } else if (!strcmp(cpe_match_element->string, JSON_START_EXC)) {
                            os_strdup(cpe_match_element->valuestring, cpe_match_node->version_start_excluding);
                        } else if (!strcmp(cpe_match_element->string, JSON_END_EXC)) {
                            os_strdup(cpe_match_element->valuestring, cpe_match_node->version_end_excluding);
                        }
                    }
                }
            }
        }
    }

    return 0;
}

int wm_vuldet_parse_nvd_impact(cJSON *nvd_item, nvd_vulnerability *data) {
    cJSON *impact_element;
    cJSON *cvss_data;
    cv_scoring_system * scoring;
    static char *JSON_VERSION = "version";
    static char *JSON_V20 = "2.0";
    static char *JSON_V30 = "3.0";
    static char *JSON_VECT_STR = "vectorString";
    static char *JSON_BASE_SCORE = "baseScore";
    static char *JSON_EXP_SCORE = "exploitabilityScore";
    static char *JSON_IMP_SCORE = "impactScore";

    for (nvd_item = nvd_item->child; nvd_item; nvd_item = nvd_item->next) {
        for (impact_element = nvd_item->child; impact_element; impact_element = impact_element->next) {
            for (cvss_data = impact_element->child; cvss_data; cvss_data = cvss_data->next) {
                if (!strcmp(cvss_data->string, JSON_VERSION)) {
                    if (!strcmp(cvss_data->valuestring, JSON_V20)) {
                        os_calloc(1, sizeof(cv_scoring_system), scoring);
                        data->cvss2 = scoring;
                    } else if (!strcmp(cvss_data->valuestring, JSON_V30)) {
                        os_calloc(1, sizeof(cv_scoring_system), scoring);
                        data->cvss3 = scoring;
                    }
                    os_strdup(cvss_data->valuestring, scoring->version);
                } else if (!strcmp(cvss_data->string, JSON_VECT_STR)) {
                    os_strdup(cvss_data->valuestring, scoring->vector_string);
                } else if (!strcmp(cvss_data->string, JSON_BASE_SCORE)) {
                    scoring->base_score = cvss_data->valuedouble;
                }
            }

            if (scoring) {
                if (!strcmp(impact_element->string, JSON_EXP_SCORE)) {
                    scoring->exploitability_score = impact_element->valuedouble;
                } else if (!strcmp(impact_element->string, JSON_IMP_SCORE)) {
                    scoring->impact_score = impact_element->valuedouble;
                }
            }
        }
    }

    return 0;
}

int wm_vuldet_insert_nvd_cve(sqlite3 *db, nvd_vulnerability *nvd_data, int year) {
    sqlite3_stmt *stmt = NULL;
    int result;
    int id_nvd_cve = 0;

    if (sqlite3_prepare_v2(db, vu_queries[INSERT_NVD_CVE], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    sqlite3_bind_int(stmt, 1, year);
    sqlite3_bind_text(stmt, 2, nvd_data->id, -1, NULL);
    sqlite3_bind_text(stmt, 3, nvd_data->cwe, -1, NULL);
    sqlite3_bind_text(stmt, 4, nvd_data->description, -1, NULL);
    sqlite3_bind_text(stmt, 5, nvd_data->published, -1, NULL);
    sqlite3_bind_text(stmt, 6, nvd_data->last_modified, -1, NULL);

    if (result = wm_vuldet_step(stmt), result != SQLITE_DONE && result != SQLITE_CONSTRAINT) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_finalize(stmt);

    if (sqlite3_prepare_v2(db, vu_queries[GET_MAX_NVD_CVE_ID], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    if (result = wm_vuldet_step(stmt), result != SQLITE_ROW) {
        return wm_vuldet_sql_error(db, stmt);
    }

    id_nvd_cve = sqlite3_column_int(stmt, 0);
    sqlite3_finalize(stmt);

    if (id_nvd_cve > 0) {
        if (nvd_data->references) {
            if (wm_vuldet_insert_nvd_cve_references(db, nvd_data->references, id_nvd_cve)) {
                return OS_INVALID;
            }
        }
        if (nvd_data->configuration) {
            if (wm_vuldet_insert_nvd_cve_configuration(db, nvd_data->configuration, id_nvd_cve, 0)) {
                return OS_INVALID;
            }
        }
        if (nvd_data->cvss2) {
            if (wm_vuldet_insert_nvd_cve_metric_cvss(db, nvd_data->cvss2, id_nvd_cve)) {
                return OS_INVALID;
            }
        }
        if (nvd_data->cvss3) {
            if (wm_vuldet_insert_nvd_cve_metric_cvss(db, nvd_data->cvss3, id_nvd_cve)) {
                return OS_INVALID;
            }
        }
    } else {
        mterror(WM_VULNDETECTOR_LOGTAG, VU_NVD_ROW_GET_ERROR, "NVD_CVE");
        sqlite3_close_v2(db);
        return OS_INVALID;
    }

    return 0;
}

int wm_vuldet_insert_nvd_cve_references(sqlite3 *db, nvd_references *nvd_data, int node_id) {
    nvd_references *node;
    sqlite3_stmt *stmt = NULL;
    int result;

    node = nvd_data;
    while(node && node->url) {
        if (sqlite3_prepare_v2(db, vu_queries[INSERT_NVD_REFERENCE], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_bind_int(stmt, 1, node_id);
        sqlite3_bind_text(stmt, 2, node->url, -1, NULL);
        sqlite3_bind_text(stmt, 3, node->refsource, -1, NULL);

        if (result = wm_vuldet_step(stmt), result != SQLITE_DONE && result != SQLITE_CONSTRAINT) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_finalize(stmt);
        node = node->next;
    }

    return 0;
}

int wm_vuldet_insert_nvd_cve_metric_cvss(sqlite3 *db, cv_scoring_system *nvd_data, int node_id) {
    sqlite3_stmt *stmt = NULL;
    int result;

    if (sqlite3_prepare_v2(db, vu_queries[INSERT_NVD_METRIC_CVSS], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }

    sqlite3_bind_int(stmt, 1, node_id);
    sqlite3_bind_text(stmt, 2, nvd_data->version, -1, NULL);
    sqlite3_bind_text(stmt, 3, nvd_data->vector_string, -1, NULL);
    sqlite3_bind_int(stmt, 4, nvd_data->base_score);
    sqlite3_bind_int(stmt, 5, nvd_data->exploitability_score);
    sqlite3_bind_int(stmt, 6, nvd_data->impact_score);

    if (result = wm_vuldet_step(stmt), result != SQLITE_DONE && result != SQLITE_CONSTRAINT) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_finalize(stmt);

    return 0;
}

int wm_vuldet_insert_nvd_cve_configuration(sqlite3 *db, nvd_configuration *nvd_data, int cve_node_id, int parent) {
    nvd_configuration *node;
    sqlite3_stmt *stmt = NULL;
    int result;
    int conf_id = 0;

    node = nvd_data;
    while(node) {
        if (sqlite3_prepare_v2(db, vu_queries[INSERT_NVD_CVE_CONFIGURATION], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_bind_int(stmt, 1, cve_node_id);
        sqlite3_bind_int(stmt, 2, parent);
        sqlite3_bind_text(stmt, 3, node->operator, -1, NULL);

        if (result = wm_vuldet_step(stmt), result != SQLITE_DONE && result != SQLITE_CONSTRAINT) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_finalize(stmt);

        if (sqlite3_prepare_v2(db, vu_queries[GET_MAX_CONFIGURATION_ID], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }

        if (result = wm_vuldet_step(stmt), result != SQLITE_ROW) {
            return wm_vuldet_sql_error(db, stmt);
        }

        conf_id = sqlite3_column_int(stmt, 0);
        sqlite3_finalize(stmt);

        if (conf_id > 0) {
            if(node->children) {
                if (wm_vuldet_insert_nvd_cve_configuration(db, node->children, cve_node_id, conf_id)) {
                    return OS_INVALID;
                }
            }
            if(node->cpe_matches) {
                if (wm_vuldet_insert_nvd_cve_match(db, node->cpe_matches, conf_id)) {
                    return OS_INVALID;
                }
            }
        } else {
            mterror(WM_VULNDETECTOR_LOGTAG, VU_NVD_ROW_GET_ERROR, "NVD_CVE_CONFIGURATION");
            sqlite3_close_v2(db);
            return OS_INVALID;
        }
        node = node->next;
    }

    return 0;
}

int wm_vuldet_insert_nvd_cve_match(sqlite3 *db, nvd_conf_cpe_match *nvd_data, int conf_id) {
    nvd_conf_cpe_match *node;
    sqlite3_stmt *stmt = NULL;
    int result;
    int cpe_id;

    node = nvd_data;
    while(node) {
        if (cpe_id = wm_vuldet_insert_nvd_cve_cpe(db, node->cpe_node), !cpe_id) {
            return OS_INVALID;
        }

        if (sqlite3_prepare_v2(db, vu_queries[INSERT_NVD_CVE_MATCH], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_bind_int(stmt, 1, conf_id);
        sqlite3_bind_int(stmt, 2, cpe_id);
        sqlite3_bind_int(stmt, 3, node->vulnerable);
        sqlite3_bind_text(stmt, 4, node->cpe_uri23, -1, NULL);
        sqlite3_bind_text(stmt, 5, node->version_start_including, -1, NULL);
        sqlite3_bind_text(stmt, 6, node->version_start_excluding, -1, NULL);
        sqlite3_bind_text(stmt, 7, node->version_end_including, -1, NULL);
        sqlite3_bind_text(stmt, 8, node->version_end_excluding, -1, NULL);

        if (result = wm_vuldet_step(stmt), result != SQLITE_DONE && result != SQLITE_CONSTRAINT) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_finalize(stmt);
        node = node->next;
    }

    return 0;
}

int wm_vuldet_insert_nvd_cve_cpe(sqlite3 *db, cpe *cpe_data) {
    sqlite3_stmt *stmt = NULL;
    int result;
    unsigned long int cpe_id = 0;

    if (sqlite3_prepare_v2(db, vu_queries[GET_MAX_NVD_CPE_ID], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }
    result = wm_vuldet_step(stmt);

    if (result == SQLITE_ROW) {
        if (cpe_id = sqlite3_column_int(stmt, 0), cpe_id > 0) {
            cpe_id++;
        } else {
            cpe_id = 1;
        }
    } else if (result == SQLITE_DONE) {
        cpe_id = 1;
    } else {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_finalize(stmt);

    if (sqlite3_prepare_v2(db, vu_queries[INSERT_NVD_CPE], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_bind_int(stmt, 1, cpe_id);
    sqlite3_bind_text(stmt, 2, cpe_data->part, -1, NULL);
    sqlite3_bind_text(stmt, 3, cpe_data->vendor, -1, NULL);
    sqlite3_bind_text(stmt, 4, cpe_data->product, -1, NULL);
    sqlite3_bind_text(stmt, 5, cpe_data->version, -1, NULL);
    sqlite3_bind_text(stmt, 6, cpe_data->update, -1, NULL);
    sqlite3_bind_text(stmt, 7, cpe_data->edition, -1, NULL);
    sqlite3_bind_text(stmt, 8, cpe_data->language, -1, NULL);
    sqlite3_bind_text(stmt, 9, cpe_data->sw_edition, -1, NULL);
    sqlite3_bind_text(stmt, 10, cpe_data->target_sw, -1, NULL);
    sqlite3_bind_text(stmt, 11, cpe_data->target_hw, -1, NULL);
    sqlite3_bind_text(stmt, 12, cpe_data->other, -1, NULL);

    if (result = wm_vuldet_step(stmt), result != SQLITE_DONE && result != SQLITE_CONSTRAINT) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_finalize(stmt);

    if(result == SQLITE_CONSTRAINT) {
        if (sqlite3_prepare_v2(db, vu_queries[GET_AN_CPE_ID], -1, &stmt, NULL) != SQLITE_OK) {
            return wm_vuldet_sql_error(db, stmt);
        }
        sqlite3_bind_text(stmt, 1, cpe_data->part, -1, NULL);
        sqlite3_bind_text(stmt, 2, cpe_data->vendor, -1, NULL);
        sqlite3_bind_text(stmt, 3, cpe_data->product, -1, NULL);
        sqlite3_bind_text(stmt, 4, cpe_data->version, -1, NULL);
        sqlite3_bind_text(stmt, 5, cpe_data->update, -1, NULL);
        sqlite3_bind_text(stmt, 6, cpe_data->edition, -1, NULL);
        sqlite3_bind_text(stmt, 7, cpe_data->language, -1, NULL);
        sqlite3_bind_text(stmt, 8, cpe_data->sw_edition, -1, NULL);
        sqlite3_bind_text(stmt, 9, cpe_data->target_sw, -1, NULL);
        sqlite3_bind_text(stmt, 10, cpe_data->target_hw, -1, NULL);
        sqlite3_bind_text(stmt, 11, cpe_data->other, -1, NULL);

        if (result = wm_vuldet_step(stmt), result != SQLITE_ROW) {
            return wm_vuldet_sql_error(db, stmt);
        }
        cpe_id = sqlite3_column_int(stmt, 0);
        sqlite3_finalize(stmt);
    }

    return cpe_id;
}

void wm_vuldet_free_nvd_references(nvd_references *data) {
    nvd_references *node;

    while (data) {
        node = data->next;
        os_free(data->url);
        os_free(data->refsource);
        os_free(data);
        data = node;
    }
}

void wm_vuldet_free_nvd_conf_cpe_match(nvd_conf_cpe_match *data) {
    nvd_conf_cpe_match *node;

    while (data) {
        node = data->next;
        os_free(data->cpe_uri23);
        os_free(data->version_start_including);
        os_free(data->version_start_excluding);
        os_free(data->version_end_including);
        os_free(data->version_end_excluding);
        wm_vuldet_free_cpe(data->cpe_node);
        os_free(data->cpe_node);
        os_free(data);
        data = node;
    }
}

void wm_vuldet_free_nvd_configuration(nvd_configuration *data) {
    nvd_configuration *node;

    while (data) {
        node = data->next;
        wm_vuldet_free_nvd_conf_cpe_match(data->cpe_matches);
        wm_vuldet_free_nvd_configuration(data->children);
        os_free(data->operator);
        os_free(data);
        data = node;
    }
}

void wm_vuldet_free_cv_scoring_system(cv_scoring_system *data) {
    if(data) {
        os_free(data->vector_string);
        os_free(data->version);
        os_free(data);
    }
}

void wm_vuldet_free_nvd_node(nvd_vulnerability *data) {
    os_free(data->id);
    os_free(data->cwe);
    os_free(data->description);
    wm_vuldet_free_nvd_references(data->references);
    wm_vuldet_free_nvd_configuration(data->configuration);
    wm_vuldet_free_cv_scoring_system(data->cvss2);
    wm_vuldet_free_cv_scoring_system(data->cvss3);
    os_free(data->published);
    os_free(data->last_modified);
    os_free(data);
}

int wm_vuldet_report_nvd_vulnerabilities(sqlite3 *db, char *agent_id) {
    nvd_report *nvd_report_list;
    //find VULNERABILITIES (wm_vulndet_find_nvd_vulnerabilites)
        //find exctly
        //find candidates
        //
    //Report vulnerability
        //generate json alerts
        //send json alert

    if (nvd_report_list = wm_vulndet_find_nvd_vulnerabilites(db, agent_id), !nvd_report_list) {
        return OS_INVALID;
    }

    /*
    if (sqlite3_prepare_v2(db, query, -1, &stmt, NULL) != SQLITE_OK) {
        cJSON_free(alert);
        return OS_INVALID;
    }
    sqlite3_bind_text(stmt, 1, agents_it->agent_OS, -1, NULL);

    sqlite3_bind_int(stmt, 2,  strtol(agents_it->agent_id, NULL, 10));

    while (sql_result = wm_vuldet_step(stmt), sql_result == SQLITE_ROW) {

    }
    sqlite3_finalize(stmt);
    */

    return 0;
}

nvd_report *wm_vulndet_find_nvd_vulnerabilites(sqlite3 *db, char *agent_id) {
    sqlite3_stmt *stmt = NULL;
    int result;
    char *vendor;
    char *product;
    char *version;
    nvd_report *nvd_report_list = NULL;

    if (sqlite3_prepare_v2(db, vu_queries[GET_DICT_CPE], -1, &stmt, NULL) != SQLITE_OK) {
        wm_vuldet_sql_error(db, stmt);
        return NULL;
    }
    sqlite3_bind_text(stmt, 1, agent_id, -1, NULL);

    while(result = sqlite3_step(stmt), result != SQLITE_DONE) {
        switch (result) {
        case SQLITE_ROW:
            vendor = (char *)sqlite3_column_text(stmt, 0);
            product = (char *)sqlite3_column_text(stmt, 1);
            version = (char *)sqlite3_column_text(stmt, 2);

            //printf("get_vulnerabilites vendor:'%s' product:'%s' version:'%s'\n", vendor, product, "*");
            if (wm_vuldet_get_vuln_nvd_cpe(db, vendor, product, version, &nvd_report_list)) {
                // mterror ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                sqlite3_finalize(stmt);
                return NULL;
            }
            break;
        default:
            printf("Error stmt in sqlite3_step '%d'\n", result);
            wm_vuldet_sql_error(db, stmt);
            return NULL;
        }
    }

    sqlite3_finalize(stmt);
    return nvd_report_list;
}


int wm_vuldet_get_vuln_nvd_cpe(sqlite3 *db, char *vendor, char *product, char *version, nvd_report **nvd_report_list) {
    sqlite3_stmt *stmt = NULL;
    sqlite3_stmt *stmt2 = NULL;
    sqlite3_stmt *stmt3 = NULL;
    int result;
    int result2;
    int result3;
    int nvd_cpe_id;
    int nvd_cve_conf;
    int nvd_cve_id;
    int parent;
    char *uri;
    int vulnerable;
    char *operator;
    char *v_start_inc;
    char *v_start_exc;
    char *v_end_inc;
    char *v_end_exc;
    int retval = OS_INVALID;

    if (sqlite3_prepare_v2(db, vu_queries[GET_NVD_CPE], -1, &stmt, NULL) != SQLITE_OK) {
        return wm_vuldet_sql_error(db, stmt);
    }
    sqlite3_bind_text(stmt, 1, vendor, -1, NULL);
    sqlite3_bind_text(stmt, 2, product, -1, NULL);
    sqlite3_bind_text(stmt, 3, version, -1, NULL);

    while(result = sqlite3_step(stmt), result != SQLITE_DONE) {
        if (result == SQLITE_ROW) {
            nvd_cpe_id = sqlite3_column_int(stmt, 0);
            //printf("GET_NVD_CPE stmt nvd_cpe_id:'%d' vendor:'%s' product:'%s' version:'%s'\n", nvd_cpe_id, vendor, product, version);

            if (stmt2) {
                sqlite3_finalize(stmt2);
            }
            if (sqlite3_prepare_v2(db, vu_queries[GET_NVD_MATCH], -1, &stmt2, NULL) != SQLITE_OK) {
                goto end;
            }
            sqlite3_bind_int(stmt2, 1, nvd_cpe_id);

            while(result2 = sqlite3_step(stmt2), result2 != SQLITE_DONE) {
                if (result == SQLITE_ROW) {
                    nvd_cve_conf = sqlite3_column_int(stmt2, 0);
                    uri = (char *)sqlite3_column_text(stmt2, 1);
                    vulnerable = sqlite3_column_int(stmt2, 2);
                    v_start_inc = (char *)sqlite3_column_text(stmt2, 3);
                    v_start_exc = (char *)sqlite3_column_text(stmt2, 4);
                    v_end_inc = (char *)sqlite3_column_text(stmt2, 5);
                    v_end_exc = (char *)sqlite3_column_text(stmt2, 6);
                    //printf("GET_NVD_MATCH stmt nvd_cve_conf:'%d' vendor:'%s' product:'%s' version:'%s' uri:'%s'\n", nvd_cve_conf, vendor, product, version, uri);

                    if (stmt3) {
                        sqlite3_finalize(stmt3);
                    }

                    if (sqlite3_prepare_v2(db, vu_queries[GET_CONF], -1, &stmt3, NULL) != SQLITE_OK) {
                        goto end;
                    }
                    sqlite3_bind_int(stmt3, 1, nvd_cve_conf);

                    while(result3 = sqlite3_step(stmt3), result3 != SQLITE_DONE) {
                        if (result == SQLITE_ROW) {
                            nvd_report *nvd_report_node;

                            nvd_cve_id = sqlite3_column_int(stmt3, 0);
                            operator = (char *)sqlite3_column_text(stmt3, 1);
                            parent = sqlite3_column_int(stmt3, 2);
                            if (nvd_report_node = wm_vuldet_check_nvd_vulnerability(vulnerable, operator, version, v_start_inc,
                                v_start_exc, v_end_inc, v_end_exc), nvd_report_node) {
                                if (*nvd_report_list) {
                                    nvd_report_node->prev = *nvd_report_list;
                                }
                                *nvd_report_list = nvd_report_node;
                            }

                            printf("GET_CONF vendor:'%s' product:'%s' version:'%s' operator:'%s uri:'%s' vulnerable:'%d' vsi:'%s' vse:'%s' vei:'%s' vee:'%s' parent:'%d' nvd_cve_id:'%d'\n", vendor, product, version, operator, uri, vulnerable, v_start_inc, v_start_exc, v_end_inc, v_end_exc, parent, nvd_cve_id);
                        } else {
                            goto end;
                        }
                    }
                } else {
                    goto end;
                }
            }
        } else {
            goto end;
        }
    }

    retval = 0;
end:
    if (stmt) {
        sqlite3_finalize(stmt);
    }
    if (stmt2) {
        sqlite3_finalize(stmt2);
    }
    if (stmt3) {
        sqlite3_finalize(stmt3);
    }
    if (retval) {
        wm_vuldet_sql_error(db, NULL);
    }
    return retval;
}

nvd_report *wm_vuldet_check_nvd_vulnerability(int vulnerable, char *operator, char *version, char *v_start_inc, char *v_start_exc, char *v_end_inc, char *v_end_exc) {
    static const char *VU_TAG_AND = "AND";
    static const char *VU_TAG_AST = "*";
    nvd_report *nvd_report_node = NULL;

    if (vulnerable || !strcmp(operator, VU_TAG_AND)) {
        // debug 2 message ~~~~~~~~~~~~~~
        return nvd_report_node;
    }

    os_calloc(1, sizeof(nvd_report), nvd_report_node);
    nvd_report_node->vulnerable = vulnerable;
    w_strdup(operator, nvd_report_node->operator);
    w_strdup(version, nvd_report_node->version);
    w_strdup(v_start_inc, nvd_report_node->v_start_inc);
    w_strdup(v_start_exc, nvd_report_node->v_start_exc);
    w_strdup(v_end_inc, nvd_report_node->v_end_inc);
    w_strdup(v_end_exc, nvd_report_node->v_end_exc);
    if (!v_start_inc && !v_start_exc && !v_end_inc && !v_end_exc) {
        if (!strcmp(version, VU_TAG_AST)) {
            // Pending
            nvd_report_node->pending = 1;
        } else {
            nvd_report_node->vulnerable = 1;
        }
    } else {
        vu_logic s_inc = v_start_inc ? wm_checks_package_vulnerability(version, vu_package_comp[VU_COMP_GE], v_start_inc) : VU_UNDEFINED;
        vu_logic s_exc = v_start_exc ? wm_checks_package_vulnerability(version, vu_package_comp[VU_COMP_G], v_start_exc) : VU_UNDEFINED;
        vu_logic e_inc = v_end_inc ? wm_checks_package_vulnerability(version, vu_package_comp[VU_COMP_LE], v_end_inc) : VU_UNDEFINED;
        vu_logic e_exc = v_end_exc ? wm_checks_package_vulnerability(version, vu_package_comp[VU_COMP_L], v_end_exc) : VU_UNDEFINED;;

        if ((s_inc == VU_UNDEFINED || s_inc == VU_VULNERABLE) &&
            (s_exc == VU_UNDEFINED || s_exc == VU_VULNERABLE) &&
            (e_inc == VU_UNDEFINED || e_inc == VU_VULNERABLE) &&
            (e_exc == VU_UNDEFINED || e_exc == VU_VULNERABLE)) {
            nvd_report_node->vulnerable = 1;
        }
    }

    return nvd_report_node;
}
