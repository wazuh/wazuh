/*
 * Vulnerability detector: Debian EVR version matching functions
 * Piece of code extracted from Debian source code
 * Copyright (C) 2015-2020, Wazuh Inc.
 * February 20th, 2020.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "../wmodules.h"
#include "wm_vuln_detector_evr.h"

#ifndef WIN32

#undef S
#define S C_CTYPE_SPACE
#undef W
#define W C_CTYPE_WHITE
#undef B
#define B C_CTYPE_BLANK
#undef U
#define U C_CTYPE_UPPER
#undef L
#define L C_CTYPE_LOWER
#undef D
#define D C_CTYPE_DIGIT

static unsigned short int c_ctype[256] = {
/** 0 **/
    /* \0 */ 0,
    0,
    0,
    0,
    0,
    0,
    0,
    /* \a */ 0,
    /* \b */ 0,
    /* \t */ S | W | B,
    /* \n */ S | W,
    /* \v */ S,
    /* \f */ S,
    /* \r */ S,
    0,
    0,
/** 16 **/
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
/** 32 **/
    /*   */ S | W | B,
    /* ! */ 0,
    /* " */ 0,
    /* # */ 0,
    /* $ */ 0,
    /* % */ 0,
    /* & */ 0,
    /* ' */ 0,
    /* ( */ 0,
    /* ) */ 0,
    /* * */ 0,
    /* + */ 0,
    /* , */ 0,
    /* - */ 0,
    /* . */ 0,
    /* / */ 0,
/** 48 **/
    /* 0 */ D,
    /* 1 */ D,
    /* 2 */ D,
    /* 3 */ D,
    /* 4 */ D,
    /* 5 */ D,
    /* 6 */ D,
    /* 7 */ D,
    /* 8 */ D,
    /* 9 */ D,
    /* : */ 0,
    /* ; */ 0,
    /* < */ 0,
    /* = */ 0,
    /* > */ 0,
    /* ? */ 0,
/* 64 */
    /* @ */ 0,
    /* A */ U,
    /* B */ U,
    /* C */ U,
    /* D */ U,
    /* E */ U,
    /* F */ U,
    /* G */ U,
    /* H */ U,
    /* I */ U,
    /* J */ U,
    /* K */ U,
    /* L */ U,
    /* M */ U,
    /* N */ U,
    /* O */ U,
/* 80 */
    /* P */ U,
    /* Q */ U,
    /* R */ U,
    /* S */ U,
    /* T */ U,
    /* U */ U,
    /* V */ U,
    /* W */ U,
    /* X */ U,
    /* Y */ U,
    /* Z */ U,
    /* [ */ 0,
    /* \ */ 0,
    /* ] */ 0,
    /* ^ */ 0,
    /* _ */ 0,
/* 96 */
    /* ` */ 0,
    /* a */ L,
    /* b */ L,
    /* c */ L,
    /* d */ L,
    /* e */ L,
    /* f */ L,
    /* g */ L,
    /* h */ L,
    /* i */ L,
    /* j */ L,
    /* k */ L,
    /* l */ L,
    /* m */ L,
    /* n */ L,
    /* o */ L,
/* 112 */
    /* p */ L,
    /* q */ L,
    /* r */ L,
    /* s */ L,
    /* t */ L,
    /* u */ L,
    /* v */ L,
    /* w */ L,
    /* x */ L,
    /* y */ L,
    /* z */ L,
    /* { */ 0,
    /* | */ 0,
    /* } */ 0,
    /* ~ */ 0,
    0,
/* 128 */
};

/**
 * Check if the character is bits ctype.
 */
bool c_isbits(int c, enum c_ctype_bit bits)
{
    return ((c_ctype[(unsigned char)c] & bits) != 0);
}
/**
 * Check if the character is [0-9].
 */
bool c_isdigit(int c)
{
    return c_isbits(c, C_CTYPE_DIGIT);
}

/**
 * Check if the character is [a-zA-Z].
 */
bool c_isalpha(int c)
{
    return c_isbits(c, C_CTYPE_ALPHA);
}
/**
 * Give a weight to the character to order in the version comparison.
 *
 * @param c An ASCII character.
 */
static int order(int c)
{
    if (c_isdigit(c))
        return 0;
    else if (c_isalpha(c))
        return c;
    else if (c == '~')
        return -1;
    else if (c)
        return c + 256;
    else
        return 0;
}

static int verrevcmp(const char *a, const char *b)
{
    if (a == NULL)
        a = "";
    if (b == NULL)
        b = "";

    while (*a || *b) {
        int first_diff = 0;

        while ((*a && !c_isdigit(*a)) || (*b && !c_isdigit(*b))) {
            int ac = order(*a);
            int bc = order(*b);

            if (ac != bc)
                return ac - bc;

            a++;
            b++;
        }
        while (*a == '0')
            a++;
        while (*b == '0')
            b++;
        while (c_isdigit(*a) && c_isdigit(*b)) {
            if (!first_diff)
                first_diff = *a - *b;
            a++;
            b++;
        }

        if (c_isdigit(*a))
            return 1;
        if (c_isdigit(*b))
            return -1;
        if (first_diff)
            return first_diff;
    }

    return 0;
}

/**
 * Compares two Debian versions. Extracted from Debian source code.
 *
 * This function follows the convention of the comparator functions used by
 * qsort().
 *
 *
 * @param a The first version.
 * @param b The second version.
 *
 * @retval 0 If a and b are equal.
 * @retval <0 If a is smaller than b.
 * @retval >0 If a is greater than b.
 */
int dpkg_version_compare(const struct dpkg_version *a, const struct dpkg_version *b)
{
    int rc;

    if (a->epoch > b->epoch)
        return 1;
    if (a->epoch < b->epoch)
        return -1;

    rc = verrevcmp(a->version, b->version);
    if (rc)
        return rc;

    return verrevcmp(a->revision, b->revision);
}

/**
 * Debian EVR string comparator. Extracted from Debian source code.
 * Check if two versions have a certain relation.
 *
 * @param a The first version.
 * @param rel The relation.
 * @param b The second version.
 *
 * @retval 1 If the expression “a rel b” is true.
 * @retval 1 If rel is #DPKG_RELATION_NONE.
 * @retval 0 Otherwise.
 *
 */
bool dpkg_version_relate(const struct dpkg_version *a, enum dpkg_relation rel, const struct dpkg_version *b)
{
    int rc;

    if (rel == DPKG_RELATION_NONE)
        return true;

    rc = dpkg_version_compare(a, b);

    switch (rel) {
    case DPKG_RELATION_EQ:
        return rc == 0;
    case DPKG_RELATION_LT:
        return rc < 0;
    case DPKG_RELATION_LE:
        return rc <= 0;
    case DPKG_RELATION_GT:
        return rc > 0;
    case DPKG_RELATION_GE:
        return rc >= 0;
    default:
        merror("unknown dpkg_relation %d", rel);
    }
    return false;
}

#endif
