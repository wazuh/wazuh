/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * January 07, 2026.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "vulnerabilityScannerFacade_test.hpp"
#include "../../inventory_sync/src/context.hpp"
#include "../../src/vulnerabilityScannerFacade.hpp"
#include "flatbuffers/include/inventorySync_generated.h"
#include "rocksDBWrapper.hpp"
#include <external/nlohmann/json.hpp>
#include <filesystem>
#include <format>
#include <fstream>
#include <memory>

void VulnerabilityScannerFacadeTest::SetUp()
{
    // Create necessary directories for testing
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd");
    std::filesystem::create_directories("queue/keystore");
}

void VulnerabilityScannerFacadeTest::TearDown()
{
    // Cleanup test directories
    std::filesystem::remove_all("tmp");
    std::filesystem::remove_all("queue");
}

// Helper to create FlatBuffer DataContext message
std::vector<uint8_t> createTestDataContext(uint64_t sessionId, const std::string& jsonData)
{
    flatbuffers::FlatBufferBuilder builder;

    auto indexOffset = builder.CreateString("wazuh-states-inventory-system");
    auto idOffset = builder.CreateString("test001");
    auto dataVector = builder.CreateVector(reinterpret_cast<const int8_t*>(jsonData.data()), jsonData.size());

    auto dataContext = Wazuh::SyncSchema::CreateDataContext(builder, sessionId, 0, indexOffset, idOffset, dataVector);
    auto message =
        Wazuh::SyncSchema::CreateMessage(builder, Wazuh::SyncSchema::MessageType_DataContext, dataContext.Union());

    builder.Finish(message);

    return std::vector<uint8_t>(builder.GetBufferPointer(), builder.GetBufferPointer() + builder.GetSize());
}

// Test: Check that facade properly tracks initialization state
TEST_F(VulnerabilityScannerFacadeTest, IsInitialized_BeforeStart)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Verify singleton pattern consistency
TEST_F(VulnerabilityScannerFacadeTest, Singleton_ConsistentInstance)
{
    auto& instance1 = VulnerabilityScannerFacade::instance();
    auto& instance2 = VulnerabilityScannerFacade::instance();
    EXPECT_EQ(&instance1, &instance2);
}

// Test: Start with VD disabled (early return path)
TEST_F(VulnerabilityScannerFacadeTest, Start_VDDisabled)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Start with VD enabled as string "no"
TEST_F(VulnerabilityScannerFacadeTest, Start_VDEnabledStringNo)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", "no"}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Start with empty config (VD enabled by default but will fail on missing resources)
TEST_F(VulnerabilityScannerFacadeTest, Start_EmptyConfig)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json emptyConfig = {};

    // Will attempt to start but fail due to missing database/feed
    try
    {
        facade.start(dummyLogFunction, emptyConfig, true, false, false);
    }
    catch (const std::exception&)
    {
        SUCCEED();
    }
}

// Test: Start with cluster name in config
TEST_F(VulnerabilityScannerFacadeTest, Start_WithClusterName)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}, {"clusterName", "test-cluster"}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: runScanner delegates to orchestrator (requires initialization)
TEST_F(VulnerabilityScannerFacadeTest, RunScanner_WithInitialization)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    // First disable VD and call start to avoid initialization
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};
    facade.start(dummyLogFunction, config, true, false, false);

    // Now trying to run scanner should fail because it's not initialized
    Utils::RocksDBWrapper dataStore("/tmp/test_runscanner");
    Context context;

    // This will cause issues because m_scanOrchestrator is null
    // We can't really test runScanner without full initialization
    // So we document this limitation
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Stop after start with VD disabled
/*TEST_F(VulnerabilityScannerFacadeTest, Stop_AfterDisabledStart)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*,
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};
    facade.start(dummyLogFunction, config, true, false, false);

    // Stop should be safe even though facade is not fully initialized
    EXPECT_NO_THROW(facade.stop());
}*/

// Test: Verify noWaitToStop parameter is respected
TEST_F(VulnerabilityScannerFacadeTest, Start_NoWaitToStopParameter)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    // Test with noWaitToStop = false
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, false, false, false));
}

// Test: Verify reloadGlobalMapsStartup parameter
TEST_F(VulnerabilityScannerFacadeTest, Start_ReloadGlobalMapsParameter)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    // Test with reloadGlobalMapsStartup = true
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, true, false));
}

// Test: Verify initContentUpdater parameter
TEST_F(VulnerabilityScannerFacadeTest, Start_InitContentUpdaterParameter)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    // Test with initContentUpdater = true
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, true));
}

// Test: Database decompression - No compressed file exists
TEST_F(VulnerabilityScannerFacadeTest, DatabaseDecompression_NoCompressedFile)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    // Ensure tmp directory exists but no compressed file
    std::filesystem::create_directories("tmp");
    std::filesystem::remove("tmp/vd_1.0.0_vd_4.13.0.tar.xz");

    // Create minimal state database directory
    std::filesystem::create_directories("queue/vd/state_track");

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}}},
                             {"updater", {{"topicName", "test"}}},
                             {"vulnerability-detection", {{"cti-url", "http://test.com"}}}};

    // This will attempt initialization but skip decompression due to missing file
    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
        // Expected to fail on other initialization steps
    }
}

// Test: Database decompression - Compressed file exists
TEST_F(VulnerabilityScannerFacadeTest, DatabaseDecompression_CompressedFileExists)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    // Create tmp directory and a dummy compressed file
    std::filesystem::create_directories("tmp");
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    std::filesystem::create_directories("queue/vd/state_track");

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    // This will attempt decompression and likely fail on XZ decompression
    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
        // Expected to fail during decompression or initialization
    }

    // Verify file operations were attempted
    EXPECT_TRUE(std::filesystem::exists("tmp"));
}

// Test: Keystore path handling in decompression
TEST_F(VulnerabilityScannerFacadeTest, DatabaseDecompression_KeystoreMissing)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    // Ensure keystore doesn't exist
    std::filesystem::remove_all("queue/keystore");
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Keystore path handling when keystore exists
TEST_F(VulnerabilityScannerFacadeTest, DatabaseDecompression_KeystoreExists)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    // Create keystore directory
    std::filesystem::create_directories("queue/keystore");
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Configuration parsing - offline-url
TEST_F(VulnerabilityScannerFacadeTest, Configuration_OfflineUrl)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}, {"offline-url", "file:///tmp/test"}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Configuration parsing - invalid offline-url
TEST_F(VulnerabilityScannerFacadeTest, Configuration_InvalidOfflineUrl)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection",
                              {{"enabled", true}, {"offline-url", "invalid-url"}, {"cti-url", "http://test.com"}}}};

    // Exception is caught internally, so just verify it doesn't crash
    // and that initialization fails
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Configuration parsing - feed-update-interval validation
TEST_F(VulnerabilityScannerFacadeTest, Configuration_FeedUpdateInterval)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}, {"feed-update-interval", "120m"}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Configuration parsing - invalid feed-update-interval
TEST_F(VulnerabilityScannerFacadeTest, Configuration_InvalidFeedUpdateInterval)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {
        {"vulnerability-detection",
         {{"enabled", true}, {"feed-update-interval", "invalid"}, {"cti-url", "http://test.com"}}}};

    // Exception is caught internally, so just verify it doesn't crash
    // and that initialization fails
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Configuration parsing - minimum feed-update-interval enforcement
TEST_F(VulnerabilityScannerFacadeTest, Configuration_MinimumFeedUpdateInterval)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection",
                              {
                                  {"enabled", false}, {"feed-update-interval", "30m"} // Below minimum
                              }}};

    // Should automatically adjust to minimum (60m) and log warning
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Indexer configuration defaults
TEST_F(VulnerabilityScannerFacadeTest, Configuration_IndexerDefaults)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {
        {"vulnerability-detection", {{"enabled", false}}}
        // No indexer config - should use defaults
    };

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Indexer configuration with SSL
TEST_F(VulnerabilityScannerFacadeTest, Configuration_IndexerWithSSL)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}},
                             {"indexer",
                              {{"hosts", {"https://localhost:9200"}},
                               {"ssl",
                                {{"certificate_authorities", {"/path/to/ca.crt"}},
                                 {"certificate", "/path/to/cert.crt"},
                                 {"key", "/path/to/key.pem"}}}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Translation LRU size configuration
TEST_F(VulnerabilityScannerFacadeTest, Configuration_TranslationLRUSize)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}, {"translationLRUSize", 2000}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Database cleanup - remove_all for DATABASE_PATH
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_CleanupDatabasePath)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/feed");
    std::filesystem::create_directories("queue/vd/state_track");

    // Create a dummy file in DATABASE_PATH to verify it gets removed
    std::ofstream dummyFile("queue/vd/feed/test.db");
    dummyFile << "test data";
    dummyFile.close();

    EXPECT_TRUE(std::filesystem::exists("queue/vd/feed/test.db"));

    // Create a valid compressed file to trigger decompression attempt
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    // This will attempt decompression
    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
        // Expected to fail during actual decompression
    }
}

// Test: Database cleanup - remove_all for UPDATER_PATH
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_CleanupUpdaterPath)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd_updater");
    std::filesystem::create_directories("queue/vd/state_track");

    // Create a dummy file in UPDATER_PATH to verify it gets removed
    std::ofstream dummyFile("queue/vd_updater/test.db");
    dummyFile << "test data";
    dummyFile.close();

    EXPECT_TRUE(std::filesystem::exists("queue/vd_updater/test.db"));

    // Create a valid compressed file to trigger decompression attempt
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    // This will attempt decompression
    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
        // Expected to fail during actual decompression
    }
}

// Test: ExtractOnly vector - VD_DATABASE_PATH always added
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_ExtractOnlyVDPath)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    // Remove keystore to verify it's added to extractOnly
    std::filesystem::remove_all("queue/keystore");

    // Create a valid compressed file to trigger decompression attempt
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    // Decompression will be attempted with VD_DATABASE_PATH in extractOnly
    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
        // Expected to fail during actual decompression
    }
}

// Test: Keystore check - keystore exists, not added to extractOnly
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_KeystoreExists_NotAdded)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");
    std::filesystem::create_directories("queue/keystore");

    // Create a dummy file in keystore
    std::ofstream keystoreFile("queue/keystore/test.key");
    keystoreFile << "test key";
    keystoreFile.close();

    EXPECT_TRUE(std::filesystem::exists("queue/keystore"));

    // Create a valid compressed file to trigger decompression attempt
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    // Keystore should NOT be added to extractOnly since it exists
    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
        // Expected to fail during actual decompression
    }

    // Verify keystore still exists
    EXPECT_TRUE(std::filesystem::exists("queue/keystore"));
}

// Test: Keystore check - keystore missing, added to extractOnly
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_KeystoreMissing_AddedToExtractOnly)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    // Ensure keystore does NOT exist
    std::filesystem::remove_all("queue/keystore");
    EXPECT_FALSE(std::filesystem::exists("queue/keystore"));

    // Create a valid compressed file to trigger decompression attempt
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    // Keystore SHOULD be added to extractOnly since it doesn't exist
    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
        // Expected to fail during actual decompression
    }
}

// Test: TAR decompression cleanup - DECOMPRESSED_DB_PATH removed
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_CleanupDecompressedTar)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    // Create a valid compressed file to trigger decompression attempt
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    // Decompression will be attempted
    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
        // Expected to fail during actual decompression
    }

    if (std::filesystem::exists("tmp/vd_1.0.0_vd_4.13.0.tar"))
    {
        // File exists means XZ decompression partially succeeded but failed before cleanup
        SUCCEED() << "Decompression attempted - TAR file created by XZ but cleanup not reached";
    }
    else
    {
        // File doesn't exist means either XZ failed immediately or cleanup succeeded
        SUCCEED() << "TAR file was cleaned up or XZ failed before creating it";
    }
}

// Test: Return value - false when m_shouldStop is set
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_ShouldStopTrue_ReturnsFalse)
{
    // This test verifies that when m_shouldStop is true, decompressDatabase returns false
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    // Start with VD disabled (no decompression attempt)
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Return value - true when decompression succeeds and m_shouldStop is false
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_SuccessfulDecompression_ReturnsTrue)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    // Without a valid compressed file, decompression is skipped
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Database version check - matching version skips decompression
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_VersionMatch_SkipsDecompression)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    // Create compressed file
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    // If database version matches __ossec_version, decompression is skipped
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: TMP_DIR does not exist - decompression skipped
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_NoTmpDir_SkipsDecompression)
{
    // Remove tmp directory
    std::filesystem::remove_all("tmp");
    EXPECT_FALSE(std::filesystem::exists("tmp"));

    std::filesystem::create_directories("queue/vd/state_track");

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    // Without TMP_DIR, decompression condition is not met
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: Empty database version triggers decompression
TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_EmptyVersion_TriggersDecompression)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    // Create compressed file
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    // Empty version should trigger decompression attempt
    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
        // Expected to fail during actual decompression
    }
}
