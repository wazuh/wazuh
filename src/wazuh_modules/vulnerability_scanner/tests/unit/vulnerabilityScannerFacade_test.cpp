/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * January 07, 2026.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "vulnerabilityScannerFacade_test.hpp"
#include "../../inventory_sync/src/context.hpp"
#include "../../src/vulnerabilityScannerFacade.hpp"
#include "flatbuffers/include/inventorySync_generated.h"
#include "rocksDBWrapper.hpp"
#include <external/nlohmann/json.hpp>
#include <filesystem>
#include <format>
#include <fstream>
#include <memory>

void VulnerabilityScannerFacadeTest::SetUp()
{
    // Create necessary directories for testing
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd");
    std::filesystem::create_directories("queue/keystore");
}

void VulnerabilityScannerFacadeTest::TearDown()
{
    // Cleanup test directories
    std::filesystem::remove_all("tmp");
    std::filesystem::remove_all("queue");
}

// Helper to create FlatBuffer DataContext message
std::vector<uint8_t> createTestDataContext(uint64_t sessionId, const std::string& jsonData)
{
    flatbuffers::FlatBufferBuilder builder;
    
    auto indexOffset = builder.CreateString("wazuh-states-inventory-system");
    auto idOffset = builder.CreateString("test001");
    auto dataVector = builder.CreateVector(reinterpret_cast<const int8_t*>(jsonData.data()), jsonData.size());
    
    auto dataContext = Wazuh::SyncSchema::CreateDataContext(
        builder, sessionId, 0, indexOffset, idOffset, dataVector);
    auto message = Wazuh::SyncSchema::CreateMessage(
        builder, Wazuh::SyncSchema::MessageType_DataContext, dataContext.Union());
    
    builder.Finish(message);
    
    return std::vector<uint8_t>(builder.GetBufferPointer(), 
                                builder.GetBufferPointer() + builder.GetSize());
}

// Test: Check that facade properly tracks initialization state
TEST_F(VulnerabilityScannerFacadeTest, IsInitialized_BeforeStart)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Verify singleton pattern consistency
TEST_F(VulnerabilityScannerFacadeTest, Singleton_ConsistentInstance)
{
    auto& instance1 = VulnerabilityScannerFacade::instance();
    auto& instance2 = VulnerabilityScannerFacade::instance();
    EXPECT_EQ(&instance1, &instance2);
}

// Test: Start with VD disabled (early return path)
TEST_F(VulnerabilityScannerFacadeTest, Start_VDDisabled)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};
    
    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};
    
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Start with VD enabled as string "no"
TEST_F(VulnerabilityScannerFacadeTest, Start_VDEnabledStringNo)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};
    
    nlohmann::json config = {{"vulnerability-detection", {{"enabled", "no"}}}};
    
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Start with empty config (VD enabled by default but will fail on missing resources)
TEST_F(VulnerabilityScannerFacadeTest, Start_EmptyConfig)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};
    
    nlohmann::json emptyConfig = {};
    
    // Will attempt to start but fail due to missing database/feed
    try {
        facade.start(dummyLogFunction, emptyConfig, true, false, false);
    } catch (const std::exception&) {
        SUCCEED();
    }
}

// Test: Start with cluster name in config
TEST_F(VulnerabilityScannerFacadeTest, Start_WithClusterName)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};
    
    nlohmann::json config = {
        {"vulnerability-detection", {{"enabled", false}}},
        {"clusterName", "test-cluster"}
    };
    
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

// Test: runScanner delegates to orchestrator (requires initialization)
TEST_F(VulnerabilityScannerFacadeTest, RunScanner_WithInitialization)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    
    // First disable VD and call start to avoid initialization
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};
    
    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};
    facade.start(dummyLogFunction, config, true, false, false);
    
    // Now trying to run scanner should fail because it's not initialized
    Utils::RocksDBWrapper dataStore("/tmp/test_runscanner");
    Context context;
    
    // This will cause issues because m_scanOrchestrator is null
    // We can't really test runScanner without full initialization
    // So we document this limitation
    EXPECT_FALSE(facade.isInitialized());
}

// Test: Stop after start with VD disabled
/*TEST_F(VulnerabilityScannerFacadeTest, Stop_AfterDisabledStart)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};
    
    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};
    facade.start(dummyLogFunction, config, true, false, false);
    
    // Stop should be safe even though facade is not fully initialized
    EXPECT_NO_THROW(facade.stop());
}*/

// Test: Verify noWaitToStop parameter is respected
TEST_F(VulnerabilityScannerFacadeTest, Start_NoWaitToStopParameter)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};
    
    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};
    
    // Test with noWaitToStop = false
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, false, false, false));
}

// Test: Verify reloadGlobalMapsStartup parameter
TEST_F(VulnerabilityScannerFacadeTest, Start_ReloadGlobalMapsParameter)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};
    
    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};
    
    // Test with reloadGlobalMapsStartup = true
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, true, false));
}

// Test: Verify initContentUpdater parameter
TEST_F(VulnerabilityScannerFacadeTest, Start_InitContentUpdaterParameter)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    
    auto dummyLogFunction = [](const int, const char*, const char*, 
                               const int, const char*, const char*, va_list) {};
    
    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};
    
    // Test with initContentUpdater = true
    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, true));
}
