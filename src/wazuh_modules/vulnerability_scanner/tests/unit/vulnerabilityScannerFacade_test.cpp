/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * January 07, 2026.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "vulnerabilityScannerFacade_test.hpp"
#include "../../inventory_sync/src/context.hpp"
#include "../../src/vulnerabilityScannerFacade.hpp"
#include "flatbuffers/include/inventorySync_generated.h"
#include "rocksDBWrapper.hpp"
#include <external/nlohmann/json.hpp>
#include <filesystem>
#include <format>
#include <fstream>
#include <memory>

void VulnerabilityScannerFacadeTest::SetUp()
{
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd");
    std::filesystem::create_directories("queue/keystore");
}

void VulnerabilityScannerFacadeTest::TearDown()
{
    std::filesystem::remove_all("tmp");
    std::filesystem::remove_all("queue");
}

// Helper to create FlatBuffer DataContext message
std::vector<uint8_t> createTestDataContext(uint64_t sessionId, const std::string& jsonData)
{
    flatbuffers::FlatBufferBuilder builder;

    auto indexOffset = builder.CreateString("wazuh-states-inventory-system");
    auto idOffset = builder.CreateString("test001");
    auto dataVector = builder.CreateVector(reinterpret_cast<const int8_t*>(jsonData.data()), jsonData.size());

    auto dataContext = Wazuh::SyncSchema::CreateDataContext(builder, sessionId, 0, indexOffset, idOffset, dataVector);
    auto message =
        Wazuh::SyncSchema::CreateMessage(builder, Wazuh::SyncSchema::MessageType_DataContext, dataContext.Union());

    builder.Finish(message);

    return std::vector<uint8_t>(builder.GetBufferPointer(), builder.GetBufferPointer() + builder.GetSize());
}

TEST_F(VulnerabilityScannerFacadeTest, IsInitialized_BeforeStart)
{
    auto& facade = VulnerabilityScannerFacade::instance();
    EXPECT_FALSE(facade.isInitialized());
}

TEST_F(VulnerabilityScannerFacadeTest, Singleton_ConsistentInstance)
{
    auto& instance1 = VulnerabilityScannerFacade::instance();
    auto& instance2 = VulnerabilityScannerFacade::instance();
    EXPECT_EQ(&instance1, &instance2);
}

TEST_F(VulnerabilityScannerFacadeTest, Start_VDDisabled)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

TEST_F(VulnerabilityScannerFacadeTest, Start_VDEnabledStringNo)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", "no"}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

TEST_F(VulnerabilityScannerFacadeTest, Start_WithClusterName)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}, {"clusterName", "test-cluster"}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, Start_NoWaitToStopParameter)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, false, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, Start_ReloadGlobalMapsParameter)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, true, false));
}

TEST_F(VulnerabilityScannerFacadeTest, Start_InitContentUpdaterParameter)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, true));
}

TEST_F(VulnerabilityScannerFacadeTest, DatabaseDecompression_NoCompressedFile)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    std::filesystem::create_directories("tmp");
    std::filesystem::remove("tmp/vd_1.0.0_vd_4.13.0.tar.xz");

    std::filesystem::create_directories("queue/vd/state_track");

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}}},
                             {"updater", {{"topicName", "test"}}},
                             {"vulnerability-detection", {{"cti-url", "http://test.com"}}}};

    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
    }
}

TEST_F(VulnerabilityScannerFacadeTest, DatabaseDecompression_CompressedFileExists)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    std::filesystem::create_directories("tmp");
    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    std::filesystem::create_directories("queue/vd/state_track");

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
    }

    EXPECT_TRUE(std::filesystem::exists("tmp"));
}

TEST_F(VulnerabilityScannerFacadeTest, DatabaseDecompression_KeystoreMissing)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    std::filesystem::remove_all("queue/keystore");
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, DatabaseDecompression_KeystoreExists)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    std::filesystem::create_directories("queue/keystore");
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, Configuration_OfflineUrl)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}, {"offline-url", "file:///tmp/test"}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, Configuration_InvalidOfflineUrl)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection",
                              {{"enabled", true}, {"offline-url", "invalid-url"}, {"cti-url", "http://test.com"}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

TEST_F(VulnerabilityScannerFacadeTest, Configuration_FeedUpdateInterval)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}, {"feed-update-interval", "120m"}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, Configuration_InvalidFeedUpdateInterval)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {
        {"vulnerability-detection",
         {{"enabled", true}, {"feed-update-interval", "invalid"}, {"cti-url", "http://test.com"}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
    EXPECT_FALSE(facade.isInitialized());
}

TEST_F(VulnerabilityScannerFacadeTest, Configuration_MinimumFeedUpdateInterval)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}, {"feed-update-interval", "30m"}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, Configuration_IndexerDefaults)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, Configuration_IndexerWithSSL)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}},
                             {"indexer",
                              {{"hosts", {"https://localhost:9200"}},
                               {"ssl",
                                {{"certificate_authorities", {"/path/to/ca.crt"}},
                                 {"certificate", "/path/to/cert.crt"},
                                 {"key", "/path/to/key.pem"}}}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, Configuration_TranslationLRUSize)
{
    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}, {"translationLRUSize", 2000}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_CleanupDatabasePath)
{
    // Setup test environment
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/feed");
    std::filesystem::create_directories("queue/vd/state_track");

    std::ofstream dummyFile("queue/vd/feed/test.db");
    dummyFile << "test data";
    dummyFile.close();

    EXPECT_TRUE(std::filesystem::exists("queue/vd/feed/test.db"));

    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
    }
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_CleanupUpdaterPath)
{

    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd_updater");
    std::filesystem::create_directories("queue/vd/state_track");

    std::ofstream dummyFile("queue/vd_updater/test.db");
    dummyFile << "test data";
    dummyFile.close();

    EXPECT_TRUE(std::filesystem::exists("queue/vd_updater/test.db"));

    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
    }
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_ExtractOnlyVDPath)
{
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    std::filesystem::remove_all("queue/keystore");

    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
    }
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_KeystoreExists_NotAdded)
{
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");
    std::filesystem::create_directories("queue/keystore");

    std::ofstream keystoreFile("queue/keystore/test.key");
    keystoreFile << "test key";
    keystoreFile.close();

    EXPECT_TRUE(std::filesystem::exists("queue/keystore"));

    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
    }

    EXPECT_TRUE(std::filesystem::exists("queue/keystore"));
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_KeystoreMissing_AddedToExtractOnly)
{
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    std::filesystem::remove_all("queue/keystore");
    EXPECT_FALSE(std::filesystem::exists("queue/keystore"));

    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
    }
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_CleanupDecompressedTar)
{
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
    }

    if (std::filesystem::exists("tmp/vd_1.0.0_vd_4.13.0.tar"))
    {
        SUCCEED() << "Decompression attempted - TAR file created by XZ but cleanup not reached";
    }
    else
    {
        SUCCEED() << "TAR file was cleaned up or XZ failed before creating it";
    }
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_ShouldStopTrue_ReturnsFalse)
{
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_SuccessfulDecompression_ReturnsTrue)
{
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_VersionMatch_SkipsDecompression)
{
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_NoTmpDir_SkipsDecompression)
{
    std::filesystem::remove_all("tmp");
    EXPECT_FALSE(std::filesystem::exists("tmp"));

    std::filesystem::create_directories("queue/vd/state_track");

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", false}}}};

    EXPECT_NO_THROW(facade.start(dummyLogFunction, config, true, false, false));
}

TEST_F(VulnerabilityScannerFacadeTest, DecompressDatabase_EmptyVersion_TriggersDecompression)
{
    std::filesystem::create_directories("tmp");
    std::filesystem::create_directories("queue/vd/state_track");

    std::ofstream compressedFile("tmp/vd_1.0.0_vd_4.13.0.tar.xz");
    compressedFile << "dummy xz content";
    compressedFile.close();

    auto& facade = VulnerabilityScannerFacade::instance();

    auto dummyLogFunction = [](const int, const char*, const char*, const int, const char*, const char*, va_list) {
    };

    nlohmann::json config = {{"vulnerability-detection", {{"enabled", true}, {"cti-url", "http://test.com"}}}};

    try
    {
        facade.start(dummyLogFunction, config, true, false, false);
    }
    catch (...)
    {
    }
}
