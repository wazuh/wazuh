/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "osScanner_test.hpp"
#include "../mocks/globalMocks.hpp"
#include "context.hpp"
#include "json.hpp"
#include "loggerHelper.h"
#include "vulnerabilityRemediations_generated.h"

/* Test constants */

namespace NSOsScannerTest
{
    const char* INCLUDE_DIRECTORIES[] = {FLATBUFFER_SCHEMAS_DIR, nullptr};
    const std::string CANDIDATES_FLATBUFFER_SCHEMA_PATH {FLATBUFFER_SCHEMAS_DIR "/vulnerabilityCandidate.fbs"};
    const std::string REMEDIATIONS_FLATBUFFER_SCHEMA_PATH {FLATBUFFER_SCHEMAS_DIR "/vulnerabilityRemediations.fbs"};

    const std::string CVE_ID_1 = "CVE-2025-1";
    const std::string CVE_ID_2 = "CVE-2025-2";
    const std::string CVE_ID_3 = "CVE-2025-3";

    const std::string DELTA_OS_INSERT_WINDOWS =
        R"({
            "agent_info": {
                "agent_id": "001",
                "agent_ip": "192.168.33.20",
                "agent_name": "agent"
            },
            "data_type": "dbsync_osinfo",
            "data": {
                "architecture": "x86_64",
                "hostname": "agent",
                "os_build": "7601",
                "os_major": "6",
                "os_minor": "1",
                "os_name": "Microsoft Windows 7",
                "os_release": "sp1",
                "os_version": "6.1.7601",
                "os_platform": "windows"
            },
            "operation": "INSERTED"
            })";

    const std::string DELTA_OS_INSERT_DARWIN =
        R"({
            "agent_info": {
                "agent_id": "002",
                "agent_ip": "192.168.33.21",
                "agent_name": "mac-agent"
            },
            "data_type": "dbsync_osinfo",
            "data": {
                "architecture": "x86_64",
                "hostname": "mac-agent",
                "os_name": "macOS",
                "os_version": "13.0",
                "os_platform": "darwin"
            },
            "operation": "INSERTED"
            })";

    const std::string DELTA_OS_INSERT_LINUX =
        R"({
            "agent_info": {
                "agent_id": "003",
                "agent_ip": "192.168.33.22",
                "agent_name": "linux-agent"
            },
            "data_type": "dbsync_osinfo",
            "data": {
                "architecture": "x86_64",
                "hostname": "linux-agent",
                "os_name": "Ubuntu",
                "os_version": "20.04",
                "os_platform": "linux"
            },
            "operation": "INSERTED"
            })";

    const nlohmann::json OSCPE_GLOBAL =
        R"(
        {
            "Microsoft Windows 7": "microsoft:windows_7:$(RELEASE):::::",
            "macOS": "apple:macos:$(VERSION):::::"
        })"_json;

    const std::string CANDIDATES_AFFECTED_WINDOWS_CVE_ID_1 =
        R"(
            {
                "candidates": [
                    {
                        "cveId": "CVE-2025-1",
                        "defaultStatus": "unaffected",
                        "platforms": [
                            "microsoft:windows_7::::::"
                        ],
                        "versions": [
                            {
                                "status": "affected",
                                "version": "0",
                                "versionType": "custom",
                                "lessThan": "6.1.7777",
                            }
                        ]
                    }
                ]
            }
        )";

    const std::string CANDIDATES_AFFECTED_WINDOWS_CVE_ID_2 =
        R"(
            {
                "candidates": [
                    {
                        "cveId": "CVE-2025-2",
                        "defaultStatus": "unaffected",
                        "platforms": [
                            "microsoft:windows_7::::::"
                        ],
                        "versions": [
                            {
                                "status": "affected",
                                "version": "0",
                                "versionType": "custom",
                                "lessThan": "6.1.7777",
                            }
                        ]
                    }
                ]
            }
        )";

    const std::string CANDIDATES_AFFECTED_DIFFERENT_RANGE_WINDOWS_CVE_ID_1 =
        R"(
            {
                "candidates": [
                    {
                        "cveId": "CVE-2025-1",
                        "defaultStatus": "unaffected",
                        "platforms": [
                            "microsoft:windows_7::::::"
                        ],
                        "versions": [
                            {
                                "status": "affected",
                                "version": "0",
                                "versionType": "custom",
                                "lessThan": "6.0.7777",
                            }
                        ]
                    }
                ]
            }
        )";

    const std::string CANDIDATES_AFFECTED_DARWIN_CVE_ID_3 =
        R"(
            {
                "candidates": [
                    {
                        "cveId": "CVE-2025-3",
                        "defaultStatus": "unaffected",
                        "platforms": [
                            "apple:macos::::::"
                        ],
                        "versions": [
                            {
                                "status": "affected",
                                "version": "0",
                                "versionType": "custom",
                                "lessThan": "14.0",
                            }
                        ]
                    }
                ]
            }
        )";

    const std::string CANDIDATES_DEFAULT_STATUS_AFFECTED =
        R"(
            {
                "candidates": [
                    {
                        "cveId": "CVE-2025-1",
                        "defaultStatus": "affected",
                        "platforms": [
                            "microsoft:windows_7::::::"
                        ],
                        "versions": []
                    }
                ]
            }
        )";

    const std::string CANDIDATES_EQUAL_VERSION =
        R"(
            {
                "candidates": [
                    {
                        "cveId": "CVE-2025-1",
                        "defaultStatus": "unaffected",
                        "platforms": [
                            "microsoft:windows_7::::::"
                        ],
                        "versions": [
                            {
                                "status": "affected",
                                "version": "6.1.7601",
                                "versionType": "custom"
                            }
                        ]
                    }
                ]
            }
        )";

    const std::string CANDIDATES_LESSEQUAL_VERSION =
        R"(
            {
                "candidates": [
                    {
                        "cveId": "CVE-2025-1",
                        "defaultStatus": "unaffected",
                        "platforms": [
                            "microsoft:windows_7::::::"
                        ],
                        "versions": [
                            {
                                "status": "affected",
                                "version": "0",
                                "versionType": "custom",
                                "lessThanOrEqual": "6.1.7601"
                            }
                        ]
                    }
                ]
            }
        )";

    const nlohmann::json HOTFIXES =
        R"(
        [
            {
                "hotfix": "KB123456"
            }
        ])"_json;

    const std::string REMEDIATIONS =
        R"(
        {
            "updates": [
                "KB123456"
            ]
        }
    )";

    const std::string REMEDIATIONS_NOT_INSTALLED =
        R"(
        {
            "updates": [
                "KB123"
            ]
        }
    )";

    const std::string REMEDIATIONS_EMPTY =
        R"(
        {
            "updates": []
        }
    )";

} // namespace NSOsScannerTest
/* SetUp / TearDown */
void OsScannerTest::SetUp()
{
    m_spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    m_spScanContext = std::make_shared<TrampolineScanContext>();
    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    spGlobalDataMock = std::make_shared<MockGlobalData>();
    spSocketDBWrapperMock = std::make_shared<MockSocketDBWrapper>();
}

void OsScannerTest::TearDown()
{
    m_spDatabaseFeedManagerMock.reset();
    m_spScanContext.reset();
    spOsDataCacheMock.reset();
    spGlobalDataMock.reset();
    spSocketDBWrapperMock.reset();
    m_spParser.reset();
    m_spRemediationsParser.reset();
}

/* Helpers */

void OsScannerTest::loadScanContext(std::string deltaMsg)
{
    // Parse the delta message for OS data
    auto jsonDelta = nlohmann::json::parse(deltaMsg);

    // Create a Context from the delta message
    Context ctx;
    ctx.agentId = jsonDelta["agent_info"]["agent_id"].get<std::string>();
    ctx.agentName = jsonDelta["agent_info"]["agent_name"].get<std::string>();
    ctx.agentVersion = "";
    ctx.architecture =
        jsonDelta["data"].contains("architecture") ? jsonDelta["data"]["architecture"].get<std::string>() : "";
    ctx.hostname = jsonDelta["data"].contains("hostname") ? jsonDelta["data"]["hostname"].get<std::string>() : "";
    ctx.osname = jsonDelta["data"]["os_name"].get<std::string>();
    ctx.osplatform = jsonDelta["data"]["os_platform"].get<std::string>();
    ctx.ostype = "";
    ctx.osversion = jsonDelta["data"]["os_version"].get<std::string>();
    ctx.groups = {};

    m_spScanContext = std::make_shared<TrampolineScanContext>(ctx);

    // Set OS data in context to build CPE name
    OsContextData osData;
    osData.name = jsonDelta["data"]["os_name"].get<std::string>();
    osData.version = jsonDelta["data"]["os_version"].get<std::string>();
    osData.platform = jsonDelta["data"]["os_platform"].get<std::string>();
    osData.displayVersion = jsonDelta["data"]["os_version"].get<std::string>();
    m_spScanContext->setOSData(osData);
}

void OsScannerTest::parseRemediations(std::string remediationsStr,
                                      FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediationsFb)
{
    std::string remediationsFlatbufferSchemaStr;
    m_spRemediationsParser = std::make_shared<flatbuffers::Parser>();

    // Read schemas from filesystem.
    bool valid = flatbuffers::LoadFile(
        NSOsScannerTest::REMEDIATIONS_FLATBUFFER_SCHEMA_PATH.c_str(), false, &remediationsFlatbufferSchemaStr);
    ASSERT_EQ(valid, true);

    valid =
        (m_spRemediationsParser->Parse(remediationsFlatbufferSchemaStr.c_str(), NSOsScannerTest::INCLUDE_DIRECTORIES) &&
         m_spRemediationsParser->Parse(remediationsStr.c_str()));
    ASSERT_EQ(valid, true);

    remediationsFb.data =
        GetRemediationInfo(reinterpret_cast<const uint8_t*>(m_spRemediationsParser->builder_.GetBufferPointer()));
}

void OsScannerTest::scanCandidates(
    std::string candidates,
    const std::string& cnaName,
    const PackageData& package,
    const std::function<bool(const std::string& cnaName,
                             const PackageData& package,
                             const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
{
    std::string candidatesFlatbufferSchemaStr;

    // Read schemas from filesystem.
    bool valid = flatbuffers::LoadFile(
        NSOsScannerTest::CANDIDATES_FLATBUFFER_SCHEMA_PATH.c_str(), false, &candidatesFlatbufferSchemaStr);
    ASSERT_EQ(valid, true);

    // Parse schemas and JSON example.
    flatbuffers::Parser fbParser;
    valid = (fbParser.Parse(candidatesFlatbufferSchemaStr.c_str(), NSOsScannerTest::INCLUDE_DIRECTORIES) &&
             fbParser.Parse(candidates.c_str()));
    ASSERT_EQ(valid, true);

    auto candidatesArray =
        GetScanVulnerabilityCandidateArray(reinterpret_cast<const uint8_t*>(fbParser.builder_.GetBufferPointer()));

    if (candidatesArray)
    {
        for (const auto& candidate : *candidatesArray->candidates())
        {
            if (callback(cnaName, package, *candidate))
            {
                break;
            }
        }
    }
}

/* Tests */

/*
 * @brief Test instantiation of the OsScanner class.
 */
TEST_F(OsScannerTest, TestInstantiationOfTheOsScannerClass)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);
}

/*
 * @brief Test handleRequest of the OsScanner class.
 */
TEST_F(OsScannerTest, TestHandleRequest)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    const auto testCandidates = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_1;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS_NOT_INSTALLED, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 1);

    const std::string expectedDetectionId = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    EXPECT_TRUE(detections.find(expectedDetectionId) != detections.end());

    if (detections.find(expectedDetectionId) != detections.end())
    {
        const auto& detection = detections.at(expectedDetectionId);
        EXPECT_EQ(detection.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection.cnaSource, "nvd");
        EXPECT_EQ(detection.matchCondition, "6.1.7777");
        EXPECT_EQ(detection.conditionType, MatchRuleCondition::LessThan);
        EXPECT_EQ(detection.componentType, AffectedComponentType::Os);
    }
}

/*
 * @brief Test handleRequest of the OsScanner class with remediations.
 */
TEST_F(OsScannerTest, TestHandleRequestWithRemediations)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    const auto testCandidates = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_1;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 1);

    const std::string expectedDetectionId = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    EXPECT_TRUE(detections.find(expectedDetectionId) != detections.end());

    if (detections.find(expectedDetectionId) != detections.end())
    {
        const auto& detection = detections.at(expectedDetectionId);
        EXPECT_EQ(detection.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection.cnaSource, "nvd");
    }
}

/*
 * @brief Test cna default array priority with only one CNA.
 */
TEST_F(OsScannerTest, TestCnaArrayPriorityOneCna)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({"adp_default_array":["nvd"]})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    const auto testCandidates = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_1;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS_NOT_INSTALLED, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 1);

    const std::string expectedDetectionId = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    EXPECT_TRUE(detections.find(expectedDetectionId) != detections.end());

    if (detections.find(expectedDetectionId) != detections.end())
    {
        const auto& detection = detections.at(expectedDetectionId);
        EXPECT_EQ(detection.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection.cnaSource, "nvd");
        EXPECT_EQ(detection.matchCondition, "6.1.7777");
        EXPECT_EQ(detection.conditionType, MatchRuleCondition::LessThan);
    }
}

/*
 * @brief Test cna default array priority with the first CNA as priority in the detection.
 */
TEST_F(OsScannerTest, TestCnaArrayPriorityMultipleCnaFirstPriority)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({"adp_default_array":["cisa","nvd"]})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    const auto testCandidatesFirstCna = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_1;

    auto mockGetVulnerabilitiesCandidatesFirstCna =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidatesFirstCna, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("cisa", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidatesFirstCna));

    const auto testCandidates = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_1;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS_NOT_INSTALLED, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 1);

    const std::string expectedDetectionId = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    EXPECT_TRUE(detections.find(expectedDetectionId) != detections.end());

    if (detections.find(expectedDetectionId) != detections.end())
    {
        const auto& detection = detections.at(expectedDetectionId);
        EXPECT_EQ(detection.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection.cnaSource, "cisa");
        EXPECT_EQ(detection.matchCondition, "6.1.7777");
        EXPECT_EQ(detection.conditionType, MatchRuleCondition::LessThan);
    }
}

/*
 * @brief Test cna default array priority with the first CNA as priority in the detection but only detection in the
 * second.
 */
TEST_F(OsScannerTest, TestCnaArrayPriorityMultipleCnaFirstPriorityDetectionSecond)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({"adp_default_array":["cisa","nvd"]})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    // First CNA
    const auto testCandidatesFirstCna = NSOsScannerTest::CANDIDATES_AFFECTED_DIFFERENT_RANGE_WINDOWS_CVE_ID_1;

    auto mockGetVulnerabilitiesCandidatesFirstCna =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidatesFirstCna, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("cisa", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidatesFirstCna));

    // Second CNA
    const auto testCandidates = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_1;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    // Remediations

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS_NOT_INSTALLED, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 1);

    const std::string expectedDetectionId = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    EXPECT_TRUE(detections.find(expectedDetectionId) != detections.end());

    if (detections.find(expectedDetectionId) != detections.end())
    {
        const auto& detection = detections.at(expectedDetectionId);
        EXPECT_EQ(detection.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection.cnaSource, "nvd");
        EXPECT_EQ(detection.matchCondition, "6.1.7777");
        EXPECT_EQ(detection.conditionType, MatchRuleCondition::LessThan);
    }
}

/*
 * @brief Test cna default array priority with detections in both CNAs.
 */
TEST_F(OsScannerTest, TestCnaArrayPriorityMultipleCnaDetectionBoth)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({"adp_default_array":["cisa","nvd"]})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    // First CNA
    const auto testCandidatesFirstCna = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_2;

    auto mockGetVulnerabilitiesCandidatesFirstCna =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidatesFirstCna, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("cisa", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidatesFirstCna));

    // Second CNA
    const auto testCandidates = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_1;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    // Remediations

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS_NOT_INSTALLED, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_2, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 2);

    const std::string detectionId1 = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    const std::string detectionId2 = "001_Microsoft Windows 7_6.1.7601_CVE-2025-2";

    EXPECT_TRUE(detections.find(detectionId1) != detections.end());
    EXPECT_TRUE(detections.find(detectionId2) != detections.end());

    if (detections.find(detectionId1) != detections.end())
    {
        const auto& detection1 = detections.at(detectionId1);
        EXPECT_EQ(detection1.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection1.cnaSource, "nvd");
        EXPECT_EQ(detection1.matchCondition, "6.1.7777");
        EXPECT_EQ(detection1.conditionType, MatchRuleCondition::LessThan);
    }

    if (detections.find(detectionId2) != detections.end())
    {
        const auto& detection2 = detections.at(detectionId2);
        EXPECT_EQ(detection2.cveId, NSOsScannerTest::CVE_ID_2);
        EXPECT_EQ(detection2.cnaSource, "cisa");
        EXPECT_EQ(detection2.matchCondition, "6.1.7777");
        EXPECT_EQ(detection2.conditionType, MatchRuleCondition::LessThan);
    }
}

/*
 * @brief Test cna default array priority with detections in both CNAs and remediations.
 */
TEST_F(OsScannerTest, TestCnaArrayPriorityMultipleCnaDetectionBothRemediations)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({"adp_default_array":["cisa","nvd"]})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    // First CNA
    const auto testCandidatesFirstCna = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_2;

    auto mockGetVulnerabilitiesCandidatesFirstCna =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidatesFirstCna, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("cisa", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidatesFirstCna));

    // Second CNA
    const auto testCandidates = NSOsScannerTest::CANDIDATES_AFFECTED_WINDOWS_CVE_ID_1;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_2, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 2);

    const std::string detectionId1 = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    const std::string detectionId2 = "001_Microsoft Windows 7_6.1.7601_CVE-2025-2";

    EXPECT_TRUE(detections.find(detectionId1) != detections.end());
    EXPECT_TRUE(detections.find(detectionId2) != detections.end());

    if (detections.find(detectionId1) != detections.end())
    {
        const auto& detection1 = detections.at(detectionId1);
        EXPECT_EQ(detection1.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection1.cnaSource, "nvd");
    }

    if (detections.find(detectionId2) != detections.end())
    {
        const auto& detection2 = detections.at(detectionId2);
        EXPECT_EQ(detection2.cveId, NSOsScannerTest::CVE_ID_2);
        EXPECT_EQ(detection2.cnaSource, "cisa");
    }
}

/*
 * @brief Test scanning macOS/Darwin platform.
 */
TEST_F(OsScannerTest, TestDarwinPlatformScanning)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_DARWIN);

    const auto testCandidates = NSOsScannerTest::CANDIDATES_AFFECTED_DARWIN_CVE_ID_3;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 1);

    const std::string expectedDetectionId = "002_macOS_13.0_CVE-2025-3";
    EXPECT_TRUE(detections.find(expectedDetectionId) != detections.end());

    if (detections.find(expectedDetectionId) != detections.end())
    {
        const auto& detection = detections.at(expectedDetectionId);
        EXPECT_EQ(detection.cveId, NSOsScannerTest::CVE_ID_3);
        EXPECT_EQ(detection.cnaSource, "nvd");
        EXPECT_EQ(detection.matchCondition, "14.0");
        EXPECT_EQ(detection.conditionType, MatchRuleCondition::LessThan);
    }
}

/*
 * @brief Test unsupported platform (Linux) - should skip OS scanning.
 */
TEST_F(OsScannerTest, TestUnsupportedPlatformLinux)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_LINUX);

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates(_, _, _)).Times(0);

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 0);
}

/*
 * @brief Test with empty CPE product (CPE parsing failure).
 */
TEST_F(OsScannerTest, TestEmptyCPEProduct)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    const nlohmann::json emptyOsCPE = R"({})"_json;
    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(emptyOsCPE));
    const auto vendorMaps = R"({})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates(_, _, _)).Times(0);

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 0);
}

/*
 * @brief Test default status affected (no version rules).
 */
TEST_F(OsScannerTest, TestDefaultStatusAffected)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    const auto testCandidates = NSOsScannerTest::CANDIDATES_DEFAULT_STATUS_AFFECTED;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS_NOT_INSTALLED, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 1);

    const std::string expectedDetectionId = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    EXPECT_TRUE(detections.find(expectedDetectionId) != detections.end());

    if (detections.find(expectedDetectionId) != detections.end())
    {
        const auto& detection = detections.at(expectedDetectionId);
        EXPECT_EQ(detection.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection.conditionType, MatchRuleCondition::DefaultStatus);
        EXPECT_EQ(detection.matchCondition, "");
        EXPECT_EQ(detection.cnaSource, "nvd");
    }
}

/*
 * @brief Test exact version match.
 */
TEST_F(OsScannerTest, TestExactVersionMatch)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    const auto testCandidates = NSOsScannerTest::CANDIDATES_EQUAL_VERSION;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS_NOT_INSTALLED, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 1);

    const std::string expectedDetectionId = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    EXPECT_TRUE(detections.find(expectedDetectionId) != detections.end());

    if (detections.find(expectedDetectionId) != detections.end())
    {
        const auto& detection = detections.at(expectedDetectionId);
        EXPECT_EQ(detection.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection.conditionType, MatchRuleCondition::Equal);
        EXPECT_EQ(detection.matchCondition, "6.1.7601");
    }
}

/*
 * @brief Test lessThanOrEqual version condition.
 */
TEST_F(OsScannerTest, TestLessThanOrEqualVersion)
{
    TOsScanner<MockDatabaseFeedManager, TrampolineScanContext, TrampolineGlobalData> osScanner(
        m_spDatabaseFeedManagerMock);

    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(testing::ReturnRef(NSOsScannerTest::OSCPE_GLOBAL));
    const auto vendorMaps = R"({})"_json;
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(vendorMaps));

    loadScanContext(NSOsScannerTest::DELTA_OS_INSERT_WINDOWS);

    const auto testCandidates = NSOsScannerTest::CANDIDATES_LESSEQUAL_VERSION;

    auto mockGetVulnerabilitiesCandidates =
        [&](const std::string& cnaName,
            const PackageData& package,
            const std::function<bool(const std::string& cnaName,
                                     const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& callback)
    {
        OsScannerTest::scanCandidates(testCandidates, cnaName, package, callback);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(testing::Invoke(mockGetVulnerabilitiesCandidates));

    auto mockGetVulnerabilityRemediation =
        [&](const std::string& cveId, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations)
    {
        parseRemediations(NSOsScannerTest::REMEDIATIONS_NOT_INSTALLED, remediations);
    };

    EXPECT_CALL(*m_spDatabaseFeedManagerMock, getVulnerabilityRemediation(NSOsScannerTest::CVE_ID_1, _))
        .Times(1)
        .WillOnce(testing::Invoke(mockGetVulnerabilityRemediation));

    EXPECT_NO_THROW(osScanner.handleRequest(m_spScanContext));

    const auto& detections = m_spScanContext->detectedCVEs();
    EXPECT_EQ(detections.size(), 1);

    const std::string expectedDetectionId = "001_Microsoft Windows 7_6.1.7601_CVE-2025-1";
    EXPECT_TRUE(detections.find(expectedDetectionId) != detections.end());

    if (detections.find(expectedDetectionId) != detections.end())
    {
        const auto& detection = detections.at(expectedDetectionId);
        EXPECT_EQ(detection.cveId, NSOsScannerTest::CVE_ID_1);
        EXPECT_EQ(detection.conditionType, MatchRuleCondition::LessThanOrEqual);
        EXPECT_EQ(detection.matchCondition, "6.1.7601");
    }
}
