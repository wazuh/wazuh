/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "factoryOrchestrator_test.hpp"
#include "MockDatabaseFeedManager.hpp"
#include "MockIndexerConnector.hpp"

enum class ScannerMockID : int
{
    PACKAGE_SCANNER = 0,
    CVE_SOLVED_ALERT_DETAILS_BUILDER = 1,
    EVENT_DETAILS_BUILDER = 2,
    ALERT_CLEAR_BUILDER = 3,
    OS_SCANNER = 4,
    CLEAN_ALL_AGENT_INVENTORY = 5,
    EVENT_DELETE_INVENTORY = 6,
    EVENT_INSERT_INVENTORY = 7,
    SCAN_INVENTORY_SYNC = 8,
    CVE_SOLVED_INVENTORY_SYNC = 9,
    CLEAR_SEND_REPORT = 10,
    EVENT_SEND_REPORT = 11,
    EVENT_GET_CVE = 12,
    EVENT_GET_CONTEXT = 13,
    BUILD_ALL_AGENT_LIST_CONTEXT = 14,
    BUILD_SINGLE_AGENT_LIST_CONTEXT = 15,
    CLEAN_SINGLE_AGENT_INVENTORY = 16,
    SCAN_AGENT_LIST = 17,
    HOTFIX_INSERT = 18,
    RESULT_INDEXER = 19
};

/**
 * @brief Generic fake base class
 */
template<ScannerMockID param = ScannerMockID::PACKAGE_SCANNER>
class TFakeClass : public AbstractHandler<std::shared_ptr<std::vector<ScannerMockID>>>
{
public:
    ScannerMockID m_id {param}; ///< Identifier.

    /**
     * @brief Construct a new TFakeClass object.
     *
     * @param databaseFeedManager MockDatabaseFeedManager instance.
     */
    TFakeClass(std::shared_ptr<MockDatabaseFeedManager>& databaseFeedManager) {};
    /**
     * @brief Construct a new TFakeClass object.
     *
     * @param inventoryDatabase RocksDBWrapper instance for inventory storage.
     * @param subOrchestration AbstractHandler instance.
     */
    TFakeClass(Utils::RocksDBWrapper& inventoryDatabase,
               std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<ScannerMockID>>>> subOrchestration) {};
    /**
     * @brief Construct a new TFakeClass object.
     *
     * @param inventoryDatabase RocksDBWrapper instance for inventory storage.
     */
    TFakeClass(Utils::RocksDBWrapper& inventoryDatabase) {};
    /**
     * @brief Construct a new TFakeClass object.
     *
     * @param reportDispatcher Report dispatcher instance.
     */
    TFakeClass(std::shared_ptr<ReportDispatcher> reportDispatcher) {};
    /**
     * @brief Construct a new TFakeClass object.
     *
     * @param indexerConnector TIndexerConnector instance.
     */
    TFakeClass(std::shared_ptr<MockIndexerConnector> indexerConnector) {};
    /**
     * @brief Construct a new TFakeClass object.
     *
     */
    TFakeClass(std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<ScannerMockID>>>>,
               std::shared_ptr<AbstractHandler<std::shared_ptr<std::vector<ScannerMockID>>>>) {};
    /**
     * @brief Construct a new TFakeClass object.
     */
    TFakeClass() = default;
    virtual ~TFakeClass() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Mocked context data
     * @return std::shared_ptr<std::vector<std::string>>
     */
    std::shared_ptr<std::vector<ScannerMockID>> handleRequest(std::shared_ptr<std::vector<ScannerMockID>> data) override
    {
        data->push_back(m_id);
        return AbstractHandler<std::shared_ptr<std::vector<ScannerMockID>>>::handleRequest(std::move(data));
    }
};

using TestFactoryOrchestrator = TFactoryOrchestrator<TFakeClass<ScannerMockID::PACKAGE_SCANNER>,
                                                     TFakeClass<ScannerMockID::EVENT_DETAILS_BUILDER>,
                                                     TFakeClass<ScannerMockID::OS_SCANNER>,
                                                     TFakeClass<ScannerMockID::EVENT_SEND_REPORT>,
                                                     MockDatabaseFeedManager,
                                                     MockIndexerConnector,
                                                     TFakeClass<ScannerMockID::EVENT_GET_CVE>,
                                                     TFakeClass<ScannerMockID::EVENT_GET_CONTEXT>,
                                                     TFakeClass<ScannerMockID::RESULT_INDEXER>,
                                                     std::vector<ScannerMockID>>;

/*
 * @brief Test the chain creation for PackagesDelta scanner type.
 * Verifies the correct orchestration chain: PackageScanner -> EventGetCve -> EventDetailsBuilder -> EventSendReport ->
 * ResultIndexer
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypePackagesDelta)
{
    // Create the orchestrator for PackagesDelta.
    auto orchestration = TestFactoryOrchestrator::create(ScannerType::PackagesDelta, nullptr, nullptr);

    // Verify orchestration was created
    ASSERT_NE(orchestration, nullptr);

    auto context = std::make_shared<std::vector<ScannerMockID>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    ASSERT_EQ(context->size(), 5);
    EXPECT_EQ(context->at(0), ScannerMockID::PACKAGE_SCANNER);
    EXPECT_EQ(context->at(1), ScannerMockID::EVENT_GET_CVE);
    EXPECT_EQ(context->at(2), ScannerMockID::EVENT_DETAILS_BUILDER);
    EXPECT_EQ(context->at(3), ScannerMockID::EVENT_SEND_REPORT);
    EXPECT_EQ(context->at(4), ScannerMockID::RESULT_INDEXER);
}

/*
 * @brief Test the chain creation for FirstFullScan scanner type.
 * Verifies the correct orchestration chain: OsScanner -> PackageScanner -> EventDetailsBuilder -> EventSendReport ->
 * ResultIndexer
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypeFirstFullScan)
{
    // Create the orchestrator for FirstFullScan.
    auto orchestration = TestFactoryOrchestrator::create(ScannerType::FirstFullScan, nullptr, nullptr);

    // Verify orchestration was created
    ASSERT_NE(orchestration, nullptr);

    auto context = std::make_shared<std::vector<ScannerMockID>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    ASSERT_EQ(context->size(), 5);
    EXPECT_EQ(context->at(0), ScannerMockID::OS_SCANNER);
    EXPECT_EQ(context->at(1), ScannerMockID::PACKAGE_SCANNER);
    EXPECT_EQ(context->at(2), ScannerMockID::EVENT_DETAILS_BUILDER);
    EXPECT_EQ(context->at(3), ScannerMockID::EVENT_SEND_REPORT);
    EXPECT_EQ(context->at(4), ScannerMockID::RESULT_INDEXER);
}

/*
 * @brief Test the chain creation for FullScan scanner type.
 * Verifies the correct orchestration chain: EventGetContext -> OsScanner -> PackageScanner -> EventDetailsBuilder ->
 * EventSendReport -> ResultIndexer
 */
TEST_F(FactoryOrchestratorTest, TestScannerTypeFullScan)
{
    auto orchestration = TestFactoryOrchestrator::create(ScannerType::FullScan, nullptr, nullptr);

    ASSERT_NE(orchestration, nullptr);

    auto context = std::make_shared<std::vector<ScannerMockID>>();

    EXPECT_NO_THROW(orchestration->handleRequest(context));
    ASSERT_EQ(context->size(), 6);
    EXPECT_EQ(context->at(0), ScannerMockID::EVENT_GET_CONTEXT);
    EXPECT_EQ(context->at(1), ScannerMockID::OS_SCANNER);
    EXPECT_EQ(context->at(2), ScannerMockID::PACKAGE_SCANNER);
    EXPECT_EQ(context->at(3), ScannerMockID::EVENT_DETAILS_BUILDER);
    EXPECT_EQ(context->at(4), ScannerMockID::EVENT_SEND_REPORT);
    EXPECT_EQ(context->at(5), ScannerMockID::RESULT_INDEXER);
}

/*
 * @brief Test the creation of an unknown scanner type.
 * Verifies that unknown scanner types return nullptr and log a warning.
 */
TEST_F(FactoryOrchestratorTest, TestCreationUnknownScannerType)
{
    auto orchestration = TestFactoryOrchestrator::create(ScannerType::Unknown, nullptr, nullptr);

    EXPECT_EQ(orchestration, nullptr);
}

/*
 * @brief Test that all scanner types are covered.
 */
TEST_F(FactoryOrchestratorTest, TestAllActiveScannerTypesReturnNonNull)
{
    auto orchestrationPackages = TestFactoryOrchestrator::create(ScannerType::PackagesDelta, nullptr, nullptr);
    EXPECT_NE(orchestrationPackages, nullptr);

    auto orchestrationFirstFull = TestFactoryOrchestrator::create(ScannerType::FirstFullScan, nullptr, nullptr);
    EXPECT_NE(orchestrationFirstFull, nullptr);

    auto orchestrationFull = TestFactoryOrchestrator::create(ScannerType::FullScan, nullptr, nullptr);
    EXPECT_NE(orchestrationFull, nullptr);
}
