/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "scanOrchestrator_test.hpp"
#include "../scanOrchestrator/scanOrchestrator.hpp"
#include "MockFactoryOrchestrator.hpp"
#include "TrampolineFactoryOrchestrator.hpp"
#include "TrampolineOsDataCache.hpp"
#include "TrampolineScanContext.hpp"
#include "flatbuffers/include/inventorySync_generated.h"
#include "json.hpp"
#include "rocksDBWrapper.hpp"
#include <format>

auto constexpr TEST_REPORTS_QUEUE_PATH {"queue/vd/reports"};
auto constexpr TEST_REPORTS_BULK_SIZE {1};

using std::string_literals::operator""s;
const std::string TEST_PACKAGE_INDEX = "wazuh-states-inventory-packages"s;
const std::string TEST_OS_INDEX = "wazuh-states-inventory-system"s;
const std::string TEST_HOTFIX_INDEX = "wazuh-states-inventory-hotfixes"s;

using ::testing::_;
using testing::Return;

namespace NSScanOrchestratorTest
{
    // Package inventory document (DataValue with Upsert operation)
    const std::string PACKAGE_INSERTED_JSON =
        R"({
            "package": {
                "architecture": "amd64",
                "checksum": "1e6ce14f97f57d1bbd46ff8e5d3e133171a1bbce",
                "description": "library for GIF images library",
                "installed": "2023-08-04T19:56:11Z",
                "name": "libgif7",
                "path": "/usr/lib/x86_64-linux-gnu/libgif.so.7.2.0",
                "size": 72704,
                "type": "deb",
                "version": "5.1.9-1"
            }
        })";

    // Package inventory document to delete (DataValue with Delete operation)
    const std::string PACKAGE_DELETED_JSON =
        R"({
            "package": {
                "architecture": "amd64",
                "name": "libgif7",
                "version": "5.1.9-1"
            }
        })";

    // Hotfix inventory document (DataValue with Upsert operation)
    const std::string HOTFIX_INSERTED_JSON =
        R"({
            "package": {
                "hotfix": {
                    "name": "KB12345678"
                }
            }
        })";

    // OS inventory document (DataContext - always upsert for current OS state)
    const std::string OSINFO_JSON =
        R"({
            "host": {
                "architecture": "x86_64",
                "hostname": "redhat",
                "os": {
                    "codename": "9",
                    "kernel": {
                        "name": "Linux",
                        "release": "5.4.0-155-generic",
                        "version": "#172-Ubuntu SMP Fri Jul 7 16:10:02 UTC 2023"
                    },
                    "major": "9",
                    "minor": "0",
                    "name": "Red Hat Enterprise Linux",
                    "patch": "6",
                    "platform": "rhel",
                    "type": "linux",
                    "version": "9.0.6"
                }
            }
        })";

    // Ubuntu OS for testing
    const std::string UBUNTU_OSINFO_JSON =
        R"({
            "host": {
                "architecture": "x86_64",
                "hostname": "ubuntu-host",
                "os": {
                    "codename": "focal",
                    "kernel": {
                        "name": "Linux",
                        "release": "5.4.0-150-generic",
                        "version": "#167-Ubuntu SMP Mon May 15 17:35:05 UTC 2023"
                    },
                    "major": "20",
                    "minor": "04",
                    "name": "Ubuntu",
                    "platform": "ubuntu",
                    "type": "linux",
                    "version": "20.04"
                }
            }
        })";

    const Os osData {.hostName = "osdata_hostname",
                     .architecture = "osdata_architecture",
                     .name = "osdata_name",
                     .codeName = "osdata_codeName",
                     .majorVersion = "osdata_majorVersion",
                     .minorVersion = "osdata_minorVersion",
                     .patch = "osdata_patch",
                     .build = "osdata_build",
                     .platform = "osdata_platform",
                     .version = "osdata_version",
                     .release = "osdata_release",
                     .displayVersion = "osdata_displayVersion",
                     .sysName = "osdata_sysName",
                     .kernelVersion = "osdata_kernelVersion",
                     .kernelRelease = "osdata_kernelRelease"};

} // namespace NSScanOrchestratorTest

// Helper functions to create FlatBuffer messages for testing

/**
 * @brief Create a DataValue FlatBuffer message
 */
std::vector<uint8_t> createDataValueMessage(uint64_t sessionId,
                                            const std::string& index,
                                            const std::string& documentId,
                                            const std::string& jsonData,
                                            Wazuh::SyncSchema::Operation operation)
{
    flatbuffers::FlatBufferBuilder builder;

    auto indexOffset = builder.CreateString(index);
    auto idOffset = builder.CreateString(documentId);
    auto dataVector = builder.CreateVector(reinterpret_cast<const int8_t*>(jsonData.data()), jsonData.size());

    auto dataValue =
        Wazuh::SyncSchema::CreateDataValue(builder, sessionId, 0, operation, indexOffset, idOffset, 0, dataVector);
    auto message =
        Wazuh::SyncSchema::CreateMessage(builder, Wazuh::SyncSchema::MessageType_DataValue, dataValue.Union());

    builder.Finish(message);

    return std::vector<uint8_t>(builder.GetBufferPointer(), builder.GetBufferPointer() + builder.GetSize());
}

/**
 * @brief Create a DataContext FlatBuffer message
 */
std::vector<uint8_t> createDataContextMessage(uint64_t sessionId,
                                              const std::string& index,
                                              const std::string& documentId,
                                              const std::string& jsonData)
{
    flatbuffers::FlatBufferBuilder builder;

    auto indexOffset = builder.CreateString(index);
    auto idOffset = builder.CreateString(documentId);
    auto dataVector = builder.CreateVector(reinterpret_cast<const int8_t*>(jsonData.data()), jsonData.size());

    auto dataContext = Wazuh::SyncSchema::CreateDataContext(builder, sessionId, 0, indexOffset, idOffset, dataVector);
    auto message =
        Wazuh::SyncSchema::CreateMessage(builder, Wazuh::SyncSchema::MessageType_DataContext, dataContext.Union());

    builder.Finish(message);

    return std::vector<uint8_t>(builder.GetBufferPointer(), builder.GetBufferPointer() + builder.GetSize());
}

/**
 * @brief Create a Context struct for testing
 */
Context createTestContext(Wazuh::SyncSchema::Option option, std::vector<std::string> indices = {})
{
    Context ctx;
    ctx.mode = Wazuh::SyncSchema::Mode_ModuleDelta;
    ctx.option = option;
    ctx.sessionId = 12345;
    ctx.moduleName = "vulnerability-scanner";
    ctx.indices = std::move(indices);
    ctx.agentId = "001";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "5.0.0";
    ctx.architecture = "x86_64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "linux";
    ctx.osversion = "20.04";
    ctx.groups = {"default"};
    ctx.globalVersion = 1;

    return ctx;
}

// Shared pointers definitions
std::shared_ptr<MockFactoryOrchestrator> spFactoryOrchestratorMock;

using namespace NSScanOrchestratorTest;

void ScanOrchestratorTest::SetUp() {}

void ScanOrchestratorTest::TearDown()
{
    spFactoryOrchestratorMock.reset();
    spOsDataCacheMock.reset();
    Log::deassignLogFunction();
}

TEST_F(ScanOrchestratorTest, TestVDFirstFullScan)
{
    // Setup mocks - only 3 orchestration chains are created in constructor
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(0);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFirstFullScan, handleRequest(_)).Times(1);

    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(0);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    EXPECT_CALL(*spIndexerConnectorMock, deleteByQuery("wazuh-states-vulnerabilities", "001")).Times(1);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    // Create RocksDB data store
    Utils::RocksDBWrapper dataStore("/tmp/test_vd_vdfirst");

    uint64_t sessionId = 12345;

    // Add package message
    auto packageMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", PACKAGE_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(packageMessage.data()), packageMessage.size()));

    // Add OS context message
    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    // Create context for VDFirst
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDFirst, {TEST_PACKAGE_INDEX, TEST_OS_INDEX});
    context.sessionId = sessionId;

    // Run scan
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, RunScanAfterFeedUpdateNullContextSkipsHandler)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(0);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFirstFullScan, handleRequest(_)).Times(0);

    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(0);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    EXPECT_NO_THROW(scanOrchestrator.runScanAfterFeedUpdate(nullptr));
}

TEST_F(ScanOrchestratorTest, RunScanAfterFeedUpdateWithContextNoLock)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(0);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFirstFullScan, handleRequest(_)).Times(0);

    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(1);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    auto scanContext = std::make_shared<TrampolineTScanContext>();
    EXPECT_NO_THROW(scanOrchestrator.runScanAfterFeedUpdate(scanContext, false));
}

TEST_F(ScanOrchestratorTest, TestVDSyncPackageDelta)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFirstFullScan, handleRequest(_)).Times(0);

    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(0);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    // Create RocksDB data store
    Utils::RocksDBWrapper dataStore("/tmp/test_vd_vdsync_pkgdelta");

    uint64_t sessionId = 12346;

    // Add package insert message
    auto packageInsertMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", PACKAGE_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(
        std::format("{}_{}", sessionId, "001"),
        rocksdb::Slice(reinterpret_cast<const char*>(packageInsertMessage.data()), packageInsertMessage.size()));

    // Add package delete message
    auto packageDeleteMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg002", PACKAGE_DELETED_JSON, Wazuh::SyncSchema::Operation_Delete);
    dataStore.put(
        std::format("{}_{}", sessionId, "002"),
        rocksdb::Slice(reinterpret_cast<const char*>(packageDeleteMessage.data()), packageDeleteMessage.size()));

    // Add OS context message
    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "003"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    // Create context for VDSync with only package changes (no OS/hotfix change)
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestVDSyncOSChangeTriggersFullScan)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(0);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFirstFullScan, handleRequest(_)).Times(0);

    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(1);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    // Create RocksDB data store
    Utils::RocksDBWrapper dataStore("/tmp/test_vd_vdsync_oschange");

    uint64_t sessionId = 12347;

    // Add package message
    auto packageMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", PACKAGE_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(packageMessage.data()), packageMessage.size()));

    // Add NEW OS context message
    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", UBUNTU_OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    // Create context for VDSync with OS change
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_OS_INDEX, TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestVDSyncHotfixChangeTriggersFullScan)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(0);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFirstFullScan, handleRequest(_)).Times(0);

    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(1);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    // Create RocksDB data store
    Utils::RocksDBWrapper dataStore("/tmp/test_vd_vdsync_hotfix");

    uint64_t sessionId = 12348;

    // Add hotfix message
    auto hotfixMessage = createDataValueMessage(
        sessionId, TEST_HOTFIX_INDEX, "hf001", HOTFIX_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(hotfixMessage.data()), hotfixMessage.size()));

    // Add OS context message
    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    // Create context for VDSync with hotfix change
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_HOTFIX_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestBuildScanContextWithPackages)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    // Create RocksDB data store with multiple packages
    Utils::RocksDBWrapper dataStore("/tmp/test_vd_build_context");

    uint64_t sessionId = 12349;

    // Add multiple package messages
    auto pkg1Message = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", PACKAGE_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkg1Message.data()), pkg1Message.size()));

    const std::string PKG2_JSON = R"({
        "package": {
            "architecture": "amd64",
            "name": "curl",
            "type": "deb",
            "version": "7.68.0-1ubuntu2.16"
        }
    })";

    auto pkg2Message =
        createDataValueMessage(sessionId, TEST_PACKAGE_INDEX, "pkg002", PKG2_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkg2Message.data()), pkg2Message.size()));

    // Add OS context message
    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "003"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    // Create context
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    // Run scan
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestMixedPackageOperations)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_mixed_ops");

    uint64_t sessionId = 12350;

    // Insert packages
    auto pkg1Insert = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", PACKAGE_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkg1Insert.data()), pkg1Insert.size()));

    // Delete a package
    auto pkg2Delete = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg002", PACKAGE_DELETED_JSON, Wazuh::SyncSchema::Operation_Delete);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkg2Delete.data()), pkg2Delete.size()));

    // Add OS context
    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "003"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    // Create context
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    // Run scan
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestUnknownOption)
{
    // Setup minimal mocks (orchestrations won't be called for unknown option)
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_unknown_option");

    uint64_t sessionId = 12351;

    // Create context with invalid option (cast to enum)
    auto context = createTestContext(static_cast<Wazuh::SyncSchema::Option>(999));
    context.sessionId = sessionId;

    // Should not throw, but will log warning about unknown option
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestEmptyDataStore)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    // Create empty data store
    Utils::RocksDBWrapper dataStore("/tmp/test_vd_empty");

    uint64_t sessionId = 12352;

    // Create context
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    // Should handle empty store gracefully
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestInvalidFlatBufferMessage)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_invalid_fb");

    uint64_t sessionId = 12353;

    // Add invalid FlatBuffer (just random bytes)
    std::vector<uint8_t> invalidData = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05};
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(invalidData.data()), invalidData.size()));

    // Add valid package message
    auto packageMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", PACKAGE_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(packageMessage.data()), packageMessage.size()));

    // Add OS context
    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "003"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    // Create context
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    // Should skip invalid message and process valid ones
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestOSDataContextVsDataValue)
{
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(1);

    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_os_datacontext");

    uint64_t sessionId = 12354;

    // Add OS as DataContext (current OS state)
    auto osContextMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osContextMessage.data()), osContextMessage.size()));

    // Add OS deleted as DataValue with Delete operation (old OS that was removed)
    const std::string OS_DELETED_JSON = R"({
        "host": {
            "os": {
                "name": "CentOS",
                "version": "7.9"
            }
        }
    })";
    auto osDeleteMessage =
        createDataValueMessage(sessionId, TEST_OS_INDEX, "os002", OS_DELETED_JSON, Wazuh::SyncSchema::Operation_Delete);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osDeleteMessage.data()), osDeleteMessage.size()));

    // Create context with OS change
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_OS_INDEX});
    context.sessionId = sessionId;

    // Should trigger full scan due to OS change
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestPackageWithMinimalFields)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_minimal_pkg");

    uint64_t sessionId = 12355;

    // Package with only minimal required fields
    const std::string MINIMAL_PKG_JSON = R"({
        "package": {
            "name": "minimal-pkg",
            "version": "1.0"
        }
    })";

    auto packageMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", MINIMAL_PKG_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(packageMessage.data()), packageMessage.size()));

    // Add OS context
    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    // Create context
    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    // Should handle minimal package data gracefully
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestOSExtractionWithComplexFields)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_os_complex");

    uint64_t sessionId = 12356;

    const std::string COMPLEX_OS_JSON = R"json({
        "host": {
            "architecture": "x86_64",
            "hostname": "complex-host",
            "os": {
                "build": "build123",
                "codename": "focal",
                "distribution": {
                    "release": "20.04.5 LTS"
                },
                "full": "Ubuntu 20.04.5 LTS (Focal Fossa)",
                "kernel": {
                    "name": "Linux",
                    "release": "5.15.0-91-generic",
                    "version": "#101-Ubuntu SMP Tue Nov 14 13:30:08 UTC 2023"
                },
                "major": "20",
                "minor": "04",
                "name": "Ubuntu",
                "patch": "5",
                "platform": "ubuntu",
                "type": "linux",
                "version": "20.04.5"
            }
        }
    })json";

    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", COMPLEX_OS_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestPackageExtractionWithAllFields)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_pkg_all_fields");

    uint64_t sessionId = 12357;

    const std::string FULL_PACKAGE_JSON = R"({
        "package": {
            "architecture": "amd64",
            "checksum": "abc123def456",
            "description": "Full package with all fields",
            "installed": "2023-08-04T19:56:11Z",
            "name": "full-package",
            "path": "/usr/lib/full-package.so",
            "size": 1024000,
            "type": "deb",
            "version": "2.0.0",
            "vendor": "Test Vendor",
            "source": "test-source-package",
            "priority": "optional",
            "multiarch": "same",
            "category": "libs"
        }
    })";

    auto packageMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", FULL_PACKAGE_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(packageMessage.data()), packageMessage.size()));

    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestPackageWithNullOptionalFields)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_pkg_null_fields");

    uint64_t sessionId = 12358;

    // Package with null optional fields
    const std::string NULL_FIELDS_PACKAGE_JSON = R"({
        "package": {
            "name": "test-package",
            "version": "1.0.0",
            "type": "deb",
            "architecture": null,
            "vendor": null,
            "description": null
        }
    })";

    auto packageMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", NULL_FIELDS_PACKAGE_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(packageMessage.data()), packageMessage.size()));

    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestMultipleHotfixesInSession)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(0);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFirstFullScan, handleRequest(_)).Times(0);

    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(1);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_multiple_hotfixes");

    uint64_t sessionId = 12359;

    // Add multiple hotfixes
    const std::string HOTFIX1_JSON = R"({"package": {"hotfix": {"name": "KB1111111"}}})";
    const std::string HOTFIX2_JSON = R"({"package": {"hotfix": {"name": "KB2222222"}}})";
    const std::string HOTFIX3_JSON = R"({"package": {"hotfix": {"name": "KB3333333"}}})";

    auto hotfix1Message = createDataValueMessage(
        sessionId, TEST_HOTFIX_INDEX, "hf001", HOTFIX1_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(hotfix1Message.data()), hotfix1Message.size()));

    auto hotfix2Message = createDataValueMessage(
        sessionId, TEST_HOTFIX_INDEX, "hf002", HOTFIX2_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(hotfix2Message.data()), hotfix2Message.size()));

    auto hotfix3Message = createDataValueMessage(
        sessionId, TEST_HOTFIX_INDEX, "hf003", HOTFIX3_JSON, Wazuh::SyncSchema::Operation_Delete);
    dataStore.put(std::format("{}_{}", sessionId, "003"),
                  rocksdb::Slice(reinterpret_cast<const char*>(hotfix3Message.data()), hotfix3Message.size()));

    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "004"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_HOTFIX_INDEX});
    context.sessionId = sessionId;

    // Should trigger full scan due to hotfix changes
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestMixedIndicesInSingleSession)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(0);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFirstFullScan, handleRequest(_)).Times(0);

    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(1);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_mixed_indices");

    uint64_t sessionId = 12360;

    // Add OS, Package, and Hotfix messages
    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    auto packageMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", PACKAGE_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(packageMessage.data()), packageMessage.size()));

    auto hotfixMessage = createDataValueMessage(
        sessionId, TEST_HOTFIX_INDEX, "hf001", HOTFIX_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "003"),
                  rocksdb::Slice(reinterpret_cast<const char*>(hotfixMessage.data()), hotfixMessage.size()));

    // Context indicates all three indices changed
    auto context =
        createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_OS_INDEX, TEST_PACKAGE_INDEX, TEST_HOTFIX_INDEX});
    context.sessionId = sessionId;

    // Should trigger full scan because OS changed
    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestOSWithNullFields)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(0);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(1);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_os_null_fields");

    uint64_t sessionId = 12361;

    const std::string OS_WITH_NULLS_JSON = R"({
        "host": {
            "architecture": "x86_64",
            "hostname": null,
            "os": {
                "name": "TestOS",
                "version": "1.0",
                "platform": null,
                "type": "linux",
                "kernel": null
            }
        }
    })";

    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OS_WITH_NULLS_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_OS_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestEmptyIndicesList)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_empty_indices");

    uint64_t sessionId = 12362;

    auto packageMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", PACKAGE_INSERTED_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(packageMessage.data()), packageMessage.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestMultiplePackageVersions)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_multi_versions");

    uint64_t sessionId = 12363;

    const std::string PKG_V1_JSON = R"({"package": {"name": "curl", "version": "7.68.0", "type": "deb"}})";
    const std::string PKG_V2_JSON = R"({"package": {"name": "curl", "version": "7.81.0", "type": "deb"}})";
    const std::string PKG_V3_JSON = R"({"package": {"name": "curl", "version": "8.0.1", "type": "deb"}})";

    auto pkg1Message = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", PKG_V1_JSON, Wazuh::SyncSchema::Operation_Delete);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkg1Message.data()), pkg1Message.size()));

    auto pkg2Message = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg002", PKG_V2_JSON, Wazuh::SyncSchema::Operation_Delete);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkg2Message.data()), pkg2Message.size()));

    auto pkg3Message = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg003", PKG_V3_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "003"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkg3Message.data()), pkg3Message.size()));

    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "004"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestHotfixWithEmptyName)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(0);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFullScan, handleRequest(_)).Times(1);

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_hotfix_empty_name");

    uint64_t sessionId = 12364;

    const std::string EMPTY_HOTFIX_JSON = R"({"package": {"hotfix": {"name": ""}}})";

    auto hotfixMessage = createDataValueMessage(
        sessionId, TEST_HOTFIX_INDEX, "hf001", EMPTY_HOTFIX_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(hotfixMessage.data()), hotfixMessage.size()));

    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_HOTFIX_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, TestPackageWithNullPackageField)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_vd_null_package_field");

    uint64_t sessionId = 12365;

    const std::string NULL_PACKAGE_JSON = R"({"package": null})";

    auto packageMessage = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "pkg001", NULL_PACKAGE_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(packageMessage.data()), packageMessage.size()));

    auto osMessage = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMessage.data()), osMessage.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

// Tests for extractPackageInfo method coverage

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_AllFieldsCoverage)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_pkg_extract_all");
    uint64_t sessionId = 20000;

    const std::string ALL_FIELDS_JSON = R"({
        "package": {
            "name": "test-pkg-all-fields",
            "version": "1.2.3",
            "type": "deb",
            "architecture": "amd64",
            "vendor": "TestVendor",
            "description": "Test package description",
            "installed": "2024-01-15T10:00:00Z",
            "size": 123456,
            "source": "test-source",
            "path": "/usr/lib/test.so",
            "priority": "optional",
            "multiarch": "same",
            "category": "libs"
        }
    })";

    auto pkgMsg = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "p001", ALL_FIELDS_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkgMsg.data()), pkgMsg.size()));

    auto osMsg = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMsg.data()), osMsg.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_NullPackageField)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_pkg_null_field");
    uint64_t sessionId = 20001;

    const std::string NULL_PKG_JSON = R"({"package": null})";

    auto pkgMsg = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "p001", NULL_PKG_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkgMsg.data()), pkgMsg.size()));

    auto osMsg = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMsg.data()), osMsg.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_NullIndividualFields)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_pkg_null_indiv");
    uint64_t sessionId = 20002;

    const std::string NULL_FIELDS_JSON = R"({
        "package": {
            "name": "test-pkg",
            "version": "1.0",
            "type": null,
            "architecture": null,
            "vendor": null,
            "description": null,
            "installed": null,
            "size": null,
            "source": null,
            "path": null,
            "priority": null,
            "multiarch": null,
            "category": null
        }
    })";

    auto pkgMsg = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "p001", NULL_FIELDS_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkgMsg.data()), pkgMsg.size()));

    auto osMsg = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMsg.data()), osMsg.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_SimdjsonError)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_pkg_invalid_json");
    uint64_t sessionId = 20003;

    const std::string INVALID_JSON = R"({invalid json format missing quotes})";

    auto pkgMsg = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "p001", INVALID_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkgMsg.data()), pkgMsg.size()));

    auto osMsg = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMsg.data()), osMsg.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_Uint64Size)
{
    auto spPackageDeltaOrchestration = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    EXPECT_CALL(*spPackageDeltaOrchestration, handleRequest(_)).Times(1);

    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(testing::Return(spPackageDeltaOrchestration))
        .WillOnce(testing::Return(spFirstFullScan))
        .WillOnce(testing::Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    Utils::RocksDBWrapper dataStore("/tmp/test_pkg_large_size");
    uint64_t sessionId = 20004;

    const std::string LARGE_SIZE_JSON = R"({
        "package": {
            "name": "large-pkg",
            "version": "1.0",
            "size": 99999999999
        }
    })";

    auto pkgMsg = createDataValueMessage(
        sessionId, TEST_PACKAGE_INDEX, "p001", LARGE_SIZE_JSON, Wazuh::SyncSchema::Operation_Upsert);
    dataStore.put(std::format("{}_{}", sessionId, "001"),
                  rocksdb::Slice(reinterpret_cast<const char*>(pkgMsg.data()), pkgMsg.size()));

    auto osMsg = createDataContextMessage(sessionId, TEST_OS_INDEX, "os001", OSINFO_JSON);
    dataStore.put(std::format("{}_{}", sessionId, "002"),
                  rocksdb::Slice(reinterpret_cast<const char*>(osMsg.data()), osMsg.size()));

    auto context = createTestContext(Wazuh::SyncSchema::Option_VDSync, {TEST_PACKAGE_INDEX});
    context.sessionId = sessionId;

    EXPECT_NO_THROW(scanOrchestrator.runScan(dataStore, context));
}

// Tests for extractOSFromHostDocument method - Complete coverage
TEST_F(ScanOrchestratorTest, ExtractOSFromHost_AllFields)
{
    const std::string OS_ALL_FIELDS_JSON = R"({
        "host": {
            "hostname": "test-hostname",
            "architecture": "x86_64",
            "os": {
                "item_id": "os-item-123",
                "name": "Ubuntu",
                "platform": "ubuntu",
                "type": "linux",
                "version": "20.04",
                "full": "Ubuntu 20.04.3 LTS",
                "codename": "focal",
                "major": "20",
                "minor": "04",
                "patch": "3",
                "build": "build-123",
                "distribution": {
                    "release": "focal-updates"
                },
                "kernel": {
                    "version": "#167-Ubuntu SMP Mon May 15 17:35:05 UTC 2023",
                    "release": "5.4.0-150-generic"
                }
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_ALL_FIELDS_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.hostName, "test-hostname");
    EXPECT_EQ(result.architecture, "x86_64");
    EXPECT_EQ(result.item_id, "os-item-123");
    EXPECT_EQ(result.name, "Ubuntu");
    EXPECT_EQ(result.platform, "ubuntu");
    EXPECT_EQ(result.sysName, "linux");
    EXPECT_EQ(result.version, "20.04");
    EXPECT_EQ(result.displayVersion, "Ubuntu 20.04.3 LTS");
    EXPECT_EQ(result.codeName, "focal");
    EXPECT_EQ(result.majorVersion, "20");
    EXPECT_EQ(result.minorVersion, "04");
    EXPECT_EQ(result.patch, "3");
    EXPECT_EQ(result.build, "build-123");
    EXPECT_EQ(result.release, "focal-updates");
    EXPECT_EQ(result.kernelVersion, "#167-Ubuntu SMP Mon May 15 17:35:05 UTC 2023");
    EXPECT_EQ(result.kernelRelease, "5.4.0-150-generic");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_OnlyHostname)
{
    const std::string OS_HOSTNAME_JSON = R"({
        "host": {
            "hostname": "my-server"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_HOSTNAME_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.hostName, "my-server");
    EXPECT_TRUE(result.architecture.empty());
    EXPECT_TRUE(result.name.empty());
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_OnlyArchitecture)
{
    const std::string OS_ARCH_JSON = R"({
        "host": {
            "architecture": "aarch64"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_ARCH_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.architecture, "aarch64");
    EXPECT_TRUE(result.hostName.empty());
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_OSName)
{
    const std::string OS_NAME_JSON = R"({
        "host": {
            "os": {
                "name": "Red Hat Enterprise Linux"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_NAME_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.name, "Red Hat Enterprise Linux");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_OSPlatform)
{
    const std::string OS_PLATFORM_JSON = R"({
        "host": {
            "os": {
                "platform": "rhel"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_PLATFORM_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.platform, "rhel");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_OSType)
{
    const std::string OS_TYPE_JSON = R"({
        "host": {
            "os": {
                "type": "windows"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_TYPE_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.sysName, "windows");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_OSVersion)
{
    const std::string OS_VERSION_JSON = R"({
        "host": {
            "os": {
                "version": "22.04"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_VERSION_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.version, "22.04");
    EXPECT_EQ(result.displayVersion, "22.04");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_VersionAndFull)
{
    const std::string OS_VERSION_FULL_JSON = R"({
        "host": {
            "os": {
                "version": "22.04",
                "full": "Ubuntu 22.04.1 LTS"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_VERSION_FULL_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.version, "22.04");
    EXPECT_EQ(result.displayVersion, "Ubuntu 22.04.1 LTS");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_Codename)
{
    const std::string OS_CODENAME_JSON = R"({
        "host": {
            "os": {
                "codename": "jammy"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_CODENAME_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.codeName, "jammy");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_MajorMinorPatch)
{
    const std::string OS_VERSIONS_JSON = R"({
        "host": {
            "os": {
                "major": "10",
                "minor": "0",
                "patch": "19044"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_VERSIONS_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.majorVersion, "10");
    EXPECT_EQ(result.minorVersion, "0");
    EXPECT_EQ(result.patch, "19044");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_Build)
{
    const std::string OS_BUILD_JSON = R"({
        "host": {
            "os": {
                "build": "19044.1234"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_BUILD_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.build, "19044.1234");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_DistributionRelease)
{
    const std::string OS_DIST_JSON = R"({
        "host": {
            "os": {
                "distribution": {
                    "release": "22.04.1"
                }
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_DIST_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.release, "22.04.1");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_KernelVersionAndRelease)
{
    const std::string OS_KERNEL_JSON = R"({
        "host": {
            "os": {
                "kernel": {
                    "version": "#50-Ubuntu SMP Thu Oct 5 15:03:31 UTC 2023",
                    "release": "5.15.0-87-generic"
                }
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_KERNEL_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.kernelVersion, "#50-Ubuntu SMP Thu Oct 5 15:03:31 UTC 2023");
    EXPECT_EQ(result.kernelRelease, "5.15.0-87-generic");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_NullHostField)
{
    const std::string OS_NULL_HOST_JSON = R"({
        "host": null
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_NULL_HOST_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_TRUE(result.hostName.empty());
    EXPECT_TRUE(result.architecture.empty());
    EXPECT_TRUE(result.name.empty());
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_NullHostnameField)
{
    const std::string OS_NULL_HOSTNAME_JSON = R"({
        "host": {
            "hostname": null,
            "architecture": "x86_64"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_NULL_HOSTNAME_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_TRUE(result.hostName.empty());
    EXPECT_EQ(result.architecture, "x86_64");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_NullOSFields)
{
    const std::string OS_NULL_FIELDS_JSON = R"({
        "host": {
            "os": {
                "name": null,
                "platform": "ubuntu",
                "version": null
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_NULL_FIELDS_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_TRUE(result.name.empty());
    EXPECT_EQ(result.platform, "ubuntu");
    EXPECT_TRUE(result.version.empty());
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_NullDistribution)
{
    const std::string OS_NULL_DIST_JSON = R"({
        "host": {
            "os": {
                "distribution": null
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_NULL_DIST_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_TRUE(result.release.empty());
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_NullKernel)
{
    const std::string OS_NULL_KERNEL_JSON = R"({
        "host": {
            "os": {
                "kernel": null
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_NULL_KERNEL_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_TRUE(result.kernelVersion.empty());
    EXPECT_TRUE(result.kernelRelease.empty());
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_NullKernelSubfields)
{
    const std::string OS_NULL_KERNEL_SUBFIELDS_JSON = R"({
        "host": {
            "os": {
                "kernel": {
                    "version": null,
                    "release": "5.15.0-87-generic"
                }
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_NULL_KERNEL_SUBFIELDS_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_TRUE(result.kernelVersion.empty());
    EXPECT_EQ(result.kernelRelease, "5.15.0-87-generic");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_EmptyDocument)
{
    const std::string OS_EMPTY_JSON = R"({})";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_EMPTY_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_TRUE(result.hostName.empty());
    EXPECT_TRUE(result.name.empty());
    EXPECT_TRUE(result.platform.empty());
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_ItemId)
{
    const std::string OS_ITEMID_JSON = R"({
        "host": {
            "os": {
                "item_id": "unique-os-identifier-123"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_ITEMID_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_EQ(result.item_id, "unique-os-identifier-123");
}

TEST_F(ScanOrchestratorTest, ExtractOSFromHost_DistributionNullRelease)
{
    const std::string OS_DIST_NULL_RELEASE_JSON = R"({
        "host": {
            "os": {
                "distribution": {
                    "release": null
                }
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(OS_DIST_NULL_RELEASE_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractOSFromHostDocument(doc);

    EXPECT_TRUE(result.release.empty());
}

// Additional tests for extractPackageInfo - One test per if statement

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_NameField)
{
    const std::string PACKAGE_NAME_JSON = R"({
        "package": {
            "name": "test-package"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_NAME_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.name, "test-package");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_VersionField)
{
    const std::string PACKAGE_VERSION_JSON = R"({
        "package": {
            "version": "1.2.3"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_VERSION_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.version, "1.2.3");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_TypeField)
{
    const std::string PACKAGE_TYPE_JSON = R"({
        "package": {
            "type": "rpm"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_TYPE_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.format, "rpm");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_ArchitectureField)
{
    const std::string PACKAGE_ARCH_JSON = R"({
        "package": {
            "architecture": "x86_64"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_ARCH_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.architecture, "x86_64");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_VendorField)
{
    const std::string PACKAGE_VENDOR_JSON = R"({
        "package": {
            "vendor": "Red Hat, Inc."
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_VENDOR_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.vendor, "Red Hat, Inc.");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_DescriptionField)
{
    const std::string PACKAGE_DESC_JSON = R"({
        "package": {
            "description": "A test package description"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_DESC_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.description, "A test package description");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_InstalledField)
{
    const std::string PACKAGE_INSTALLED_JSON = R"({
        "package": {
            "installed": "2023-08-04T19:56:11Z"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_INSTALLED_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.install_time, "2023-08-04T19:56:11Z");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_SizeField)
{
    const std::string PACKAGE_SIZE_JSON = R"({
        "package": {
            "size": 123456
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_SIZE_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.size, 123456);
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_SourceField)
{
    const std::string PACKAGE_SOURCE_JSON = R"({
        "package": {
            "source": "test-source-package"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_SOURCE_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.source, "test-source-package");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_PathField)
{
    const std::string PACKAGE_PATH_JSON = R"({
        "package": {
            "path": "/usr/lib/test-package.so"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_PATH_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.location, "/usr/lib/test-package.so");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_PriorityField)
{
    const std::string PACKAGE_PRIORITY_JSON = R"({
        "package": {
            "priority": "optional"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_PRIORITY_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.priority, "optional");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_MultiarchField)
{
    const std::string PACKAGE_MULTIARCH_JSON = R"({
        "package": {
            "multiarch": "same"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_MULTIARCH_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.multiarch, "same");
}

TEST_F(ScanOrchestratorTest, ExtractPackageInfo_CategoryField)
{
    const std::string PACKAGE_CATEGORY_JSON = R"({
        "package": {
            "category": "libs"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(PACKAGE_CATEGORY_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractPackageInfo(doc);

    EXPECT_EQ(result.groups, "libs");
}

// Tests for extractHotfixInfo method - One test per if statement
TEST_F(ScanOrchestratorTest, ExtractHotfixInfo_PackageField)
{
    const std::string HOTFIX_PACKAGE_JSON = R"({
        "package": {
            "hotfix": {
                "name": "KB5001234"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(HOTFIX_PACKAGE_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractHotfixInfo(doc);

    EXPECT_EQ(result.hotfixName, "KB5001234");
}

TEST_F(ScanOrchestratorTest, ExtractHotfixInfo_NullPackageField)
{
    const std::string HOTFIX_NULL_PACKAGE_JSON = R"({
        "package": null
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(HOTFIX_NULL_PACKAGE_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractHotfixInfo(doc);

    EXPECT_TRUE(result.hotfixName.empty());
}

TEST_F(ScanOrchestratorTest, ExtractHotfixInfo_HotfixField)
{
    const std::string HOTFIX_FIELD_JSON = R"({
        "package": {
            "hotfix": {
                "name": "KB9876543"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(HOTFIX_FIELD_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractHotfixInfo(doc);

    EXPECT_EQ(result.hotfixName, "KB9876543");
}

TEST_F(ScanOrchestratorTest, ExtractHotfixInfo_NullHotfixField)
{
    const std::string HOTFIX_NULL_HOTFIX_JSON = R"({
        "package": {
            "hotfix": null
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(HOTFIX_NULL_HOTFIX_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractHotfixInfo(doc);

    EXPECT_TRUE(result.hotfixName.empty());
}

TEST_F(ScanOrchestratorTest, ExtractHotfixInfo_NameField)
{
    const std::string HOTFIX_NAME_JSON = R"({
        "package": {
            "hotfix": {
                "name": "KB5005033"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(HOTFIX_NAME_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractHotfixInfo(doc);

    EXPECT_EQ(result.hotfixName, "KB5005033");
}

TEST_F(ScanOrchestratorTest, ExtractHotfixInfo_NullNameField)
{
    const std::string HOTFIX_NULL_NAME_JSON = R"({
        "package": {
            "hotfix": {
                "name": null
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(HOTFIX_NULL_NAME_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractHotfixInfo(doc);

    EXPECT_TRUE(result.hotfixName.empty());
}

TEST_F(ScanOrchestratorTest, ExtractHotfixInfo_NoHotfixField)
{
    const std::string HOTFIX_NO_HOTFIX_JSON = R"({
        "package": {
            "name": "some-package",
            "version": "1.0.0"
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(HOTFIX_NO_HOTFIX_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractHotfixInfo(doc);

    EXPECT_TRUE(result.hotfixName.empty());
}

// Test: extractHotfixInfo with hotfix but no name field
TEST_F(ScanOrchestratorTest, ExtractHotfixInfo_HotfixNoNameField)
{
    const std::string HOTFIX_NO_NAME_JSON = R"({
        "package": {
            "hotfix": {
                "other_field": "value"
            }
        }
    })";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(HOTFIX_NO_NAME_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractHotfixInfo(doc);

    EXPECT_TRUE(result.hotfixName.empty());
}

TEST_F(ScanOrchestratorTest, ExtractHotfixInfo_EmptyDocument)
{
    const std::string HOTFIX_EMPTY_JSON = R"({})";

    spFactoryOrchestratorMock = std::make_shared<MockFactoryOrchestrator>();
    auto spPackageDelta = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFirstFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    auto spFullScan = std::make_shared<MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>>();
    EXPECT_CALL(*spFactoryOrchestratorMock, create())
        .WillOnce(Return(spPackageDelta))
        .WillOnce(Return(spFirstFullScan))
        .WillOnce(Return(spFullScan));

    auto spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    std::shared_mutex mutexScanOrchestrator;

    TScanOrchestrator<TrampolineTScanContext,
                      TrampolineFactoryOrchestrator,
                      MockAbstractHandler<std::shared_ptr<TrampolineTScanContext>>,
                      MockIndexerConnector,
                      MockDatabaseFeedManager>
        scanOrchestrator(spIndexerConnectorMock, spDatabaseFeedManagerMock, mutexScanOrchestrator);

    thread_local simdjson::ondemand::parser parser;
    simdjson::padded_string paddedJson(HOTFIX_EMPTY_JSON);
    auto doc = parser.iterate(paddedJson).value();

    auto result = scanOrchestrator.extractHotfixInfo(doc);

    EXPECT_TRUE(result.hotfixName.empty());
}
