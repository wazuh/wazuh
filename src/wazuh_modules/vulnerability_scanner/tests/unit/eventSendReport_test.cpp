/*
 * Wazuh Send report test
 * Copyright (C) 2015, Wazuh Inc.
 * November 22, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "eventSendReport_test.hpp"
#include "../../src/scanOrchestrator/factory/eventSendReport.hpp"
#include "json.hpp"
#include <cstring>

using ::testing::_;

namespace NSEventSendReportTest
{
    // ECS event templates for testing
    const std::string ECS_PACKAGE_INSERT_EVENT = R"({
        "agent": {
            "id": "001",
            "name": "test-agent",
            "type": "Wazuh",
            "version": "4.5.0"
        },
        "vulnerability": {
            "id": "CVE-2020-14343",
            "severity": "Critical",
            "category": "Packages",
            "classification": "CVSS",
            "enumeration": "CVE",
            "description": "A vulnerability was discovered in the PyYAML library",
            "reference": "https://nvd.nist.gov/vuln/detail/CVE-2020-14343",
            "score": {
                "base": 9.8,
                "version": "3.1"
            }
        },
        "package": {
            "name": "PyYAML",
            "version": "5.3.1",
            "architecture": "amd64",
            "type": "pypi"
        }
    })";

    const std::string ECS_PACKAGE_DELETE_EVENT = R"({
        "agent": {
            "id": "001",
            "name": "focal"
        },
        "vulnerability": {
            "id": "CVE-2023-5441",
            "severity": "Medium",
            "category": "Packages",
            "enumeration": "CVE",
            "score": {
                "base": 6.2,
                "version": "3.0"
            }
        },
        "package": {
            "name": "vim",
            "version": "2:8.1.2269-1ubuntu5.21",
            "architecture": "amd64"
        }
    })";

    const std::string ECS_OS_VULNERABILITY_EVENT = R"({
        "agent": {
            "id": "001",
            "name": "focal"
        },
        "vulnerability": {
            "id": "CVE-2024-9999",
            "severity": "Critical",
            "category": "OS",
            "classification": "CVSS",
            "score": {
                "base": 9.8,
                "version": "3.1"
            }
        },
        "host": {
            "os": {
                "name": "SLES",
                "version": "15-SP5",
                "platform": "sles"
            }
        }
    })";

} // namespace NSEventSendReportTest

using namespace NSEventSendReportTest;

/**
 * @brief Test sending a formatted message with INSERT operation
 *
 * Simulates the original SendFormattedMsg test adapted to new API.
 * Verifies that detection with Upsert operation is properly sent.
 */
TEST_F(EventSendReportTest, SendFormattedMsg)
{
    TEventSendReport<ScanContext> sendReport;

    // Create scan context
    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add detection with INSERT operation
    const std::string detectionId = "001_pkg_CVE-2020-14343";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2020-14343";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->addECSEvent(detectionId, std::string(ECS_PACKAGE_INSERT_EVENT));

    // Execute - should complete without throwing
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify scanContext still has the detection registered
    EXPECT_EQ(scanContext->detectedCVEs().size(), 1);
    EXPECT_EQ(scanContext->ecsEventCount(), 1);
}

/**
 * @brief Test invalid encoding (skipping malformed data)
 *
 * Note: In new API, ECS events are pre-validated strings.
 * This test verifies graceful handling when detection has no ECS event.
 */
TEST_F(EventSendReportTest, InvalidEncodingValue)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add detection but with invalid/missing ECS event
    const std::string detectionId = "001_pkg_CVE-2020-14343";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2020-14343";
    detection.operation = ElementOperation::Delete;
    detection.componentType = AffectedComponentType::Package;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    // Intentionally NOT adding ECS event to simulate invalid data

    // Execute - should complete without throwing (no ECS event to send)
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));
}

/**
 * @brief Test sending formatted delta message (DELETE operation)
 *
 * Simulates the original SendFormattedDeltaMsg test adapted to new API.
 * Verifies that detection with Delete operation is properly sent.
 */
TEST_F(EventSendReportTest, SendFormattedDeltaMsg)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add detection with DELETE operation
    const std::string detectionId = "001_pkg_CVE-2023-5441";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2023-5441";
    detection.operation = ElementOperation::Delete;
    detection.componentType = AffectedComponentType::Package;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->addECSEvent(detectionId, std::string(ECS_PACKAGE_DELETE_EVENT));

    // Execute - should complete without throwing
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify scanContext still has the detection registered
    EXPECT_EQ(scanContext->detectedCVEs().size(), 1);
    EXPECT_EQ(scanContext->ecsEventCount(), 1);
}

/**
 * @brief Test sending formatted delta message for OS vulnerability
 *
 * Simulates the original SendFormattedDeltaMsgOS test adapted to new API.
 * Verifies that OS-level vulnerabilities are properly sent.
 */
TEST_F(EventSendReportTest, SendFormattedDeltaMsgOS)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.osname = "SLES";
    ctx.osversion = "15-SP5";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add OS vulnerability detection
    const std::string detectionId = "001_os_CVE-2024-9999";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-9999";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Os;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->addECSEvent(detectionId, std::string(ECS_OS_VULNERABILITY_EVENT));

    // Execute - should complete without throwing
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify scanContext still has the detection registered
    EXPECT_EQ(scanContext->detectedCVEs().size(), 1);
    EXPECT_EQ(scanContext->ecsEventCount(), 1);
}

/**
 * @brief Test sending formatted delta message for hotfix
 *
 * Note: In current API, hotfixes are treated as package-like components.
 * This test verifies handling of special component types.
 */
TEST_F(EventSendReportTest, SendFormattedDeltaMsgHotfix)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add hotfix/package detection
    const std::string detectionId = "001_hotfix_CVE-2024-1111";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-1111";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package; // Hotfixes as packages
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));

    // ECS event for hotfix
    const std::string hotfixECS = R"({
        "agent": {"id": "001", "name": "focal"},
        "vulnerability": {"id": "CVE-2024-1111", "category": "Packages"},
        "package": {"name": "KB123456", "type": "hotfix"}
    })";
    scanContext->addECSEvent(detectionId, std::string(hotfixECS));

    // Execute - should complete without throwing
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify scanContext still has the detection registered
    EXPECT_EQ(scanContext->detectedCVEs().size(), 1);
    EXPECT_EQ(scanContext->ecsEventCount(), 1);
}

/**
 * @brief Test sending multiple detections in one scan
 *
 * Verifies that multiple vulnerabilities can be sent in a single scan.
 */
/* TEST_F(EventSendReportTest, SendMultipleDetections)
{
    clearEnqueuedEvents();

    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add 3 detections with mixed operations
    for (int i = 1; i <= 3; ++i)
    {
        const std::string detectionId = "001_pkg_CVE-2024-" + std::to_string(i);
        CVEDetectionResult detection;
        detection.cveId = "CVE-2024-" + std::to_string(i);
        detection.operation = (i == 2) ? ElementOperation::Delete : ElementOperation::Upsert;
        detection.componentType = AffectedComponentType::Package;
        detection.cnaSource = "nvd";

        scanContext->addDetectedCVE(detectionId, std::move(detection));

        const std::string ecsEvent = R"({"vulnerability": {"id": "CVE-2024-)" + std::to_string(i) + R"("}})";
        scanContext->addECSEvent(detectionId, std::string(ecsEvent));
    }

    // Execute
    sendReport.handleRequest(scanContext);

    // Verify all events were sent
    const auto& events = getEnqueuedEvents();
    EXPECT_EQ(events.size(), 3);

    // Verify operations
    auto event1 = nlohmann::json::parse(events[0]);
    EXPECT_EQ(event1["operation"].get<std::string>(), "insert");

    auto event2 = nlohmann::json::parse(events[1]);
    EXPECT_EQ(event2["operation"].get<std::string>(), "delete");

    auto event3 = nlohmann::json::parse(events[2]);
    EXPECT_EQ(event3["operation"].get<std::string>(), "insert");
}*/

/**
 * @brief Test empty detections list
 *
 * Verifies that no events are sent when there are no detections.
 */
TEST_F(EventSendReportTest, EmptyDetectionsList)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Don't add any detections

    // Execute - should complete without throwing (no detections)
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));
}

/**
 * @brief Test partial detections (some with ECS, some without)
 *
 * Verifies that detections without ECS events are skipped gracefully
 * while others are still sent.
 */

TEST_F(EventSendReportTest, PartialDetectionsWithMissingECS)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add first detection WITH ECS
    const std::string detection1Id = "001_pkg_CVE-2024-1111";
    CVEDetectionResult detection1;
    detection1.cveId = "CVE-2024-1111";
    detection1.operation = ElementOperation::Upsert;
    detection1.componentType = AffectedComponentType::Package;
    detection1.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection1Id, std::move(detection1));
    scanContext->addECSEvent(detection1Id, std::string(ECS_PACKAGE_INSERT_EVENT));

    // Add second detection WITHOUT ECS (should be skipped)
    const std::string detection2Id = "001_pkg_CVE-2024-2222";
    CVEDetectionResult detection2;
    detection2.cveId = "CVE-2024-2222";
    detection2.operation = ElementOperation::Upsert;
    detection2.componentType = AffectedComponentType::Package;
    detection2.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection2Id, std::move(detection2));
    // NOT adding ECS for detection2

    // Add third detection WITH ECS
    const std::string detection3Id = "001_pkg_CVE-2024-3333";
    CVEDetectionResult detection3;
    detection3.cveId = "CVE-2024-3333";
    detection3.operation = ElementOperation::Delete;
    detection3.componentType = AffectedComponentType::Package;
    detection3.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection3Id, std::move(detection3));
    scanContext->addECSEvent(detection3Id, std::string(ECS_PACKAGE_DELETE_EVENT));

    // Execute - should complete without throwing
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify scanContext has all 3 detections registered
    EXPECT_EQ(scanContext->detectedCVEs().size(), 3);
    // Only 2 have ECS events
    EXPECT_EQ(scanContext->ecsEventCount(), 2);
}

/**
 * @brief Test mixed package and OS vulnerabilities
 *
 * Verifies that both package and OS vulnerabilities can be sent
 * in the same scan context.
 */
TEST_F(EventSendReportTest, MixedPackageAndOSVulnerabilities)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add package vulnerability
    const std::string pkgDetectionId = "001_pkg_CVE-2024-1111";
    CVEDetectionResult pkgDetection;
    pkgDetection.cveId = "CVE-2024-1111";
    pkgDetection.operation = ElementOperation::Upsert;
    pkgDetection.componentType = AffectedComponentType::Package;
    pkgDetection.cnaSource = "nvd";

    scanContext->addDetectedCVE(pkgDetectionId, std::move(pkgDetection));
    scanContext->addECSEvent(pkgDetectionId, std::string(ECS_PACKAGE_INSERT_EVENT));

    // Add OS vulnerability
    const std::string osDetectionId = "001_os_CVE-2024-9999";
    CVEDetectionResult osDetection;
    osDetection.cveId = "CVE-2024-9999";
    osDetection.operation = ElementOperation::Upsert;
    osDetection.componentType = AffectedComponentType::Os;
    osDetection.cnaSource = "nvd";

    scanContext->addDetectedCVE(osDetectionId, std::move(osDetection));
    scanContext->addECSEvent(osDetectionId, std::string(ECS_OS_VULNERABILITY_EVENT));

    // Execute - should complete without throwing
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify both detections are registered
    EXPECT_EQ(scanContext->detectedCVEs().size(), 2);
    EXPECT_EQ(scanContext->ecsEventCount(), 2);
}

/**
 * @brief Test HTTP request failure handling
 *
 * Verifies that when HTTP requests fail, the handler completes gracefully
 * with appropriate logging.
 */
TEST_F(EventSendReportTest, EnqueueFailureHandling)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add detection with valid ECS event
    const std::string detectionId = "001_pkg_CVE-2024-1111";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-1111";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->addECSEvent(detectionId, std::string(ECS_PACKAGE_INSERT_EVENT));

    // Execute - should complete without throwing even if HTTP request fails
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Note: This test verifies graceful handling of network/HTTP failures.
    // The actual HTTP failure would be logged but not throw an exception.
}

/**
 * @brief Test exception handling when JSON parsing fails
 *
 * Verifies that std::exception during JSON wrapping/parsing
 * is caught and logged without crashing.
 */
TEST_F(EventSendReportTest, JSONParsingExceptionHandling)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add detection with INVALID JSON (should throw parse exception)
    const std::string detectionId = "001_pkg_CVE-2024-1111";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-1111";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));

    // Add malformed JSON that will cause parse exception
    scanContext->addECSEvent(detectionId, std::string("{invalid json here}"));

    // Execute - should not throw, exception should be caught and logged
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Note: Invalid JSON parsing is caught and logged as warning,
    // but doesn't crash the handler.
}

/**
 * @brief Test multiple detections with mixed success and failures
 *
 * Verifies that when some detections fail, others still succeed.
 */
TEST_F(EventSendReportTest, MixedSuccessAndFailures)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add first detection - VALID
    const std::string detection1Id = "001_pkg_CVE-2024-1111";
    CVEDetectionResult detection1;
    detection1.cveId = "CVE-2024-1111";
    detection1.operation = ElementOperation::Upsert;
    detection1.componentType = AffectedComponentType::Package;
    detection1.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection1Id, std::move(detection1));
    scanContext->addECSEvent(detection1Id, std::string(ECS_PACKAGE_INSERT_EVENT));

    // Add second detection - INVALID JSON (should fail)
    const std::string detection2Id = "001_pkg_CVE-2024-2222";
    CVEDetectionResult detection2;
    detection2.cveId = "CVE-2024-2222";
    detection2.operation = ElementOperation::Upsert;
    detection2.componentType = AffectedComponentType::Package;
    detection2.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection2Id, std::move(detection2));
    scanContext->addECSEvent(detection2Id, std::string("INVALID_JSON"));

    // Add third detection - MISSING ECS (should be skipped)
    const std::string detection3Id = "001_pkg_CVE-2024-3333";
    CVEDetectionResult detection3;
    detection3.cveId = "CVE-2024-3333";
    detection3.operation = ElementOperation::Delete;
    detection3.componentType = AffectedComponentType::Package;
    detection3.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection3Id, std::move(detection3));
    // NOT adding ECS for detection3

    // Add fourth detection - VALID
    const std::string detection4Id = "001_pkg_CVE-2024-4444";
    CVEDetectionResult detection4;
    detection4.cveId = "CVE-2024-4444";
    detection4.operation = ElementOperation::Delete;
    detection4.componentType = AffectedComponentType::Package;
    detection4.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection4Id, std::move(detection4));
    scanContext->addECSEvent(detection4Id, std::string(ECS_PACKAGE_DELETE_EVENT));

    // Execute
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify all 4 detections are registered
    EXPECT_EQ(scanContext->detectedCVEs().size(), 4);
    // 3 ECS events were added (detection1, detection2, detection4), even though detection2 has invalid JSON
    EXPECT_EQ(scanContext->ecsEventCount(), 3);
}

/**
 * @brief Test outer catch-all exception handling
 *
 * Verifies that the outer catch(...) block handles unexpected exceptions.
 * This is tested by simulating a scenario that could throw from the outer try block.
 */
TEST_F(EventSendReportTest, OuterCatchAllExceptionHandling)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add multiple detections with mix of valid and invalid data
    for (int i = 1; i <= 3; ++i)
    {
        const std::string detectionId = "001_pkg_CVE-2024-" + std::to_string(i);
        CVEDetectionResult detection;
        detection.cveId = "CVE-2024-" + std::to_string(i);
        detection.operation = ElementOperation::Upsert;
        detection.componentType = AffectedComponentType::Package;
        detection.cnaSource = "nvd";

        scanContext->addDetectedCVE(detectionId, std::move(detection));

        if (i == 2)
        {
            // Add invalid JSON for middle detection
            scanContext->addECSEvent(detectionId, std::string("{malformed}"));
        }
        else
        {
            // Add valid JSON for others
            scanContext->addECSEvent(detectionId, std::string(ECS_PACKAGE_INSERT_EVENT));
        }
    }

    // Execute - should handle all exceptions gracefully
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify all 3 detections are registered
    EXPECT_EQ(scanContext->detectedCVEs().size(), 3);
    // All 3 have ECS events (even if one is malformed)
    EXPECT_EQ(scanContext->ecsEventCount(), 3);
}

/**
 * @brief Test HTTP socket failure handling
 *
 * Verifies that when the HTTP UNIX socket is unavailable or fails,
 * the handler completes gracefully with appropriate logging.
 */
TEST_F(EventSendReportTest, HTTPSocketFailureHandling)
{
    TEventSendReport<ScanContext> sendReport;

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add detection with valid ECS event
    const std::string detectionId = "001_pkg_CVE-2024-1111";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-1111";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->addECSEvent(detectionId, std::string(ECS_PACKAGE_INSERT_EVENT));

    // Execute - should not crash even if HTTP socket is unavailable
    // (will log warnings but continue processing)
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Note: HTTP failures are logged but don't throw exceptions,
    // allowing the scan to continue processing other detections.
}
