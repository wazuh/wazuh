/*
 * Wazuh Send report test
 * Copyright (C) 2015, Wazuh Inc.
 * November 22, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "eventSendReport_test.hpp"
#include "../../src/scanOrchestrator/factory/eventSendReport.hpp"
#include "MockReportDispatcher.hpp"
#include "json.hpp"
#include <cstring>

using ::testing::_;

// Mock implementation for batch_queue_enqueue_ex and events_queue
struct MockEventItem
{
    char* raw;
    size_t len;
};

static std::vector<std::string> g_enqueuedEvents;

extern "C"
{
    struct w_rr_queue
    {
    };
    w_rr_queue g_mockQueue;
    w_rr_queue* events_queue = &g_mockQueue;

    int batch_queue_enqueue_ex(w_rr_queue* /*sched*/, const char* /*agent_key*/, void* data)
    {
        auto* item = static_cast<MockEventItem*>(data);
        if (item && item->raw)
        {
            std::string payload(item->raw, item->len);
            g_enqueuedEvents.push_back(payload);

            // Free the memory as the real function would
            std::free(item->raw);
            std::free(item);
            return 0;
        }
        return -1;
    }
}

static void clearEnqueuedEvents()
{
    g_enqueuedEvents.clear();
}

static const std::vector<std::string>& getEnqueuedEvents()
{
    return g_enqueuedEvents;
}

namespace NSEventSendReportTest
{
    // ECS event templates for testing
    const std::string ECS_PACKAGE_INSERT_EVENT = R"({
        "agent": {
            "id": "001",
            "name": "test-agent",
            "type": "Wazuh",
            "version": "4.5.0"
        },
        "vulnerability": {
            "id": "CVE-2020-14343",
            "severity": "Critical",
            "category": "Packages",
            "classification": "CVSS",
            "enumeration": "CVE",
            "description": "A vulnerability was discovered in the PyYAML library",
            "reference": "https://nvd.nist.gov/vuln/detail/CVE-2020-14343",
            "score": {
                "base": 9.8,
                "version": "3.1"
            }
        },
        "package": {
            "name": "PyYAML",
            "version": "5.3.1",
            "architecture": "amd64",
            "type": "pypi"
        }
    })";

    const std::string ECS_PACKAGE_DELETE_EVENT = R"({
        "agent": {
            "id": "001",
            "name": "focal"
        },
        "vulnerability": {
            "id": "CVE-2023-5441",
            "severity": "Medium",
            "category": "Packages",
            "enumeration": "CVE",
            "score": {
                "base": 6.2,
                "version": "3.0"
            }
        },
        "package": {
            "name": "vim",
            "version": "2:8.1.2269-1ubuntu5.21",
            "architecture": "amd64"
        }
    })";

    const std::string ECS_OS_VULNERABILITY_EVENT = R"({
        "agent": {
            "id": "001",
            "name": "focal"
        },
        "vulnerability": {
            "id": "CVE-2024-9999",
            "severity": "Critical",
            "category": "OS",
            "classification": "CVSS",
            "score": {
                "base": 9.8,
                "version": "3.1"
            }
        },
        "host": {
            "os": {
                "name": "SLES",
                "version": "15-SP5",
                "platform": "sles"
            }
        }
    })";

} // namespace NSEventSendReportTest

using namespace NSEventSendReportTest;

/**
 * @brief Test sending a formatted message with INSERT operation
 *
 * Simulates the original SendFormattedMsg test adapted to new API.
 * Verifies that detection with Upsert operation is properly sent.
 */
TEST_F(EventSendReportTest, SendFormattedMsg)
{
    clearEnqueuedEvents();

    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<ScanContext, MockReportDispatcher> sendReport(reportDispatcher);

    // Create scan context
    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add detection with INSERT operation
    const std::string detectionId = "001_pkg_CVE-2020-14343";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2020-14343";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->addECSEvent(detectionId, std::string(ECS_PACKAGE_INSERT_EVENT));

    // Execute
    sendReport.handleRequest(scanContext);

    // Verify event was sent
    const auto& events = getEnqueuedEvents();
    ASSERT_EQ(events.size(), 1);

    auto wrapper = nlohmann::json::parse(events[0]);
    EXPECT_EQ(wrapper["operation"].get<std::string>(), "insert");
    EXPECT_TRUE(wrapper.contains("data"));
}

/**
 * @brief Test invalid encoding (skipping malformed data)
 *
 * Note: In new API, ECS events are pre-validated strings.
 * This test verifies graceful handling when detection has no ECS event.
 */
TEST_F(EventSendReportTest, InvalidEncodingValue)
{
    clearEnqueuedEvents();

    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<ScanContext, MockReportDispatcher> sendReport(reportDispatcher);

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add detection but with invalid/missing ECS event
    const std::string detectionId = "001_pkg_CVE-2020-14343";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2020-14343";
    detection.operation = ElementOperation::Delete;
    detection.componentType = AffectedComponentType::Package;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    // Intentionally NOT adding ECS event to simulate invalid data

    // Execute
    sendReport.handleRequest(scanContext);

    // Verify no event was sent (skipped due to missing ECS)
    const auto& events = getEnqueuedEvents();
    EXPECT_EQ(events.size(), 0);
}

/**
 * @brief Test sending formatted delta message (DELETE operation)
 *
 * Simulates the original SendFormattedDeltaMsg test adapted to new API.
 * Verifies that detection with Delete operation is properly sent.
 */
TEST_F(EventSendReportTest, SendFormattedDeltaMsg)
{
    clearEnqueuedEvents();

    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<ScanContext, MockReportDispatcher> sendReport(reportDispatcher);

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add detection with DELETE operation
    const std::string detectionId = "001_pkg_CVE-2023-5441";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2023-5441";
    detection.operation = ElementOperation::Delete;
    detection.componentType = AffectedComponentType::Package;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->addECSEvent(detectionId, std::string(ECS_PACKAGE_DELETE_EVENT));

    // Execute
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify event was sent
    const auto& events = getEnqueuedEvents();
    ASSERT_EQ(events.size(), 1);

    auto wrapper = nlohmann::json::parse(events[0]);
    EXPECT_EQ(wrapper["operation"].get<std::string>(), "delete");
}

/**
 * @brief Test sending formatted delta message for OS vulnerability
 *
 * Simulates the original SendFormattedDeltaMsgOS test adapted to new API.
 * Verifies that OS-level vulnerabilities are properly sent.
 */
TEST_F(EventSendReportTest, SendFormattedDeltaMsgOS)
{
    clearEnqueuedEvents();

    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<ScanContext, MockReportDispatcher> sendReport(reportDispatcher);

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.osname = "SLES";
    ctx.osversion = "15-SP5";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add OS vulnerability detection
    const std::string detectionId = "001_os_CVE-2024-9999";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-9999";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Os;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->addECSEvent(detectionId, std::string(ECS_OS_VULNERABILITY_EVENT));

    // Execute
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify event was sent
    const auto& events = getEnqueuedEvents();
    ASSERT_EQ(events.size(), 1);

    auto wrapper = nlohmann::json::parse(events[0]);
    EXPECT_EQ(wrapper["operation"].get<std::string>(), "insert");
    EXPECT_EQ(wrapper["data"]["vulnerability"]["category"].get<std::string>(), "OS");
}

/**
 * @brief Test sending formatted delta message for hotfix
 *
 * Note: In current API, hotfixes are treated as package-like components.
 * This test verifies handling of special component types.
 */
TEST_F(EventSendReportTest, SendFormattedDeltaMsgHotfix)
{
    clearEnqueuedEvents();

    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<ScanContext, MockReportDispatcher> sendReport(reportDispatcher);

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add hotfix/package detection
    const std::string detectionId = "001_hotfix_CVE-2024-1111";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-1111";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package; // Hotfixes as packages
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));

    // ECS event for hotfix
    const std::string hotfixECS = R"({
        "agent": {"id": "001", "name": "focal"},
        "vulnerability": {"id": "CVE-2024-1111", "category": "Packages"},
        "package": {"name": "KB123456", "type": "hotfix"}
    })";
    scanContext->addECSEvent(detectionId, std::string(hotfixECS));

    // Execute
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));

    // Verify event was sent
    const auto& events = getEnqueuedEvents();
    ASSERT_EQ(events.size(), 1);

    auto wrapper = nlohmann::json::parse(events[0]);
    EXPECT_EQ(wrapper["operation"].get<std::string>(), "insert");
}

/**
 * @brief Test sending multiple detections in one scan
 *
 * Verifies that multiple vulnerabilities can be sent in a single scan.
 */
TEST_F(EventSendReportTest, SendMultipleDetections)
{
    clearEnqueuedEvents();

    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<ScanContext, MockReportDispatcher> sendReport(reportDispatcher);

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add 3 detections with mixed operations
    for (int i = 1; i <= 3; ++i)
    {
        const std::string detectionId = "001_pkg_CVE-2024-" + std::to_string(i);
        CVEDetectionResult detection;
        detection.cveId = "CVE-2024-" + std::to_string(i);
        detection.operation = (i == 2) ? ElementOperation::Delete : ElementOperation::Upsert;
        detection.componentType = AffectedComponentType::Package;
        detection.cnaSource = "nvd";

        scanContext->addDetectedCVE(detectionId, std::move(detection));

        const std::string ecsEvent = R"({"vulnerability": {"id": "CVE-2024-)" + std::to_string(i) + R"("}})";
        scanContext->addECSEvent(detectionId, std::string(ecsEvent));
    }

    // Execute
    sendReport.handleRequest(scanContext);

    // Verify all events were sent
    const auto& events = getEnqueuedEvents();
    EXPECT_EQ(events.size(), 3);

    // Verify operations
    auto event1 = nlohmann::json::parse(events[0]);
    EXPECT_EQ(event1["operation"].get<std::string>(), "insert");

    auto event2 = nlohmann::json::parse(events[1]);
    EXPECT_EQ(event2["operation"].get<std::string>(), "delete");

    auto event3 = nlohmann::json::parse(events[2]);
    EXPECT_EQ(event3["operation"].get<std::string>(), "insert");
}

/**
 * @brief Test empty detections list
 *
 * Verifies that no events are sent when there are no detections.
 */
TEST_F(EventSendReportTest, EmptyDetectionsList)
{
    clearEnqueuedEvents();

    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<ScanContext, MockReportDispatcher> sendReport(reportDispatcher);

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Don't add any detections

    // Execute
    sendReport.handleRequest(scanContext);

    // Verify no events were sent
    const auto& events = getEnqueuedEvents();
    EXPECT_EQ(events.size(), 0);
}

/**
 * @brief Test partial detections (some with ECS, some without)
 *
 * Verifies that detections without ECS events are skipped gracefully
 * while others are still sent.
 */
TEST_F(EventSendReportTest, PartialDetectionsWithMissingECS)
{
    clearEnqueuedEvents();

    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<ScanContext, MockReportDispatcher> sendReport(reportDispatcher);

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add first detection WITH ECS
    const std::string detection1Id = "001_pkg_CVE-2024-1111";
    CVEDetectionResult detection1;
    detection1.cveId = "CVE-2024-1111";
    detection1.operation = ElementOperation::Upsert;
    detection1.componentType = AffectedComponentType::Package;
    detection1.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection1Id, std::move(detection1));
    scanContext->addECSEvent(detection1Id, std::string(ECS_PACKAGE_INSERT_EVENT));

    // Add second detection WITHOUT ECS (should be skipped)
    const std::string detection2Id = "001_pkg_CVE-2024-2222";
    CVEDetectionResult detection2;
    detection2.cveId = "CVE-2024-2222";
    detection2.operation = ElementOperation::Upsert;
    detection2.componentType = AffectedComponentType::Package;
    detection2.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection2Id, std::move(detection2));
    // NOT adding ECS for detection2

    // Add third detection WITH ECS
    const std::string detection3Id = "001_pkg_CVE-2024-3333";
    CVEDetectionResult detection3;
    detection3.cveId = "CVE-2024-3333";
    detection3.operation = ElementOperation::Delete;
    detection3.componentType = AffectedComponentType::Package;
    detection3.cnaSource = "nvd";

    scanContext->addDetectedCVE(detection3Id, std::move(detection3));
    scanContext->addECSEvent(detection3Id, std::string(ECS_PACKAGE_DELETE_EVENT));

    // Execute
    sendReport.handleRequest(scanContext);

    // Verify only 2 events sent (detection2 skipped)
    const auto& events = getEnqueuedEvents();
    EXPECT_EQ(events.size(), 2);
}

/**
 * @brief Test mixed package and OS vulnerabilities
 *
 * Verifies that both package and OS vulnerabilities can be sent
 * in the same scan context.
 */
TEST_F(EventSendReportTest, MixedPackageAndOSVulnerabilities)
{
    clearEnqueuedEvents();

    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<ScanContext, MockReportDispatcher> sendReport(reportDispatcher);

    Context ctx;
    ctx.agentId = "001";

    auto scanContext = std::make_shared<ScanContext>(ctx);

    // Add package vulnerability
    const std::string pkgDetectionId = "001_pkg_CVE-2024-1111";
    CVEDetectionResult pkgDetection;
    pkgDetection.cveId = "CVE-2024-1111";
    pkgDetection.operation = ElementOperation::Upsert;
    pkgDetection.componentType = AffectedComponentType::Package;
    pkgDetection.cnaSource = "nvd";

    scanContext->addDetectedCVE(pkgDetectionId, std::move(pkgDetection));
    scanContext->addECSEvent(pkgDetectionId, std::string(ECS_PACKAGE_INSERT_EVENT));

    // Add OS vulnerability
    const std::string osDetectionId = "001_os_CVE-2024-9999";
    CVEDetectionResult osDetection;
    osDetection.cveId = "CVE-2024-9999";
    osDetection.operation = ElementOperation::Upsert;
    osDetection.componentType = AffectedComponentType::Os;
    osDetection.cnaSource = "nvd";

    scanContext->addDetectedCVE(osDetectionId, std::move(osDetection));
    scanContext->addECSEvent(osDetectionId, std::string(ECS_OS_VULNERABILITY_EVENT));

    // Execute
    sendReport.handleRequest(scanContext);

    // Verify both events sent
    const auto& events = getEnqueuedEvents();
    EXPECT_EQ(events.size(), 2);

    // Both should be inserts
    for (const auto& event : events)
    {
        auto wrapper = nlohmann::json::parse(event);
        EXPECT_EQ(wrapper["operation"].get<std::string>(), "insert");
    }
}