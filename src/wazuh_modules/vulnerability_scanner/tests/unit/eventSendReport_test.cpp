/*
 * Wazuh Send report test
 * Copyright (C) 2015, Wazuh Inc.
 * November 22, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "eventSendReport_test.hpp"
#include "../scanOrchestrator/eventSendReport.hpp"
#include "MockOsDataCache.hpp"
#include "MockReportDispatcher.hpp"
#include "TrampolineOsDataCache.hpp"
#include "TrampolineRemediationDataCache.hpp"
#include "flatbuffers/idl.h"

using ::testing::_;

const size_t MAX_RETRIES {10};
auto constexpr TEST_REPORTS_QUEUE_PATH {"queue/vd/reports"};
auto constexpr TEST_REPORTS_BULK_SIZE {1};
auto constexpr TEST_REPORTS_THREADS_NUMBER {1};

namespace NSEventSendReportTest
{

    const std::string SYNC_STATE_MSG {
        R"(
            {
                "agent_info": {
                    "agent_id": "001",
                    "agent_ip": "192.168.33.20",
                    "agent_name": "focal"
                },
                "data_type": "state",
                "data": {
                    "attributes_type": "syscollector_packages",
                    "attributes": {
                        "architecture": " ",
                        "checksum": "d24e16553ac8f6983f16fb7a68b841ac8876d745",
                        "description": " ",
                        "format": "pypi",
                        "groups": " ",
                        "install_time": " ",
                        "item_id": "e051a99ad3950084b538c6538c0fcad0f1c4c713",
                        "location": "/usr/lib/python3/dist-packages/language_selector-0.1.egg-info/PKG-INFO",
                        "name": "language-selector",
                        "priority": " ",
                        "scan_time": "2023/12/01 20:48:21",
                        "size": 0,
                        "source": " ",
                        "vendor": " ",
                         "version": "0.1"
                    },
                    "index": "e051a99ad3950084b538c6538c0fcad0f1c4c713",
                }
            }
        )"};

    const std::string SYNC_STATE_ALERT {
        R"(
        {
            "vulnerability": {
                "category": "Packages",
                "classification": "CVSS",
                "cve": "CVE-2020-14343",
                "description": "A vulnerability was discovered in the PyYAML library in versions before 5.4, where it is susceptible to arbitrary code execution when it processes untrusted YAML files through the full_load method or with the FullLoader loader. Applications that use the library to process untrusted input may be vulnerable to this flaw. This flaw allows an attacker to execute arbitrary code on the system by abusing the python/object/new constructor. This flaw is due to an incomplete fix for CVE-2020-1747.",
                "enumeration": "CVE",
                "package": {
                    "architecture": " ",
                    "build_version": "",
                    "checksum": "",
                    "description": " ",
                    "install_scope": "",
                    "install_time": " ",
                    "license": "",
                    "name": "PyYAML",
                    "path": "/usr/lib/python3/dist-packages/PyYAML-5.3.1.egg-info",
                    "reference": "",
                    "size": 0,
                    "type": "pypi",
                    "version": "5.3.1"
                },
                "reference": "https://bugzilla.redhat.com/show_bug.cgi?id=1860466, https://github.com/SeldonIO/seldon-core/issues/2252, https://github.com/yaml/pyyaml/issues/420, https://www.oracle.com/security-alerts/cpuapr2022.html, https://www.oracle.com/security-alerts/cpujul2022.html",
                "score": {
                    "base": 9.800000190734863,
                    "environmental": 0.0,
                    "temporal": 0.0,
                    "version": "3.1"
                },
                "severity": "Critical",
                "status": "Active"
            }
        }
    )"};

    const std::string DELTA_DELETE_MSG {
        R"(
            {
                "agent_info": {
                    "agent_id": "001",
                    "agent_ip": "192.168.33.20",
                    "agent_name": "focal"
                },
                "data_type": "dbsync_packages",
                "data": {
                    "architecture": "amd64",
                    "checksum": "dfc12dd72d4b32c6b2c6b598c1999f8578c2ee89",
                    "description": "Text editor",
                    "format": "deb",
                    "groups": "editors",
                    "item_id": "772cafce68754b17864ade66be2d66730b5706e4",
                    "multiarch": "foreign",
                    "name": "vim",
                    "priority": "important",
                    "scan_time": "2023/08/04 20:03:45",
                    "size": 205,
                    "source": "vim",
                    "vendor": "Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>",
                    "version": "2:8.1.2269-1ubuntu5.21"
                },
                "operation": "DELETED"
            }
    )"};

    const std::string DELTA_DELETE_ALERT {
        R"(
            {
                "vulnerability": {
                    "category": "Packages",
                    "classification": "CVSS",
                    "cve": "CVE-2023-5441",
                    "description": "NULL Pointer Dereference in GitHub repository vim/vim prior to 20d161ace307e28690229b68584f2d84556f8960.",
                    "enumeration": "CVE",
                    "package": {
                        "architecture": "amd64",
                        "name": "vim",
                        "version": "2:8.1.2269-1ubuntu5.21"
                    },
                    "reference": "https://huntr.dev/bounties/b54cbdf5-3e85-458d-bb38-9ea2c0b669f2, https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VDDWD25AZIHBAA44HQT75OWLQ5UMDKU3/, https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VGTVLUV7UCXXCZAIQIUCLG6JXAVYT3HE/, https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XPT7NMYJRLBPIALGSE24UWTY6F774GZW/, https://github.com/vim/vim/commit/20d161ace307e28690229b68584f2d84556f8960",
                    "score": {
                    "base": "6.200000",
                    "version": "3.0"
                    },
                    "severity": "Medium",
                    "status": "Solved"
                }
            }
        )"};

    const std::string DELTA_INSERT_OS {
        R"({
          "agent_info": {
            "agent_id": "001",
            "agent_ip": "192.168.33.20",
            "agent_name": "focal"
          },
          "data_type": "dbsync_osinfo",
          "data": {
              "architecture":"x86_64",
              "checksum":"1691178971959743855",
              "hostname":"fd9b83c25f30",
              "os_major":"15",
              "os_name":"SLES",
              "os_platform":"sles",
              "os_version":"15-SP5",
              "release":"5.4.0-155-generic",
              "scan_time":"2023/08/04 19:56:11",
              "sysname":"Linux",
              "version":"#172-Ubuntu SMP Fri Jul 7 16:10:02 UTC 2023"
          },
          "operation": "INSERTED"
       })"};

    const std::string DELTA_UPDATE_HOTFIX {
        R"({
          "agent_info": {
            "agent_id": "001",
            "agent_ip": "192.168.33.20",
            "agent_name": "focal"
          },
          "data_type":"dbsync_hotfixes",
          "data":
          {
             "hotfix":"KB123456",
             "checksum":"abcdef0123456789"
          },
          "operation":"MODIFIED"
        })"};

    // Helpers

    const Os osData {.hostName = "osdata_hostname",
                     .architecture = "osdata_architecture",
                     .name = "osdata_name",
                     .codeName = "osdata_codeName",
                     .majorVersion = "osdata_majorVersion",
                     .minorVersion = "osdata_minorVersion",
                     .patch = "osdata_patch",
                     .build = "osdata_build",
                     .platform = "osdata_platform",
                     .version = "osdata_version",
                     .release = "osdata_release",
                     .displayVersion = "osdata_displayVersion",
                     .sysName = "osdata_sysName",
                     .kernelVersion = "osdata_kernelVersion",
                     .kernelRelease = "osdata_kernelRelease"};

    void expectOsData()
    {
        spOsDataCacheMock = std::make_shared<MockOsDataCache>();
        EXPECT_CALL(*spOsDataCacheMock, getOsData(_, _))
            .WillOnce(testing::Invoke(
                [](const std::string&, Os& osDataResult)
                {
                    osDataResult = osData;
                    return true;
                }));
    }

} // namespace NSEventSendReportTest

using namespace NSEventSendReportTest;

TEST_F(EventSendReportTest, SendFormattedMsg)
{
    // Mock report dispatcher.
    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    // Send report instance.
    TEventSendReport<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                     MockReportDispatcher>
        sendReport(reportDispatcher);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    // Mock scanContext.
    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(rsync_SCHEMA));
    ASSERT_TRUE(parser.Parse(SYNC_STATE_MSG.c_str()));
    const uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorSync = Synchronization::GetSyncMsg(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorSync);
    
    // Use new API: add detection and ECS event
    CVEDetectionResult detection;
    detection.cveId = "CVE-2020-14343";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    std::string detectionId = "001_test_detection_CVE-2020-14343";
    scanContext->addDetectedCVE(detectionId, std::move(detection));
    
    // Add ECS event (simulating what EventDetailsBuilder would produce)
    nlohmann::json ecsEvent = nlohmann::json::parse(SYNC_STATE_ALERT);
    scanContext->addECSEvent(detectionId, ecsEvent.dump());

    EXPECT_CALL(*reportDispatcher, push(_)).Times(1);

    // Send report.
    sendReport.handleRequest(scanContext);
}

// Test removed: InvalidEncodingValue
// This test is no longer relevant because EventSendReport now receives pre-built
// ECS JSON from EventDetailsBuilder. Encoding validation happens during ECS event
// construction, not during report sending.

TEST_F(EventSendReportTest, SendFormattedDeltaMsg)
{
    // Mock report dispatcher.
    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    // Send report instance.
    TEventSendReport<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                     MockReportDispatcher>
        sendReport(reportDispatcher);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    // Mock scanContext.
    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_DELETE_MSG.c_str()));
    const uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    
    // Use new API: add detection with DELETE operation and ECS event
    CVEDetectionResult detection;
    detection.cveId = "CVE-2023-5441";
    detection.operation = ElementOperation::Delete;  // DELETE operation
    detection.componentType = AffectedComponentType::Package;
    std::string detectionId = "001_test_detection_CVE-2023-5441";
    scanContext->addDetectedCVE(detectionId, std::move(detection));
    
    // Add ECS event
    nlohmann::json ecsEvent = nlohmann::json::parse(DELTA_DELETE_ALERT);
    scanContext->addECSEvent(detectionId, ecsEvent.dump());

    EXPECT_CALL(*reportDispatcher, push(_)).Times(1);

    // Send report.
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));
}

TEST_F(EventSendReportTest, SendFormattedDeltaMsgOS)
{
    // Mock report dispatcher.
    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    // Send report instance.
    TEventSendReport<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                     MockReportDispatcher>
        sendReport(reportDispatcher);

    Os osData {.hostName = "osdata_hostname",
               .architecture = "osdata_architecture",
               .name = "osdata_name",
               .codeName = "osdata_codeName",
               .majorVersion = "osdata_majorVersion",
               .minorVersion = "osdata_minorVersion",
               .patch = "osdata_patch",
               .build = "osdata_build",
               .platform = "osdata_platform",
               .version = "osdata_version",
               .release = "osdata_release",
               .displayVersion = "osdata_displayVersion",
               .sysName = "osdata_sysName",
               .kernelVersion = "osdata_kernelVersion",
               .kernelRelease = "osdata_kernelRelease"};

    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    EXPECT_CALL(*spOsDataCacheMock, setOsData(_, _)).Times(1);

    // Mock scanContext.
    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_INSERT_OS.c_str()));
    const uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    
    // Use new API: add OS detection and ECS event
    CVEDetectionResult detection;
    detection.cveId = "CVE-2023-5441";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Os;  // OS type
    std::string detectionId = "001_osdata_name_CVE-2023-5441";
    scanContext->addDetectedCVE(detectionId, std::move(detection));
    
    // Add minimal ECS event for OS
    nlohmann::json ecsEvent;
    ecsEvent["vulnerability"]["id"] = "CVE-2023-5441";
    ecsEvent["vulnerability"]["category"] = "OS";
    scanContext->addECSEvent(detectionId, ecsEvent.dump());

    EXPECT_CALL(*reportDispatcher, push(_)).Times(1);

    // Send report.
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));
}

TEST_F(EventSendReportTest, SendFormattedDeltaMsgHotfix)
{
    // Mock report dispatcher.
    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    // Send report instance.
    TEventSendReport<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                     MockReportDispatcher>
        sendReport(reportDispatcher);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    // Mock scanContext.
    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_UPDATE_HOTFIX.c_str()));
    const uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    
    // Use new API: add Hotfix detection and ECS event
    CVEDetectionResult detection;
    detection.cveId = "CVE-2023-5441";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Hotfix;
    std::string detectionId = "001_hotfix_CVE-2023-5441";
    scanContext->addDetectedCVE(detectionId, std::move(detection));
    
    // Add minimal ECS event for Hotfix
    nlohmann::json ecsEvent;
    ecsEvent["vulnerability"]["id"] = "CVE-2023-5441";
    ecsEvent["vulnerability"]["category"] = "Hotfix";
    scanContext->addECSEvent(detectionId, ecsEvent.dump());

    EXPECT_CALL(*reportDispatcher, push(_)).Times(1);

    // Send report.
    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));
}

TEST_F(EventSendReportTest, HandleRequestWithoutEcsEventsSkipsPush)
{
    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                     MockReportDispatcher>
        sendReport(reportDispatcher);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_DELETE_MSG.c_str()));
    const uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);

    CVEDetectionResult detection;
    detection.cveId = "CVE-TEST";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    scanContext->addDetectedCVE("detection_id", std::move(detection));

    EXPECT_CALL(*reportDispatcher, push(_)).Times(0);

    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));
}

TEST_F(EventSendReportTest, SendMultipleDetectionsInSameContext)
{
    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                     MockReportDispatcher>
        sendReport(reportDispatcher);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_DELETE_MSG.c_str()));
    const uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);

    // Add multiple detections with different types and operations
    CVEDetectionResult detection1;
    detection1.cveId = "CVE-2023-1111";
    detection1.operation = ElementOperation::Upsert;
    detection1.componentType = AffectedComponentType::Package;
    scanContext->addDetectedCVE("001_package_CVE-2023-1111", std::move(detection1));
    nlohmann::json ecs1;
    ecs1["vulnerability"]["id"] = "CVE-2023-1111";
    scanContext->addECSEvent("001_package_CVE-2023-1111", ecs1.dump());

    CVEDetectionResult detection2;
    detection2.cveId = "CVE-2023-2222";
    detection2.operation = ElementOperation::Delete;
    detection2.componentType = AffectedComponentType::Package;
    scanContext->addDetectedCVE("002_package_CVE-2023-2222", std::move(detection2));
    nlohmann::json ecs2;
    ecs2["vulnerability"]["id"] = "CVE-2023-2222";
    scanContext->addECSEvent("002_package_CVE-2023-2222", ecs2.dump());

    CVEDetectionResult detection3;
    detection3.cveId = "CVE-2023-3333";
    detection3.operation = ElementOperation::Upsert;
    detection3.componentType = AffectedComponentType::Os;
    scanContext->addDetectedCVE("003_os_CVE-2023-3333", std::move(detection3));
    nlohmann::json ecs3;
    ecs3["vulnerability"]["id"] = "CVE-2023-3333";
    scanContext->addECSEvent("003_os_CVE-2023-3333", ecs3.dump());

    // Expect 3 pushes for 3 detections with ECS events
    EXPECT_CALL(*reportDispatcher, push(_)).Times(3);

    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));
}

TEST_F(EventSendReportTest, MixedDetectionsWithAndWithoutEcsEvents)
{
    auto reportDispatcher = std::make_shared<MockReportDispatcher>();
    TEventSendReport<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>,
                     MockReportDispatcher>
        sendReport(reportDispatcher);

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_DELETE_MSG.c_str()));
    const uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContext =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);

    // Add detection with ECS event
    CVEDetectionResult detection1;
    detection1.cveId = "CVE-2023-WITH-ECS";
    detection1.operation = ElementOperation::Upsert;
    detection1.componentType = AffectedComponentType::Package;
    scanContext->addDetectedCVE("detection_with_ecs", std::move(detection1));
    nlohmann::json ecs1;
    ecs1["vulnerability"]["id"] = "CVE-2023-WITH-ECS";
    scanContext->addECSEvent("detection_with_ecs", ecs1.dump());

    // Add detection WITHOUT ECS event
    CVEDetectionResult detection2;
    detection2.cveId = "CVE-2023-WITHOUT-ECS";
    detection2.operation = ElementOperation::Upsert;
    detection2.componentType = AffectedComponentType::Package;
    scanContext->addDetectedCVE("detection_without_ecs", std::move(detection2));

    // Expect only 1 push (for detection with ECS event)
    EXPECT_CALL(*reportDispatcher, push(_)).Times(1);

    EXPECT_NO_THROW(sendReport.handleRequest(scanContext));
}
