/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * January 15, 2026.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "buildAllAgentListContext_test.hpp"
#include "../mocks/globalMocks.hpp"
#include "../scanOrchestrator/buildAllAgentListContext.hpp"
#include "MockSocketDBWrapper.hpp"
#include "TrampolineSocketDBWrapper.hpp"
#include "json.hpp"
#include "socketDBWrapperException.hpp"

using ::testing::_;
using ::testing::Invoke;

void BuildAllAgentListContextTest::SetUp()
{
    spSocketDBWrapperMock = std::make_shared<MockSocketDBWrapper>();
}

void BuildAllAgentListContextTest::TearDown()
{
    ScanContext::setClusterInfo("", "");
    ScanContext::setClusterRole(false);
    spSocketDBWrapperMock.reset();
}

TEST_F(BuildAllAgentListContextTest, ReturnsNullOnNullContext)
{
    TBuildAllAgentListContext<ScanContext, TrampolineSocketDBWrapper> builder;
    EXPECT_CALL(*spSocketDBWrapperMock, query(_, _)).Times(0);
    EXPECT_EQ(builder.handleRequest(nullptr), nullptr);
}

TEST_F(BuildAllAgentListContextTest, ReturnsNullOnSocketDbException)
{
    TBuildAllAgentListContext<ScanContext, TrampolineSocketDBWrapper> builder;

    EXPECT_CALL(*spSocketDBWrapperMock, query(_, _))
        .WillOnce(Invoke([](const std::string&, nlohmann::json&) { throw SocketDbWrapperException("boom"); }));

    auto data = std::make_shared<ScanContext>();
    EXPECT_EQ(builder.handleRequest(data), nullptr);
}

TEST_F(BuildAllAgentListContextTest, ReturnsNullOnStdException)
{
    TBuildAllAgentListContext<ScanContext, TrampolineSocketDBWrapper> builder;

    EXPECT_CALL(*spSocketDBWrapperMock, query(_, _))
        .WillOnce(Invoke([](const std::string&, nlohmann::json&) { throw std::runtime_error("boom"); }));

    auto data = std::make_shared<ScanContext>();
    EXPECT_EQ(builder.handleRequest(data), nullptr);
}

TEST_F(BuildAllAgentListContextTest, WorkerFiltersActiveAgentsByNode)
{
    ScanContext::setClusterInfo("wazuh", "nodeA");
    ScanContext::setClusterRole(true);

    nlohmann::json response = nlohmann::json::array(
        {{{"id", 1},
          {"name", "agent1"},
          {"version", "Wazuh v5.0.0"},
          {"os_arch", "x86_64"},
          {"os_uname", "Linux"},
          {"connection_status", "active"},
          {"node_name", "nodeA"}},
         {{"id", 2}, {"name", "agent2"}, {"connection_status", "active"}, {"node_name", "nodeB"}},
         {{"id", 3}, {"name", "agent3"}, {"connection_status", "disconnected"}, {"node_name", "nodeA"}},
         {{"id", "4"}, {"name", "agent4"}, {"connection_status", "active"}, {"node_name", "nodeA"}}});

    EXPECT_CALL(*spSocketDBWrapperMock, query(_, _))
        .WillOnce(Invoke([&](const std::string&, nlohmann::json& out) { out = response; }));

    auto data = std::make_shared<ScanContext>();
    TBuildAllAgentListContext<ScanContext, TrampolineSocketDBWrapper> builder;
    auto result = builder.handleRequest(data);

    ASSERT_NE(result, nullptr);
    ASSERT_EQ(result->m_agents.size(), 2u);
    EXPECT_EQ(result->m_agents[0].id, "001");
    EXPECT_EQ(result->m_agents[0].hostArchitecture, "x86_64");
    EXPECT_EQ(result->m_agents[0].hostHostname, "agent1");
    EXPECT_EQ(result->m_agents[0].hostOsType, "Linux");
    EXPECT_EQ(result->m_agents[0].version, "v5.0.0");
    EXPECT_EQ(result->m_agents[1].id, "004");
}

TEST_F(BuildAllAgentListContextTest, WorkerSkipsAgentsWhenNodeNameMissing)
{
    ScanContext::setClusterInfo("wazuh", "");
    ScanContext::setClusterRole(true);

    nlohmann::json response = nlohmann::json::array({
        {{"id", true}, {"connection_status", "active"}, {"node_name", "nodeA"}},
        {{"id", 1}, {"name", "agent1"}, {"connection_status", "active"}, {"node_name", "nodeA"}},
    });

    EXPECT_CALL(*spSocketDBWrapperMock, query(_, _))
        .WillOnce(Invoke([&](const std::string&, nlohmann::json& out) { out = response; }));

    auto data = std::make_shared<ScanContext>();
    TBuildAllAgentListContext<ScanContext, TrampolineSocketDBWrapper> builder;
    auto result = builder.handleRequest(data);

    ASSERT_NE(result, nullptr);
    EXPECT_TRUE(result->m_agents.empty());
}

TEST_F(BuildAllAgentListContextTest, MasterIncludesDisconnectedAgents)
{
    ScanContext::setClusterInfo("wazuh", "nodeA");
    ScanContext::setClusterRole(false);

    nlohmann::json response = nlohmann::json::array(
        {{{"id", 1}, {"name", "agent1"}, {"connection_status", "active"}, {"node_name", "nodeA"}},
         {{"id", 2}, {"name", "agent2"}, {"connection_status", "active"}, {"node_name", "nodeB"}},
         {{"id", "2"}, {"name", "agent3"}, {"connection_status", "disconnected"}, {"node_name", "nodeB"}}});

    EXPECT_CALL(*spSocketDBWrapperMock, query(_, _))
        .WillOnce(Invoke([&](const std::string&, nlohmann::json& out) { out = response; }));

    auto data = std::make_shared<ScanContext>();
    TBuildAllAgentListContext<ScanContext, TrampolineSocketDBWrapper> builder;
    auto result = builder.handleRequest(data);

    ASSERT_NE(result, nullptr);
    ASSERT_EQ(result->m_agents.size(), 2u);
    EXPECT_EQ(result->m_agents[0].id, "001");
    EXPECT_EQ(result->m_agents[1].id, "002");
}

TEST_F(BuildAllAgentListContextTest, MasterIncludesActiveWithGroupsAndSkipsInvalidId)
{
    ScanContext::setClusterInfo("wazuh", "");
    ScanContext::setClusterRole(false);

    nlohmann::json response = nlohmann::json::array({
        {{"id", "7"},
         {"name", "agent7"},
         {"connection_status", "active"},
         {"group", "default"},
         {"groups", {"extra"}},
         {"os_arch", "arm64"},
         {"os_uname", "Linux"}},
        {{"name", "agentX"}, {"connection_status", "active"}},
    });

    EXPECT_CALL(*spSocketDBWrapperMock, query(_, _))
        .WillOnce(Invoke([&](const std::string&, nlohmann::json& out) { out = response; }));

    auto data = std::make_shared<ScanContext>();
    TBuildAllAgentListContext<ScanContext, TrampolineSocketDBWrapper> builder;
    auto result = builder.handleRequest(data);

    ASSERT_NE(result, nullptr);
    ASSERT_EQ(result->m_agents.size(), 1u);
    EXPECT_EQ(result->m_agents[0].id, "007");
    EXPECT_EQ(result->m_agents[0].hostArchitecture, "arm64");
    EXPECT_EQ(result->m_agents[0].hostHostname, "agent7");
    EXPECT_EQ(result->m_agents[0].hostOsType, "Linux");
    ASSERT_EQ(result->m_agents[0].groups.size(), 2u);
    EXPECT_EQ(result->m_agents[0].groups[0], "default");
    EXPECT_EQ(result->m_agents[0].groups[1], "extra");
}

TEST_F(BuildAllAgentListContextTest, MasterKeepsNumericStringIdWithThreeDigits)
{
    ScanContext::setClusterInfo("wazuh", "");
    ScanContext::setClusterRole(false);

    nlohmann::json response = nlohmann::json::array({
        {{"id", "987"},
         {"name", "agent987"},
         {"hostname", "host987"},
         {"architecture", "arm64"},
         {"os_arch", "x86_64"},
         {"os_type", "Darwin"},
         {"os_uname", "DarwinKernel"},
         {"connection_status", "active"},
         {"group", "default"},
         {"groups", {"extra", 7}}},
    });

    EXPECT_CALL(*spSocketDBWrapperMock, query(_, _))
        .WillOnce(Invoke([&](const std::string&, nlohmann::json& out) { out = response; }));

    auto data = std::make_shared<ScanContext>();
    TBuildAllAgentListContext<ScanContext, TrampolineSocketDBWrapper> builder;
    auto result = builder.handleRequest(data);

    ASSERT_NE(result, nullptr);
    ASSERT_EQ(result->m_agents.size(), 1u);
    EXPECT_EQ(result->m_agents[0].id, "987");
    EXPECT_EQ(result->m_agents[0].hostArchitecture, "arm64");
    EXPECT_EQ(result->m_agents[0].hostHostname, "host987");
    EXPECT_EQ(result->m_agents[0].hostOsType, "Darwin");
    ASSERT_EQ(result->m_agents[0].groups.size(), 2u);
    EXPECT_EQ(result->m_agents[0].groups[0], "default");
    EXPECT_EQ(result->m_agents[0].groups[1], "extra");
}
