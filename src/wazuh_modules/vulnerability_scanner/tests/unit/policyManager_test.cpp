/*
 * Wazuh PolicyManager
 * Copyright (C) 2015, Wazuh Inc.
 * September 8, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */
#include "policyManager_test.h"

void PolicyManagerTest::SetUp()
{
    m_policyManager = std::make_unique<PolicyManager>();
};

void PolicyManagerTest::TearDown() {};

TEST_F(PolicyManagerTest, invalidConfigurationIDWithVD)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "feed-update-interval": "60m",
        "offline-url": "file:///var/algo.tar.gz"
      },
      "indexer": {
        "enabled": "no",
        "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
        "username": "user",
        "password": "pwd",
        "ssl": {
          "certificate_authorities": ["/var/ossec/"],
          "certificate": "cert",
          "key": ""
        }
      }
    })")};
    EXPECT_THROW(m_policyManager->validateConfiguration(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidConfigurationURLFeed)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "feed-update-interval": "60m",
        "offline-url": "www:///var/algo.tar.gz"
      },
      "indexer": {
        "enabled": "yes",
        "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
        "username": "user",
        "password": "pwd",
        "ssl": {
          "certificate_authorities": ["/var/ossec/"],
          "certificate": "cert",
          "key": ""
        }
      }
    })")};
    EXPECT_THROW(m_policyManager->validateConfiguration(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidConfigurationNegativeTime)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "feed-update-interval": "-10m",
        "offline-url": "http:///var/algo.tar.gz"
      },
      "indexer": {
        "enabled": "yes",
        "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
        "username": "user",
        "password": "pwd",
        "ssl": {
          "certificate_authorities": ["/var/ossec/"],
          "certificate": "cert",
          "key": ""
        }
      }
    })")};
    EXPECT_THROW(m_policyManager->validateConfiguration(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidConfigurationIDWithTypo)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "feed-update-interval": "60m",
        "offline-url": "file:///var/algo.tar.gz"
      },
      "indexer": {
        "enable": "yes",
        "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
        "username": "user",
        "password": "pwd",
        "ssl": {
          "certificate_authorities": ["/var/ossec/"],
          "certificate": "cert",
          "key": ""
        }
      }
    })")};
    EXPECT_THROW(m_policyManager->validateConfiguration(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidConfigurationVDWithTypo)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enable": "yes",
        "index-status": "yes",
        "feed-update-interval": "60m",
        "offline-url": "file:///var/algo.tar.gz"
      },
      "indexer": {
        "enabled": "yes",
        "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
        "username": "user",
        "password": "pwd",
        "ssl": {
          "certificate_authorities": ["/var/ossec/"],
          "certificate": "cert",
          "key": ""
        }
      }
    })")};
    EXPECT_THROW(m_policyManager->validateConfiguration(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, invalidConfigurationVDWithoutIDStatus)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index": "yes",
        "feed-update-interval": "60m",
        "offline-url": "file:///var/algo.tar.gz"
      },
      "indexer": {
        "enabled": "yes",
        "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
        "username": "user",
        "password": "pwd",
        "ssl": {
          "certificate_authorities": ["/var/ossec/"],
          "certificate": "cert",
          "key": ""
        }
      }
    })")};
    EXPECT_THROW(m_policyManager->validateConfiguration(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, validConfigurationCheckParameters)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "feed-update-interval": "60m",
        "cti-url": "https://cti-url.com"
      },
      "indexer": {
        "enabled": "yes",
        "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
        "username": "ImGroot",
        "password": "MoreSecurePassword123",
        "ssl": {
          "certificate_authorities": ["/var/ossec/"],
          "certificate": "cert",
          "key": "ItsASecret!"
        }
      },
      "translationLRUSize": 5000,
      "osdataLRUSize": 6000,
      "clusterName":"clusterName",
      "clusterEnabled":false,
      "remediationLRUSize": 7000
    })")};
    EXPECT_NO_THROW(m_policyManager->initialize(configJson));

    EXPECT_TRUE(m_policyManager->isVulnerabilityDetectionEnabled());
    EXPECT_TRUE(m_policyManager->isIndexerEnabled());

    EXPECT_EQ(m_policyManager->getFeedUpdateTime(), 3600);

    EXPECT_EQ(m_policyManager->getHostList().count("http://10.2.20.2:9200"), 1);
    EXPECT_EQ(m_policyManager->getHostList().count("https://10.2.20.42:9200"), 1);

    EXPECT_STREQ(m_policyManager->getUsername().c_str(), "ImGroot");
    EXPECT_STREQ(m_policyManager->getPassword().c_str(), "MoreSecurePassword123");

    EXPECT_EQ(m_policyManager->getCAList().count("/var/ossec/"), 1);

    EXPECT_STREQ(m_policyManager->getCertificate().c_str(), "cert");
    EXPECT_STREQ(m_policyManager->getKey().c_str(), "ItsASecret!");

    EXPECT_STREQ(m_policyManager->getCTIUrl().c_str(), "https://cti-url.com");
    EXPECT_STREQ(
        m_policyManager->getUpdaterConfiguration().dump().c_str(),
        R"({"configData":{"compressionType":"raw","consumerName":"Wazuh VulnerabilityDetector","contentFileName":"api_file.json","contentSource":"cti-offset","databasePath":"queue/vd_updater/rocksdb","deleteDownloadedContent":true,"offset":0,"outputFolder":"queue/vd_updater/tmp","url":"https://cti-url.com","versionedContent":"false"},"interval":3600,"ondemand":true,"topicName":"vulnerability_feed_manager"})");
    EXPECT_EQ(m_policyManager->getTranslationLRUSize(), 5000);
    EXPECT_EQ(m_policyManager->getOsdataLRUSize(), 6000);
    EXPECT_EQ(m_policyManager->getRemediationLRUSize(), 7000);
}

TEST_F(PolicyManagerTest, validConfigurationCheckParametersOffline)
{
    // The cti-url parameter is ignored if the content source is offline.
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "no",
        "offline-url": "file:///var/algo.tar.gz",
        "cti-url": "https://cti-url.com"
      },
      "clusterName":"clusterName",
      "clusterEnabled":false
    })")};
    EXPECT_NO_THROW(m_policyManager->initialize(configJson));

    EXPECT_TRUE(m_policyManager->isVulnerabilityDetectionEnabled());

    EXPECT_STREQ(m_policyManager->getFeedUrl().c_str(), "file:///var/algo.tar.gz");
    EXPECT_EQ(m_policyManager->getFeedUpdateTime(), 3600);

    EXPECT_STREQ(
        m_policyManager->getUpdaterConfiguration().dump().c_str(),
        R"({"configData":{"compressionType":"raw","consumerName":"Wazuh VulnerabilityDetector","contentSource":"offline","databasePath":"queue/vd_updater/rocksdb","deleteDownloadedContent":true,"offset":0,"outputFolder":"queue/vd_updater/tmp","url":"file:///var/algo.tar.gz","versionedContent":"false"},"interval":3600,"ondemand":true,"topicName":"vulnerability_feed_manager"})");
}

TEST_F(PolicyManagerTest, validConfigurationNoCluster)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "cti-url": "cti-url.com"
      },
      "indexer": {
        "enabled": "yes"
      }
    })")};

    // Cluster name is no longer needed for indexer name.
    EXPECT_NO_THROW(m_policyManager->initialize(configJson));
}

TEST_F(PolicyManagerTest, invalidConfigurationNoCTIUrl)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes"
      }
    })")};

    EXPECT_THROW(m_policyManager->initialize(configJson), std::runtime_error);
}

TEST_F(PolicyManagerTest, validConfigurationDefaultValuesNoIndexer)
{
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "cti-url": "cti-url.com"
      },
      "clusterName":"cluster01",
      "clusterEnabled":false
    })")};

    m_policyManager->initialize(configJson);

    EXPECT_TRUE(m_policyManager->isVulnerabilityDetectionEnabled());
    EXPECT_FALSE(m_policyManager->isIndexerEnabled());

    EXPECT_EQ(m_policyManager->getFeedUpdateTime(), 3600);

    EXPECT_EQ(m_policyManager->getHostList().count("http://localhost:9200"), 0);

    EXPECT_EQ(m_policyManager->getTranslationLRUSize(), DEFAULT_TRANSLATION_LRU_SIZE);
    EXPECT_EQ(m_policyManager->getOsdataLRUSize(), DEFAULT_OSDATA_LRU_SIZE);
    EXPECT_EQ(m_policyManager->getRemediationLRUSize(), DEFAULT_REMEDIATION_LRU_SIZE);
}

TEST_F(PolicyManagerTest, validConfigurationVulnerabilityScannerIgnoreIndexStatus)
{
    // If the module is disable, the index-status setting should be ignored.
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "no",
        "index-status": "yes",
        "feed-update-interval": "60m",
        "offline-url": "file:///var/algo.tar.gz",
        "cti-url": "https://cti-url.com"
      },
      "indexer": {
        "enabled": "no",
        "hosts": ["http://10.2.20.2:9200", "https://10.2.20.42:9200"],
        "username": "ImGroot",
        "password": "MoreSecurePassword123",
        "api_key": "ABC123",
        "ssl": {
          "certificate_authorities": ["/var/ossec/"],
          "certificate": "cert",
          "key": "ItsASecret!"
        }
      },
      "clusterName":"cluster01",
      "clusterEnabled":false
    })")};
    EXPECT_NO_THROW(m_policyManager->initialize(configJson));

    EXPECT_FALSE(m_policyManager->isVulnerabilityDetectionEnabled());
    EXPECT_FALSE(m_policyManager->isIndexerEnabled());
}

TEST_F(PolicyManagerTest, validConfigurationCheckFeedUpdateIntervalLessThan60m)
{
    // If the feed-update-interval is less than 60m, it should be set to 60m.
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "feed-update-interval": "10m",
        "cti-url": "https://cti-url.com"
      },
      "clusterName":"cluster01",
      "clusterEnabled":false
    })")};
    EXPECT_NO_THROW(m_policyManager->initialize(configJson));

    EXPECT_TRUE(m_policyManager->isVulnerabilityDetectionEnabled());

    EXPECT_EQ(m_policyManager->getFeedUpdateTime(), 3600);

    EXPECT_STREQ(
        m_policyManager->getUpdaterConfiguration().dump().c_str(),
        R"({"configData":{"compressionType":"raw","consumerName":"Wazuh VulnerabilityDetector","contentFileName":"api_file.json","contentSource":"cti-offset","databasePath":"queue/vd_updater/rocksdb","deleteDownloadedContent":true,"offset":0,"outputFolder":"queue/vd_updater/tmp","url":"https://cti-url.com","versionedContent":"false"},"interval":3600,"ondemand":true,"topicName":"vulnerability_feed_manager"})");

    EXPECT_EQ(m_policyManager->getUpdaterConfiguration().at("interval"), 3600);
}

TEST_F(PolicyManagerTest, validConfigurationCheckFeedUpdateIntervalGreaterThan60m)
{
    // If the feed-update-interval is greater than 60m, it should be set to the specified value.
    const auto& configJson {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "feed-update-interval": "61m",
        "cti-url": "https://cti-url.com"
      },
      "clusterName":"cluster01",
      "clusterEnabled":false
    })")};
    EXPECT_NO_THROW(m_policyManager->initialize(configJson));

    EXPECT_TRUE(m_policyManager->isVulnerabilityDetectionEnabled());

    EXPECT_EQ(m_policyManager->getFeedUpdateTime(), 3660);

    EXPECT_STREQ(
        m_policyManager->getUpdaterConfiguration().dump().c_str(),
        R"({"configData":{"compressionType":"raw","consumerName":"Wazuh VulnerabilityDetector","contentFileName":"api_file.json","contentSource":"cti-offset","databasePath":"queue/vd_updater/rocksdb","deleteDownloadedContent":true,"offset":0,"outputFolder":"queue/vd_updater/tmp","url":"https://cti-url.com","versionedContent":"false"},"interval":3660,"ondemand":true,"topicName":"vulnerability_feed_manager"})");

    EXPECT_EQ(m_policyManager->getUpdaterConfiguration().at("interval"), 3660);
}

const auto& UPDATER_BASIC_CONFIG {nlohmann::json::parse(R"({
      "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes"
      },
      "updater": {
        "interval": 3600,
        "ondemand": true,
        "topicName": "vulnerability_feed_manager",
        "configData": {
          "consumerName": "Wazuh VulnerabilityDetector",
          "contentSource": "cti-snapshot",
          "compressionType": "zip",
          "versionedContent": "false",
          "deleteDownloadedContent": true,
          "outputFolder": "queue/vd_updater/tmp",
          "contentFileName": "api_file.json",
          "databasePath": "queue/vd_updater/rocksdb",
          "url": "https://updater-url.com",
          "offset": 0
        }
      },
      "clusterName":"cluster01",
      "clusterEnabled":false
    })")};

TEST_F(PolicyManagerTest, updaterValidConfiguration)
{
    EXPECT_NO_THROW(m_policyManager->initialize(UPDATER_BASIC_CONFIG));

    EXPECT_EQ(m_policyManager->getFeedUpdateTime(), 3600);
    EXPECT_EQ(m_policyManager->getUpdaterConfiguration(), UPDATER_BASIC_CONFIG.at("updater"));
    EXPECT_EQ(m_policyManager->getCTIUrl(), "https://updater-url.com");
}

TEST_F(PolicyManagerTest, updaterValidUrlhttp)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("url") = "http://updater-url.com";

    EXPECT_NO_THROW(m_policyManager->initialize(basicConfigCopy));
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingInterval)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").erase("interval");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingOndemand)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").erase("ondemand");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingTopicName)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").erase("topicName");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingConfigData)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").erase("configData");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingConsumerName)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("consumerName");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingContentSource)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("contentSource");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingCompressionType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("compressionType");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingVersionedContent)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("versionedContent");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingDeleteDownloadedContent)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("deleteDownloadedContent");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingOutputFolder)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("outputFolder");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingContentFileName)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("contentFileName");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingDatabasePath)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("databasePath");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingUrl)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("url");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationMissingOffset)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").erase("offset");

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongIntervalType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("interval") = "3600";

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongOndemandType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("ondemand") = "true";

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongTopicNameType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("topicName") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongConsumerNameType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("consumerName") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongContentSourceType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("contentSource") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongCompressionTypeType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("compressionType") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongVersionedContentType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("versionedContent") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongDeleteDownloadedContentType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("deleteDownloadedContent") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongOutputFolderType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("outputFolder") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongContentFileNameType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("contentFileName") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongDatabasePathType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("databasePath") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongUrlType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("url") = 123;

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongUrlType2)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("url") = "cti-url.com";

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}

TEST_F(PolicyManagerTest, updaterInvalidConfigurationWrongOffsetType)
{
    nlohmann::json basicConfigCopy = UPDATER_BASIC_CONFIG;
    basicConfigCopy.at("updater").at("configData").at("offset") = "0";

    EXPECT_THROW(m_policyManager->initialize(basicConfigCopy), std::runtime_error);
}
