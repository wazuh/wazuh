/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * December 1, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "eventGetCve_test.hpp"
#include "../../src/scanOrchestrator/factory/eventGetCve.hpp"
#include "MockIndexerConnector.hpp"
#include "inventory_sync/src/context.hpp"
#include "json.hpp"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

#include <functional>
#include <memory>
#include <string>

using ::testing::_;
using ::testing::Invoke;

namespace
{
    /**
     * @brief Helper to create a ScanContext with a basic agent id.
     */
    std::shared_ptr<TScanContext<>> createScanContext()
    {
        Context ctx;
        ctx.agentId = "001";
        return std::make_shared<TScanContext<>>(ctx);
    }
} // namespace

PackageContextData EventGetCveTest::buildDeletedPackage()
{
    PackageContextData pkg;
    pkg.name = "libcustom";
    pkg.version = "1.0.0";
    pkg.format = "deb";
    pkg.location = "/usr/lib/libcustom.so";
    return pkg;
}

TEST_F(EventGetCveTest, AddsDeleteDetectionFromIndexerHits)
{
    auto mockConnector = std::make_shared<MockIndexerConnector>();
    const auto cveId = std::string {"CVE-2024-5678"};

    auto scanContext = createScanContext();
    auto pkg = buildDeletedPackage();
    const auto detectionBase = scanContext->buildPackageDetectionIdBase("pkg123");
    scanContext->addPackageToContext(detectionBase, pkg, ElementOperation::Delete);

    const std::string detectionId = detectionBase + "_" + cveId;
    auto response = nlohmann::json::parse(R"(
        {
            "hits": {
                "hits": [
                    {
                        "_id": "DUMMY",
                        "_source": {
                            "vulnerability": {
                                "id": "CVE-9999-0000"
                            }
                        }
                    }
                ]
            }
        })");
    response["hits"]["hits"][0]["_id"] = detectionId;
    response["hits"]["hits"][0]["_source"]["vulnerability"]["id"] = cveId;

    EXPECT_CALL(*mockConnector, executeSearchQueryWithPagination(_, _, _))
        .WillOnce(Invoke(
            [&](const std::string& index,
                const nlohmann::json& query,
                std::function<void(const nlohmann::json&)> callback)
            {
                EXPECT_EQ(index, "wazuh-states-vulnerabilities");
                callback(response);
            }));

    TEventGetCve<MockIndexerConnector, TScanContext<>> handler(mockConnector);

    EXPECT_NO_THROW(handler.handleRequest(scanContext));

    ASSERT_EQ(scanContext->cveCount(), 1);
    ASSERT_TRUE(scanContext->hasCVE(detectionId));

    const auto& detection = scanContext->detectedCVEs().at(detectionId);
    EXPECT_EQ(detection.cveId, cveId);
    EXPECT_EQ(detection.operation, ElementOperation::Delete);
    EXPECT_EQ(detection.componentType, AffectedComponentType::Package);
}

TEST_F(EventGetCveTest, SkipDeletedPackageWithoutNameOrVersion)
{
    auto mockConnector = std::make_shared<MockIndexerConnector>();

    auto scanContext = createScanContext();
    PackageContextData pkg;
    pkg.name = "libinvalid";
    pkg.version.clear(); // Missing version should force a skip.
    auto detectionBase = scanContext->buildPackageDetectionIdBase("pkg-invalid");
    scanContext->addPackageToContext(detectionBase, pkg, ElementOperation::Delete);

    EXPECT_CALL(*mockConnector, executeSearchQueryWithPagination(_, _, _)).Times(0);

    TEventGetCve<MockIndexerConnector, TScanContext<>> handler(mockConnector);

    handler.handleRequest(scanContext);

    EXPECT_EQ(scanContext->cveCount(), 0U);
}

TEST_F(EventGetCveTest, ContinuesProcessingWhenIndexerThrows)
{
    auto mockConnector = std::make_shared<MockIndexerConnector>();

    auto scanContext = createScanContext();
    auto pkg = buildDeletedPackage();
    auto detectionBase = scanContext->buildPackageDetectionIdBase("pkg-ex");
    scanContext->addPackageToContext(detectionBase, pkg, ElementOperation::Delete);

    EXPECT_CALL(*mockConnector, executeSearchQueryWithPagination(_, _, _))
        .WillOnce(Invoke([](const std::string&, const nlohmann::json&, std::function<void(const nlohmann::json&)>)
                         { throw std::runtime_error("forced error"); }));

    TEventGetCve<MockIndexerConnector, TScanContext<>> handler(mockConnector);

    EXPECT_NO_THROW(handler.handleRequest(scanContext));
    EXPECT_EQ(scanContext->cveCount(), 0U);
}

TEST_F(EventGetCveTest, SkipsPackagesWithNonDeleteOperation)
{
    auto mockConnector = std::make_shared<MockIndexerConnector>();

    auto scanContext = createScanContext();

    // Add package with Upsert operation
    auto pkg1 = buildDeletedPackage();
    auto detectionBase1 = scanContext->buildPackageDetectionIdBase("pkg-upsert");
    scanContext->addPackageToContext(detectionBase1, pkg1, ElementOperation::Upsert);

    // Add package with another Upsert operation
    auto pkg2 = buildDeletedPackage();
    pkg2.name = "libother";
    auto detectionBase2 = scanContext->buildPackageDetectionIdBase("pkg-upsert2");
    scanContext->addPackageToContext(detectionBase2, pkg2, ElementOperation::Upsert);

    EXPECT_CALL(*mockConnector, executeSearchQueryWithPagination(_, _, _)).Times(0);

    TEventGetCve<MockIndexerConnector, TScanContext<>> handler(mockConnector);

    EXPECT_NO_THROW(handler.handleRequest(scanContext));
    EXPECT_EQ(scanContext->cveCount(), 0U);
}

TEST_F(EventGetCveTest, ProcessesMultipleDeletedPackages)
{
    auto mockConnector = std::make_shared<MockIndexerConnector>();

    auto scanContext = createScanContext();

    // Add first deleted package
    auto pkg1 = buildDeletedPackage();
    const auto detectionBase1 = scanContext->buildPackageDetectionIdBase("pkg1");
    scanContext->addPackageToContext(detectionBase1, pkg1, ElementOperation::Delete);

    // Add second deleted package
    auto pkg2 = buildDeletedPackage();
    pkg2.name = "libother";
    pkg2.version = "2.0.0";
    const auto detectionBase2 = scanContext->buildPackageDetectionIdBase("pkg2");
    scanContext->addPackageToContext(detectionBase2, pkg2, ElementOperation::Delete);

    const std::string cveId1 = "CVE-2024-1111";
    const std::string cveId2 = "CVE-2024-2222";
    const std::string detectionId1 = detectionBase1 + "_" + cveId1;
    const std::string detectionId2 = detectionBase2 + "_" + cveId2;

    auto response1 = nlohmann::json::parse(R"(
        {
            "hits": {
                "hits": [
                    {
                        "_id": "DUMMY",
                        "_source": {
                            "vulnerability": {
                                "id": "CVE-9999-0000"
                            }
                        }
                    }
                ]
            }
        })");
    response1["hits"]["hits"][0]["_id"] = detectionId1;
    response1["hits"]["hits"][0]["_source"]["vulnerability"]["id"] = cveId1;

    auto response2 = nlohmann::json::parse(R"(
        {
            "hits": {
                "hits": [
                    {
                        "_id": "DUMMY",
                        "_source": {
                            "vulnerability": {
                                "id": "CVE-9999-0000"
                            }
                        }
                    }
                ]
            }
        })");
    response2["hits"]["hits"][0]["_id"] = detectionId2;
    response2["hits"]["hits"][0]["_source"]["vulnerability"]["id"] = cveId2;

    EXPECT_CALL(*mockConnector, executeSearchQueryWithPagination(_, _, _))
        .WillOnce(Invoke(
            [&](const std::string& index,
                const nlohmann::json& query,
                std::function<void(const nlohmann::json&)> callback)
            {
                EXPECT_EQ(index, "wazuh-states-vulnerabilities");
                callback(response1);
            }))
        .WillOnce(Invoke(
            [&](const std::string& index,
                const nlohmann::json& query,
                std::function<void(const nlohmann::json&)> callback)
            {
                EXPECT_EQ(index, "wazuh-states-vulnerabilities");
                callback(response2);
            }));

    TEventGetCve<MockIndexerConnector, TScanContext<>> handler(mockConnector);

    EXPECT_NO_THROW(handler.handleRequest(scanContext));
    ASSERT_EQ(scanContext->cveCount(), 2U);
    ASSERT_TRUE(scanContext->hasCVE(detectionId1));
    ASSERT_TRUE(scanContext->hasCVE(detectionId2));
}

TEST_F(EventGetCveTest, SkipsPackageWithMissingName)
{
    auto mockConnector = std::make_shared<MockIndexerConnector>();

    auto scanContext = createScanContext();
    PackageContextData pkg;
    pkg.name.clear();
    pkg.version = "1.0.0";
    pkg.format = "deb";
    auto detectionBase = scanContext->buildPackageDetectionIdBase("pkg-no-name");
    scanContext->addPackageToContext(detectionBase, pkg, ElementOperation::Delete);

    EXPECT_CALL(*mockConnector, executeSearchQueryWithPagination(_, _, _)).Times(0);

    TEventGetCve<MockIndexerConnector, TScanContext<>> handler(mockConnector);

    handler.handleRequest(scanContext);

    EXPECT_EQ(scanContext->cveCount(), 0U);
}

TEST_F(EventGetCveTest, SkipsDuplicateDetections)
{
    auto mockConnector = std::make_shared<MockIndexerConnector>();
    const auto cveId = std::string {"CVE-2024-5678"};

    auto scanContext = createScanContext();
    auto pkg = buildDeletedPackage();
    const auto detectionBase = scanContext->buildPackageDetectionIdBase("pkg123");
    scanContext->addPackageToContext(detectionBase, pkg, ElementOperation::Delete);

    const std::string detectionId = detectionBase + "_" + cveId;

    auto response = nlohmann::json::parse(R"(
        {
            "hits": {
                "hits": [
                    {
                        "_id": "DUMMY",
                        "_source": {
                            "vulnerability": {
                                "id": "CVE-9999-0000"
                            }
                        }
                    },
                    {
                        "_id": "DUMMY",
                        "_source": {
                            "vulnerability": {
                                "id": "CVE-9999-0000"
                            }
                        }
                    }
                ]
            }
        })");
    response["hits"]["hits"][0]["_id"] = detectionId;
    response["hits"]["hits"][0]["_source"]["vulnerability"]["id"] = cveId;
    response["hits"]["hits"][1]["_id"] = detectionId; // Same detection ID
    response["hits"]["hits"][1]["_source"]["vulnerability"]["id"] = cveId;

    EXPECT_CALL(*mockConnector, executeSearchQueryWithPagination(_, _, _))
        .WillOnce(Invoke([&](const std::string& index,
                             const nlohmann::json& query,
                             std::function<void(const nlohmann::json&)> callback) { callback(response); }));

    TEventGetCve<MockIndexerConnector, TScanContext<>> handler(mockConnector);

    EXPECT_NO_THROW(handler.handleRequest(scanContext));

    ASSERT_EQ(scanContext->cveCount(), 1U);
    ASSERT_TRUE(scanContext->hasCVE(detectionId));
}
