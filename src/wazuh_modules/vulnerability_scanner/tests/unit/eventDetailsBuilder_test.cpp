/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * January 2, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "eventDetailsBuilder_test.hpp"
#include "../../src/scanOrchestrator/factory/eventDetailsBuilder.hpp"
#include "../mocks/globalMocks.hpp"
#include "MockGlobalData.hpp"
#include "MockOsDataCache.hpp"
#include "TrampolineGlobalData.hpp"
#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "json.hpp"
#include "timeHelper.h"
#include "vulnerabilityDescription_schema.h"
#include <unistd.h>

using ::testing::_;
using ::testing::HasSubstr;
using ::testing::ThrowsMessage;

namespace NSEventDetailsBuilderTest
{
    constexpr auto TEST_DESCRIPTION_DATABASE_PATH {"queue/vd/feed"};

    const std::string MANAGER_NAME {"manager_name"};

    const std::string CVEID {"CVE-2024-1234"};

    const std::string OFFSET {"123456"};

    const std::string DESCRIPTIONS_COLUMN_DEFAULT {"descriptions_nvd"};

    const Os osData {.hostName = "osdata_hostname",
                     .architecture = "osdata_architecture",
                     .name = "osdata_name",
                     .codeName = "osdata_codeName",
                     .majorVersion = "osdata_majorVersion",
                     .minorVersion = "osdata_minorVersion",
                     .patch = "osdata_patch",
                     .build = "osdata_build",
                     .platform = "osdata_platform",
                     .version = "osdata_version",
                     .release = "osdata_release",
                     .displayVersion = "osdata_displayVersion",
                     .sysName = "osdata_sysName",
                     .kernelVersion = "osdata_kernelVersion",
                     .kernelRelease = "osdata_kernelRelease"};

    void expectOsData()
    {

        spOsDataCacheMock = std::make_shared<MockOsDataCache>();
        EXPECT_CALL(*spOsDataCacheMock, getOsData(_, _))
            .WillOnce(testing::Invoke(
                [](const std::string&, Os& osDataResult)
                {
                    osDataResult = osData;
                    return true;
                }));
    }
} // namespace NSEventDetailsBuilderTest

const nlohmann::json ADP_DESCRIPTIONS =
    R"#(
        {
            "adp_descriptions": {
    "alas": {
      "adp": "Amazon Linux Security Center",
      "description": "nvd",
      "cvss": "alas"
    },
    "alma": {
      "adp": "Alma Linux Security Oval",
      "description": "alma",
      "cvss": "alma"
    },
    "arch": {
      "adp": "Arch Linux Security Tracker",
      "description": "nvd",
      "cvss": "nvd"
    },
    "debian": {
      "adp": "Debian Security Tracker",
      "description": "debian",
      "cvss": "nvd"
    },
    "oracle": {
      "adp": "Oracle Linux Security",
      "description": "nvd",
      "cvss": "oracle"
    },
    "npm": {
      "adp": "Open Source Vulnerabilities",
      "description": "npm",
      "cvss": "npm"
    },
    "nvd": {
      "adp": "National Vulnerability Database",
      "description": "nvd",
      "cvss": "nvd"
    },
    "pypi": {
      "adp": "Open Source Vulnerabilities",
      "description": "pypi",
      "cvss": "pypi"
    },
    "redhat": {
      "adp": "Red Hat CVE Database",
      "description": "redhat",
      "cvss": "redhat"
    },
    "rocky": {
      "adp": "Rocky Enterprise Product Errata",
      "description": "rocky",
      "cvss": "rocky"
    },
    "suse": {
      "adp": "SUSE CVE Database",
      "description": "suse",
      "cvss": "suse"
    },
    "opensuse": {
      "adp": "SUSE CVE Database",
      "description": "suse",
      "cvss": "suse"
    },
    "canonical": {
      "adp": "Canonical Security Tracker",
      "description": "canonical",
      "cvss": "canonical"
    },
    "homebrew": {
      "adp": "Homebrew Security Audit",
      "description": "homebrew",
      "cvss": "nvd"
    }
  }
        }
    )#"_json;

using namespace NSEventDetailsBuilderTest;

void EventDetailsBuilderTest::SetUp()
{
    std::filesystem::create_directories("queue/vd");
    TScanContext<TrampolineOsDataCache, GlobalData>::setClusterInfo("cluster01", "node01");
}

void EventDetailsBuilderTest::TearDown()
{
    spOsDataCacheMock.reset();
    spGlobalDataMock.reset();
    std::filesystem::remove_all("queue/vd");
}

TEST_F(EventDetailsBuilderTest, TestPackageVulnerabilityWithCVSS2)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData = NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(
        fbBuilder,
        "LOW",                                            // accessComplexity
        "nvd",                                            // assignerShortName
        "NETWORK",                                        // attackVector
        "NONE",                                           // authentication
        "PARTIAL",                                        // availabilityImpact
        "CVSS:2.0",                                       // classification
        "PARTIAL",                                        // confidentialityImpact
        "CWE-89",                                         // cweId
        "2021-01-15T10:00:00Z",                           // datePublished
        "2021-02-20T15:30:00Z",                           // dateUpdated
        "SQL injection vulnerability in package",         // description
        "PARTIAL",                                        // integrityImpact
        "",                                               // privilegesRequired
        "https://nvd.nist.gov/vuln/detail/CVE-2024-1234", // reference
        "",                                               // scope
        7.5,                                              // scoreBase
        "2.0",                                            // scoreVersion
        "HIGH",                                           // severity
        "NONE",                                           // userInteraction
        NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put(CVEID, dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    // Create scan context using Context struct
    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "x86_64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    // Add a package to the context
    PackageContextData pkg;
    pkg.name = "vulnerable-package";
    pkg.version = "1.0.0";
    pkg.architecture = "amd64";
    pkg.format = "deb";
    pkg.description = "A vulnerable test package";
    pkg.size = 1024;

    // Add a CVE detection for this package
    const std::string detectionId = "001_vulnerable-package_1.0.0_CVE-2024-1234";
    const std::string detectionIdBase = "001_vulnerable-package_1.0.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "1.2.0";
    detection.conditionType = MatchRuleCondition::LessThan;
    detection.cnaSource = "nvd";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    // Mock GlobalData
    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    // Run EventDetailsBuilder
    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    // Verify ECS event was created
    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->ecsEventCount(), 1);

    // Get and parse the ECS event
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify agent fields
    EXPECT_EQ(event["wazuh"]["agent"]["id"].get<std::string>(), "001");
    EXPECT_EQ(event["wazuh"]["agent"]["name"].get<std::string>(), "test-agent");
    EXPECT_EQ(event["wazuh"]["agent"]["type"].get<std::string>(), "Wazuh");
    EXPECT_EQ(event["wazuh"]["agent"]["version"].get<std::string>(), "4.5.0");

    // Verify package fields
    EXPECT_EQ(event["package"]["name"].get<std::string>(), "vulnerable-package");
    EXPECT_EQ(event["package"]["version"].get<std::string>(), "1.0.0");
    EXPECT_EQ(event["package"]["architecture"].get<std::string>(), "amd64");
    EXPECT_EQ(event["package"]["type"].get<std::string>(), "deb");
    EXPECT_EQ(event["package"]["size"].get<int64_t>(), 1024);

    // Verify vulnerability fields
    EXPECT_EQ(event["vulnerability"]["id"].get<std::string>(), CVEID);
    EXPECT_EQ(event["vulnerability"]["category"].get<std::string>(), "Packages");
    EXPECT_EQ(event["vulnerability"]["classification"].get<std::string>(), "CVSS:2.0");
    EXPECT_EQ(event["vulnerability"]["description"].get<std::string>(), "SQL injection vulnerability in package");
    EXPECT_EQ(event["vulnerability"]["severity"].get<std::string>(), "High");
    EXPECT_EQ(event["vulnerability"]["score"]["base"].get<double>(), 7.5);
    EXPECT_EQ(event["vulnerability"]["score"]["version"].get<std::string>(), "2.0");
    EXPECT_FALSE(event["vulnerability"]["under_evaluation"].get<bool>());
    EXPECT_EQ(event["vulnerability"]["scanner"]["condition"].get<std::string>(), "Package less than 1.2.0");
    EXPECT_EQ(event["vulnerability"]["scanner"]["vendor"].get<std::string>(), "Wazuh");

    EXPECT_EQ(event["wazuh"]["cluster"]["name"].get<std::string>(), "cluster01");
    EXPECT_EQ(event["wazuh"]["schema"]["version"].get<std::string>(), WAZUH_SCHEMA_VERSION);

    EXPECT_TRUE(event.contains("host"));
    EXPECT_TRUE(event["host"].contains("os"));
    EXPECT_EQ(event["host"]["os"]["name"].get<std::string>(), "Ubuntu");
    EXPECT_EQ(event["host"]["os"]["platform"].get<std::string>(), "ubuntu");
}

TEST_F(EventDetailsBuilderTest, TestDarwinToMacOSConversion)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "",
                                                                     "nvd",
                                                                     "NETWORK",
                                                                     "",
                                                                     "HIGH",
                                                                     "CVSS:3.1",
                                                                     "NONE",
                                                                     "CWE-787",
                                                                     "2023-03-10T10:00:00Z",
                                                                     "2023-04-15T12:00:00Z",
                                                                     "macOS buffer overflow",
                                                                     "NONE",
                                                                     "LOW",
                                                                     "https://nvd.nist.gov/vuln/detail/CVE-2024-8888",
                                                                     "UNCHANGED",
                                                                     7.8,
                                                                     "3.1",
                                                                     "HIGH",
                                                                     "NONE",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-8888", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "011";
    ctx.agentName = "macos-agent";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "arm64";
    ctx.hostname = "macos-host";
    ctx.osname = "macOS";
    ctx.osplatform = "darwin";
    ctx.osversion = "13.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "macos-app";
    pkg.version = "1.0.0";
    pkg.architecture = "arm64";
    pkg.format = "pkg";

    const std::string detectionId = "011_macos-app_1.0.0_CVE-2024-8888";
    const std::string detectionIdBase = "011_macos-app_1.0.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-8888";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "1.1.0";
    detection.conditionType = MatchRuleCondition::LessThan;
    detection.cnaSource = "nvd";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify darwin platform converted to macos in host.os.type
    EXPECT_EQ(event["host"]["os"]["platform"].get<std::string>(), "darwin");
    EXPECT_EQ(event["host"]["os"]["type"].get<std::string>(), "macos"); // darwin -> macos
    EXPECT_EQ(event["host"]["os"]["name"].get<std::string>(), "macOS");
}

TEST_F(EventDetailsBuilderTest, TestDefaultStatusCondition)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData = NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(
        fbBuilder,
        "LOW",
        "debian",
        "NETWORK",
        "",
        "PARTIAL",
        "CVSS:2.0",
        "PARTIAL",
        "CWE-22",
        "2020-06-01T08:00:00Z",
        "2020-07-05T10:00:00Z",
        "Path traversal vulnerability",
        "PARTIAL",
        "",
        "https://security-tracker.debian.org/tracker/CVE-2024-5555",
        "",
        6.4,
        "2.0",
        "MEDIUM",
        "",
        NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-5555", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "012";
    ctx.agentName = "debian-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "default-pkg";
    pkg.version = "2.0.0";
    pkg.format = "deb";

    const std::string detectionId = "012_default-pkg_2.0.0_CVE-2024-5555";
    const std::string detectionIdBase = "012_default-pkg_2.0.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-5555";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "";
    detection.conditionType = MatchRuleCondition::DefaultStatus;
    detection.cnaSource = "debian";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"debian", "debian"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify DefaultStatus condition
    EXPECT_EQ(event["vulnerability"]["scanner"]["condition"].get<std::string>(), "Package default status");
}

TEST_F(EventDetailsBuilderTest, TestUnknownConditionType)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "",
                                                                     "nvd",
                                                                     "NETWORK",
                                                                     "",
                                                                     "HIGH",
                                                                     "CVSS:3.1",
                                                                     "NONE",
                                                                     "CWE-416",
                                                                     "2023-09-01T14:00:00Z",
                                                                     "2023-10-05T16:00:00Z",
                                                                     "Use after free vulnerability",
                                                                     "LOW",
                                                                     "NONE",
                                                                     "https://nvd.nist.gov/vuln/detail/CVE-2024-9191",
                                                                     "UNCHANGED",
                                                                     8.1,
                                                                     "3.1",
                                                                     "HIGH",
                                                                     "NONE",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-9191", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "013";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "unknown-pkg";
    pkg.version = "1.0.0";
    pkg.format = "rpm";

    const std::string detectionId = "013_unknown-pkg_1.0.0_CVE-2024-9191";
    const std::string detectionIdBase = "013_unknown-pkg_1.0.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-9191";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "";
    detection.conditionType = MatchRuleCondition::Unknown;
    detection.cnaSource = "nvd";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify Unknown condition type returns "Unknown"
    EXPECT_EQ(event["vulnerability"]["scanner"]["condition"].get<std::string>(), "Unknown");
}

TEST_F(EventDetailsBuilderTest, TestScannerSourceFallbackToCnaSource)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "",
                                                                     "custom-vendor",
                                                                     "NETWORK",
                                                                     "",
                                                                     "PARTIAL",
                                                                     "CVSS:2.0",
                                                                     "PARTIAL",
                                                                     "CWE-89",
                                                                     "2021-11-10T10:00:00Z",
                                                                     "2021-12-15T12:00:00Z",
                                                                     "Custom vendor vulnerability",
                                                                     "NONE",
                                                                     "",
                                                                     "https://custom-vendor.com/CVE-2024-7890",
                                                                     "",
                                                                     5.0,
                                                                     "2.0",
                                                                     "MEDIUM",
                                                                     "",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-7890", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "014";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "custom-pkg";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    const std::string detectionId = "014_custom-pkg_1.0.0_CVE-2024-7890";
    const std::string detectionIdBase = "014_custom-pkg_1.0.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-7890";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "1.1.0";
    detection.conditionType = MatchRuleCondition::LessThan;
    detection.cnaSource = "custom-vendor"; // Not in ADP map
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"custom-vendor", "custom-vendor"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify scanner.source falls back to cnaSource when ADP lookup fails
    EXPECT_EQ(event["vulnerability"]["scanner"]["source"].get<std::string>(), "custom-vendor");
}

TEST_F(EventDetailsBuilderTest, TestOsDeleteWithDeletedOSData)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "",
                                                                     "canonical",
                                                                     "LOCAL",
                                                                     "",
                                                                     "HIGH",
                                                                     "CVSS:3.1",
                                                                     "HIGH",
                                                                     "CWE-269",
                                                                     "2022-02-10T09:00:00Z",
                                                                     "2022-03-15T11:00:00Z",
                                                                     "Old Ubuntu version vulnerability",
                                                                     "HIGH",
                                                                     "LOW",
                                                                     "https://ubuntu.com/security/CVE-2024-1111",
                                                                     "UNCHANGED",
                                                                     7.8,
                                                                     "3.1",
                                                                     "HIGH",
                                                                     "NONE",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-1111", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    // Current OS: Ubuntu 22.04
    Context ctx;
    ctx.agentId = "015";
    ctx.agentName = "ubuntu-upgraded";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "x86_64";
    ctx.hostname = "ubuntu-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "22.04";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    // Deleted OS: Ubuntu 18.04
    OsContextData deletedOS;
    deletedOS.item_id = "deleted-ubuntu-18";
    deletedOS.name = "Ubuntu";
    deletedOS.version = "18.04"; // Old version
    deletedOS.platform = "ubuntu";
    deletedOS.architecture = "x86_64";
    deletedOS.codeName = "bionic";
    scanContext->setDeletedOSData(deletedOS);

    const std::string detectionId = "015_Ubuntu_CVE-2024-1111";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-1111";
    detection.operation = ElementOperation::Delete;
    detection.componentType = AffectedComponentType::Os;
    detection.matchCondition = "18.04";
    detection.conditionType = MatchRuleCondition::Equal;
    detection.cnaSource = "canonical";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"canonical", "canonical"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify category is OS
    EXPECT_EQ(event["vulnerability"]["category"], "OS");

    // Verify package.
    EXPECT_TRUE(event.contains("package"));
    EXPECT_EQ(event["package"]["name"], "Ubuntu");
    EXPECT_EQ(event["package"]["version"], "18.04"); // Deleted version

    // Verify host.os fields are present
    EXPECT_TRUE(event.contains("host"));
    EXPECT_TRUE(event["host"].contains("os"));
    EXPECT_EQ(event["host"]["os"]["name"], "Ubuntu");
    EXPECT_EQ(event["host"]["os"]["platform"], "ubuntu");
}

TEST_F(EventDetailsBuilderTest, TestEmptyCveIdSkipsDetection)
{
    Context ctx;
    ctx.agentId = "016";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    const std::string detectionId = "016_pkg_EMPTY";
    CVEDetectionResult detection;
    detection.cveId = ""; // Empty CVE ID
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.conditionType = MatchRuleCondition::Unknown;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->ecsEventCount(), 0);

    auto* eventJson = result->getECSEvent(detectionId);
    EXPECT_EQ(eventJson, nullptr);
}

TEST_F(EventDetailsBuilderTest, TestExceptionDuringDescriptionFetch)
{
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillOnce(testing::Throw(std::runtime_error("Database connection failed")));

    Context ctx;
    ctx.agentId = "017";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "error-pkg";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    const std::string detectionId = "017_error-pkg_1.0.0_CVE-2024-9999";
    const std::string detectionIdBase = "017_error-pkg_1.0.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-9999";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "";
    detection.conditionType = MatchRuleCondition::Unknown;
    detection.cnaSource = "nvd";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->ecsEventCount(), 0);
}

TEST_F(EventDetailsBuilderTest, TestAgentWithEmptyOptionalFields)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "",
                                                                     "nvd",
                                                                     "NETWORK",
                                                                     "",
                                                                     "HIGH",
                                                                     "CVSS:3.1",
                                                                     "HIGH",
                                                                     "CWE-502",
                                                                     "2023-05-01T10:00:00Z",
                                                                     "2023-06-10T12:00:00Z",
                                                                     "Deserialization vulnerability",
                                                                     "HIGH",
                                                                     "LOW",
                                                                     "https://nvd.nist.gov/vuln/detail/CVE-2024-2222",
                                                                     "UNCHANGED",
                                                                     9.8,
                                                                     "3.1",
                                                                     "CRITICAL",
                                                                     "NONE",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-2222", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "018";
    ctx.agentName = "minimal-agent";
    ctx.agentVersion = "4.5.0";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "minimal-pkg";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    const std::string detectionId = "018_minimal-pkg_1.0.0_CVE-2024-2222";
    const std::string detectionIdBase = "018_minimal-pkg_1.0.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-2222";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "2.0.0";
    detection.conditionType = MatchRuleCondition::LessThan;
    detection.cnaSource = "nvd";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify required agent fields are present
    EXPECT_EQ(event["wazuh"]["agent"]["id"].get<std::string>(), "018");
    EXPECT_EQ(event["wazuh"]["agent"]["name"].get<std::string>(), "minimal-agent");
    EXPECT_EQ(event["wazuh"]["agent"]["version"].get<std::string>(), "4.5.0");

    // Verify optional empty fields are NOT present
    EXPECT_FALSE(event["wazuh"]["agent"]["host"].contains("architecture"));
    EXPECT_FALSE(event["wazuh"]["agent"]["host"].contains("hostname"));
    EXPECT_FALSE(event["wazuh"]["agent"]["host"].contains("ip"));
    EXPECT_FALSE(event["wazuh"]["agent"].contains("groups"));

    EXPECT_TRUE(event["host"].contains("os"));
    EXPECT_EQ(event["host"]["os"]["name"].get<std::string>(), "Ubuntu");
}

TEST_F(EventDetailsBuilderTest, TestOsVulnerabilityWithCVSS3)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "",
                                                                     "nvd",
                                                                     "NETWORK",
                                                                     "",
                                                                     "HIGH",
                                                                     "CVSS:3.1",
                                                                     "NONE",
                                                                     "CWE-20",
                                                                     "2022-03-10T08:00:00Z",
                                                                     "2022-04-15T12:00:00Z",
                                                                     "Kernel vulnerability in Linux",
                                                                     "NONE",
                                                                     "NONE",
                                                                     "https://nvd.nist.gov/vuln/detail/CVE-2024-5678",
                                                                     "UNCHANGED",
                                                                     6.8,
                                                                     "3.1",
                                                                     "MEDIUM",
                                                                     "NONE",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-5678", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    // Mock database feed manager
    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    // Create scan context
    Context ctx;
    ctx.agentId = "002";
    ctx.agentName = "linux-server";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "x86_64";
    ctx.hostname = "linux-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04.3";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    OsContextData osData;
    osData.hostName = "linux-host";
    osData.architecture = "x86_64";
    osData.name = "Ubuntu";
    osData.platform = "ubuntu";
    osData.sysName = "Linux";
    osData.version = "20.04.3";
    osData.majorVersion = "20";
    osData.minorVersion = "04";
    osData.patch = "3";
    scanContext->setOSData(osData);

    // Add an OS vulnerability detection
    const std::string detectionId = "002_ubuntu_CVE-2024-5678";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-5678";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Os;
    detection.matchCondition = "20.04";
    detection.conditionType = MatchRuleCondition::Equal;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    // Mock GlobalData
    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    // Run EventDetailsBuilder
    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    // Verify ECS event was created
    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->ecsEventCount(), 1);

    // Get and parse the ECS event
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify agent fields
    EXPECT_EQ(event["wazuh"]["agent"]["id"].get<std::string>(), "002");
    EXPECT_EQ(event["wazuh"]["agent"]["name"].get<std::string>(), "linux-server");

    // Verify package fields ARE present for OS vulnerabilities (filled with OS data as affected component)
    EXPECT_TRUE(event.contains("package"));
    EXPECT_EQ(event["package"]["name"].get<std::string>(), "Ubuntu");
    EXPECT_EQ(event["package"]["version"].get<std::string>(), "20.04.3");
    EXPECT_EQ(event["package"]["type"].get<std::string>(), "ubuntu");

    // Verify host.os fields ARE present for OS vulnerabilities
    EXPECT_TRUE(event.contains("host"));
    EXPECT_EQ(event["host"]["os"]["name"].get<std::string>(), "Ubuntu");
    EXPECT_EQ(event["host"]["os"]["platform"].get<std::string>(), "ubuntu");
    EXPECT_EQ(event["host"]["os"]["type"].get<std::string>(), "linux");
    EXPECT_EQ(event["host"]["os"]["version"].get<std::string>(), "20.04.3");
    EXPECT_TRUE(event["host"]["os"]["full"].get<std::string>().find("Ubuntu") != std::string::npos);

    // Verify vulnerability fields
    EXPECT_EQ(event["vulnerability"]["id"].get<std::string>(), "CVE-2024-5678");
    EXPECT_EQ(event["vulnerability"]["category"].get<std::string>(), "OS");
    EXPECT_EQ(event["vulnerability"]["classification"].get<std::string>(), "CVSS:3.1");
    EXPECT_EQ(event["vulnerability"]["severity"].get<std::string>(), "Medium");
    EXPECT_EQ(event["vulnerability"]["score"]["base"].get<double>(), 6.8);
    EXPECT_EQ(event["vulnerability"]["score"]["version"].get<std::string>(), "3.1");
    EXPECT_FALSE(event["vulnerability"]["under_evaluation"].get<bool>());
    EXPECT_EQ(event["vulnerability"]["scanner"]["condition"].get<std::string>(), "Package equal to 20.04");
}

TEST_F(EventDetailsBuilderTest, TestEmptyCVEListReturnsNull)
{
    Context ctx;
    ctx.agentId = "003";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    // Should return nullptr when no CVEs found
    EXPECT_EQ(result, nullptr);
}

TEST_F(EventDetailsBuilderTest, TestUnderEvaluationFlag)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "",
                                                                     "nvd",
                                                                     "",
                                                                     "",
                                                                     "",
                                                                     "",
                                                                     "",
                                                                     "",
                                                                     "2023-01-01T00:00:00Z",
                                                                     "",
                                                                     "Under evaluation CVE",
                                                                     "",
                                                                     "",
                                                                     "https://example.com",
                                                                     "",
                                                                     0.0,
                                                                     "",
                                                                     "",
                                                                     "",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-9999", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "004";
    ctx.agentName = "test-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    const std::string detectionId = "004_pkg_CVE-2024-9999";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-9999";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.conditionType = MatchRuleCondition::Unknown;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);
    ASSERT_NE(result, nullptr);

    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify under_evaluation is TRUE when score/severity are missing
    EXPECT_TRUE(event["vulnerability"]["under_evaluation"].get<bool>());
    EXPECT_EQ(event["vulnerability"]["score"]["version"].get<std::string>(), "-");
    EXPECT_EQ(event["vulnerability"]["severity"].get<std::string>(), "-");
}

TEST_F(EventDetailsBuilderTest, TestManagerAgentProcessing)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "",
                                                                     "nvd",
                                                                     "NETWORK",
                                                                     "",
                                                                     "HIGH",
                                                                     "CVSS:3.1",
                                                                     "LOW",
                                                                     "CWE-119",
                                                                     "2022-05-10T10:00:00Z",
                                                                     "2022-06-15T12:00:00Z",
                                                                     "Buffer overflow in manager",
                                                                     "LOW",
                                                                     "LOW",
                                                                     "https://nvd.nist.gov/vuln/detail/CVE-2024-9876",
                                                                     "CHANGED",
                                                                     8.8,
                                                                     "3.1",
                                                                     "HIGH",
                                                                     "REQUIRED",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-9876", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    // Create context for testing manager agent processing (agent with any ID including 000)
    Context ctx;
    ctx.agentId = "000";
    ctx.agentName = "manager";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "x86_64";
    ctx.hostname = "manager-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "22.04";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "manager-package";
    pkg.version = "2.1.0";
    pkg.architecture = "amd64";
    pkg.format = "deb";

    const std::string detectionId = "000_manager-package_2.1.0_CVE-2024-9876";
    const std::string detectionIdBase = "000_manager-package_2.1.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-9876";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "2.2.0";
    detection.conditionType = MatchRuleCondition::LessThanOrEqual;
    detection.cnaSource = "nvd";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify CVSS 3.1 and LessThanOrEqual condition
    EXPECT_EQ(event["vulnerability"]["classification"].get<std::string>(), "CVSS:3.1");
    EXPECT_EQ(event["vulnerability"]["score"]["base"].get<double>(), 8.8);
    EXPECT_EQ(event["vulnerability"]["score"]["version"].get<std::string>(), "3.1");
    EXPECT_EQ(event["vulnerability"]["scanner"]["condition"].get<std::string>(), "Package less than or equal to 2.2.0");
}

TEST_F(EventDetailsBuilderTest, TestDeleteOperation)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "HIGH",
                                                                     "suse",
                                                                     "LOCAL",
                                                                     "SINGLE",
                                                                     "COMPLETE",
                                                                     "CVSS:2.0",
                                                                     "COMPLETE",
                                                                     "CWE-264",
                                                                     "2020-03-15T08:00:00Z",
                                                                     "2020-04-20T10:00:00Z",
                                                                     "Privilege escalation vulnerability",
                                                                     "COMPLETE",
                                                                     "",
                                                                     "https://www.suse.com/security/cve/CVE-2024-7777",
                                                                     "",
                                                                     9.3,
                                                                     "2.0",
                                                                     "CRITICAL",
                                                                     "NONE",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-7777", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "005";
    ctx.agentName = "suse-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "deleted-package";
    pkg.version = "1.5.0";
    pkg.architecture = "x86_64";
    pkg.format = "rpm";

    const std::string detectionId = "005_deleted-package_1.5.0_CVE-2024-7777";
    const std::string detectionIdBase = "005_deleted-package_1.5.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Delete);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-7777";
    detection.operation = ElementOperation::Delete; // DELETE operation
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "1.6.0";
    detection.conditionType = MatchRuleCondition::LessThan;
    detection.cnaSource = "suse";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"suse", "suse"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->ecsEventCount(), 1);

    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    EXPECT_EQ(event["vulnerability"]["id"].get<std::string>(), "CVE-2024-7777");
    EXPECT_EQ(event["package"]["name"].get<std::string>(), "deleted-package");

    // Verify SUSE vendor source
    EXPECT_TRUE(event["vulnerability"]["scanner"]["source"].get<std::string>().find("SUSE") != std::string::npos);
}

TEST_F(EventDetailsBuilderTest, TestPackageWithOptionalFields)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData = NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(
        fbBuilder,
        "",
        "redhat",
        "ADJACENT_NETWORK",
        "",
        "LOW",
        "CVSS:3.0",
        "NONE",
        "CWE-200",
        "2021-07-20T14:00:00Z",
        "2021-08-25T16:30:00Z",
        "Information disclosure vulnerability",
        "NONE",
        "NONE",
        "https://access.redhat.com/security/cve/CVE-2024-3333",
        "UNCHANGED",
        4.3,
        "3.0",
        "MEDIUM",
        "NONE",
        NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-3333", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "007";
    ctx.agentName = "rhel-agent";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "x86_64";
    ctx.hostname = "rhel-host";
    ctx.osname = "Red Hat Enterprise Linux";
    ctx.osplatform = "rhel";
    ctx.ostype = "Linux";
    ctx.osversion = "8.5";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "full-package";
    pkg.version = "3.2.1";
    pkg.architecture = "x86_64";
    pkg.format = "rpm";
    pkg.description = "Package with all optional fields";
    pkg.location = "/usr/lib/full-package";
    pkg.size = 2048000;
    pkg.install_time = "1640000000";

    const std::string detectionId = "007_full-package_3.2.1_CVE-2024-3333";
    const std::string detectionIdBase = "007_full-package_3.2.1";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-3333";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "3.3.0";
    detection.conditionType = MatchRuleCondition::LessThan;
    detection.cnaSource = "redhat";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"redhat", "redhat"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify all package fields including optional ones
    EXPECT_EQ(event["package"]["name"].get<std::string>(), "full-package");
    EXPECT_EQ(event["package"]["version"].get<std::string>(), "3.2.1");
    EXPECT_EQ(event["package"]["architecture"].get<std::string>(), "x86_64");
    EXPECT_EQ(event["package"]["type"].get<std::string>(), "rpm");
    EXPECT_EQ(event["package"]["description"].get<std::string>(), "Package with all optional fields");
    EXPECT_EQ(event["package"]["path"].get<std::string>(), "/usr/lib/full-package");
    EXPECT_EQ(event["package"]["size"].get<int64_t>(), 2048000);

    // Verify install_time converted to ISO8601
    EXPECT_TRUE(event["package"].contains("installed"));
    EXPECT_FALSE(event["package"]["installed"].get<std::string>().empty());

    // Verify Red Hat vendor
    EXPECT_TRUE(event["vulnerability"]["scanner"]["source"].get<std::string>().find("Red Hat") != std::string::npos);
}

TEST_F(EventDetailsBuilderTest, TestUnderEvaluationFalseWithValidScore)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "MEDIUM",
                                                                     "canonical",
                                                                     "NETWORK",
                                                                     "MULTIPLE",
                                                                     "PARTIAL",
                                                                     "CVSS:2.0",
                                                                     "NONE",
                                                                     "CWE-79",
                                                                     "2019-11-05T09:00:00Z",
                                                                     "2019-12-10T11:00:00Z",
                                                                     "Cross-site scripting vulnerability",
                                                                     "PARTIAL",
                                                                     "",
                                                                     "https://ubuntu.com/security/CVE-2024-4444",
                                                                     "",
                                                                     5.8,
                                                                     "2.0",
                                                                     "MEDIUM",
                                                                     "NONE",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-4444", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "008";
    ctx.agentName = "ubuntu-agent";
    ctx.agentVersion = "4.5.0";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "webapp-lib";
    pkg.version = "2.4.0";
    pkg.format = "deb";

    const std::string detectionId = "008_webapp-lib_2.4.0_CVE-2024-4444";
    const std::string detectionIdBase = "008_webapp-lib_2.4.0";
    scanContext->addPackageToContext(detectionIdBase, pkg, ElementOperation::Upsert);

    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-4444";
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    detection.matchCondition = "";
    detection.conditionType = MatchRuleCondition::Unknown;
    detection.cnaSource = "canonical";
    detection.detectionIdBase = detectionIdBase;

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"canonical", "canonical"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    // Verify under_evaluation is FALSE when score and severity are present
    EXPECT_FALSE(event["vulnerability"]["under_evaluation"].get<bool>());
    EXPECT_EQ(event["vulnerability"]["score"]["base"].get<double>(), 5.8);
    EXPECT_EQ(event["vulnerability"]["score"]["version"].get<std::string>(), "2.0");
    EXPECT_EQ(event["vulnerability"]["severity"].get<std::string>(), "Medium");

    // Verify Canonical vendor source
    EXPECT_TRUE(event["vulnerability"]["scanner"]["source"].get<std::string>().find("Canonical") != std::string::npos);
}

TEST_F(EventDetailsBuilderTest, TestOsDeleteOperation)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "",
                                                                     "nvd",
                                                                     "LOCAL",
                                                                     "",
                                                                     "COMPLETE",
                                                                     "CVSS:3.0",
                                                                     "COMPLETE",
                                                                     "CWE-20",
                                                                     "2022-08-10T14:00:00Z",
                                                                     "2022-09-15T16:00:00Z",
                                                                     "Windows OS vulnerability",
                                                                     "COMPLETE",
                                                                     "HIGH",
                                                                     "https://nvd.nist.gov/vuln/detail/CVE-2024-6666",
                                                                     "CHANGED",
                                                                     6.8,
                                                                     "3.0",
                                                                     "MEDIUM",
                                                                     "REQUIRED",
                                                                     NSEventDetailsBuilderTest::OFFSET.c_str());
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto m_rocksDbWrapper = std::make_unique<Utils::RocksDBWrapper>(TEST_DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    if (!m_rocksDbWrapper->columnExists(DESCRIPTIONS_COLUMN_DEFAULT))
    {
        m_rocksDbWrapper->createColumn(DESCRIPTIONS_COLUMN_DEFAULT);
    }
    m_rocksDbWrapper->put("CVE-2024-6666", dbValue, DESCRIPTIONS_COLUMN_DEFAULT);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityDescriptiveInformation(_, _, _))
        .WillRepeatedly(testing::Invoke(
            [&](const std::string& cveId,
                const std::string& shortName,
                FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
            {
                m_rocksDbWrapper->get(std::string(cveId), resultContainer.slice, DESCRIPTIONS_COLUMN_DEFAULT);
                if (flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(resultContainer.slice.data()),
                                                   resultContainer.slice.size());
                    NSVulnerabilityScanner::VerifyVulnerabilityDescriptionBuffer(verifier) == false)
                {
                    resultContainer.data = nullptr;
                    return false;
                }
                resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
                    NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
                return true;
            }));

    Context ctx;
    ctx.agentId = "010";
    ctx.agentName = "windows-agent";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "x86_64";
    ctx.hostname = "win-host";
    ctx.osname = "Windows 11";
    ctx.osplatform = "windows";
    ctx.ostype = "Windows";
    ctx.osversion = "11.0.22000";

    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    const std::string detectionId = "010_Windows11_CVE-2024-6666";
    CVEDetectionResult detection;
    detection.cveId = "CVE-2024-6666";
    detection.operation = ElementOperation::Delete;
    detection.componentType = AffectedComponentType::Os;
    detection.matchCondition = "10.0";
    detection.conditionType = MatchRuleCondition::Equal;
    detection.cnaSource = "nvd";

    scanContext->addDetectedCVE(detectionId, std::move(detection));
    scanContext->m_vulnerabilitySource = {"nvd", "nvd"};

    spGlobalDataMock = std::make_shared<MockGlobalData>();
    static const std::string managerNameStr = MANAGER_NAME;
    EXPECT_CALL(*spGlobalDataMock, managerName()).WillRepeatedly(testing::ReturnRef(managerNameStr));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(testing::ReturnRef(ADP_DESCRIPTIONS));

    TEventDetailsBuilder<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache, GlobalData>, TrampolineGlobalData>
        eventDetailsBuilder(spDatabaseFeedManagerMock);

    auto result = eventDetailsBuilder.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    auto* eventJson = result->getECSEvent(detectionId);
    ASSERT_NE(eventJson, nullptr);

    auto event = nlohmann::json::parse(*eventJson);

    EXPECT_EQ(event["vulnerability"]["category"].get<std::string>(), "OS");

    EXPECT_TRUE(event.contains("package"));
    EXPECT_EQ(event["package"]["name"].get<std::string>(), "Windows 11");
    EXPECT_EQ(event["package"]["version"].get<std::string>(), "11.0.22000");
    EXPECT_EQ(event["package"]["type"].get<std::string>(), "windows");

    EXPECT_TRUE(event.contains("host"));
    EXPECT_TRUE(event["host"].contains("os"));
    EXPECT_EQ(event["host"]["os"]["name"].get<std::string>(), "Windows 11");
    EXPECT_EQ(event["host"]["os"]["platform"].get<std::string>(), "windows");
}
