/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * January 15, 2026.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "scanAgentList_test.hpp"
#include "../scanOrchestrator/agentReScanListException.hpp"
#include "../scanOrchestrator/scanAgentList.hpp"
#include "MockIndexerConnector.hpp"
#include "json.hpp"

using ::testing::_;
using ::testing::Invoke;

namespace NSScanAgentListTest
{
    nlohmann::json makeSearchResponse(nlohmann::json hits)
    {
        return {{"hits", {{"hits", std::move(hits)}}}};
    }

    nlohmann::json makeOsHit()
    {
        return {{"_id", "os_001"},
                {"_source",
                 {{"host",
                   {{"architecture", "x86_64"},
                    {"hostname", "test-host"},
                    {"os", {{"name", "Ubuntu"}, {"platform", "ubuntu"}, {"type", "linux"}, {"version", "20.04"}}}}}}}};
    }

    nlohmann::json makeOsHitWithId(const std::string& id)
    {
        auto hit = makeOsHit();
        hit["_id"] = id;
        return hit;
    }

    nlohmann::json makePackageHit(const std::string& docId)
    {
        return {{"_id", docId},
                {"_source",
                 {{"package",
                   {{"name", "pkg"},
                    {"version", "1.0"},
                    {"architecture", "x86_64"},
                    {"format", "deb"},
                    {"vendor", "vendor"},
                    {"installed", "2026-01-01T00:00:00Z"}}}}}};
    }

    nlohmann::json makeHotfixHit()
    {
        return {{"_id", "hf_001"}, {"_source", {{"package", {{"hotfix", {{"name", "KB123"}}}}}}}};
    }

    AgentContextData makeAgent(std::string id)
    {
        AgentContextData agent {};
        agent.id = std::move(id);
        agent.name = "agent-name";
        agent.version = "v5.0.0";
        agent.hostArchitecture = "x86_64";
        agent.hostHostname = "agent-host";
        agent.hostOsName = "Ubuntu";
        agent.hostOsPlatform = "ubuntu";
        agent.hostOsType = "linux";
        agent.hostOsVersion = "20.04";
        return agent;
    }
} // namespace NSScanAgentListTest

using namespace NSScanAgentListTest;

void ScanAgentListTest::SetUp() {}

void ScanAgentListTest::TearDown() {}

TEST_F(ScanAgentListTest, HandleRequestReturnsNullWithoutIndexerConnector)
{
    auto scanRunner = [](std::shared_ptr<ScanContext>) {
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(nullptr, scanRunner);

    auto data = std::make_shared<ScanContext>();
    EXPECT_EQ(scanAgents.handleRequest(data), nullptr);
}

TEST_F(ScanAgentListTest, HandleRequestReturnsNullOnNullContext)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    auto scanRunner = [](std::shared_ptr<ScanContext>) {
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _)).Times(0);
    EXPECT_EQ(scanAgents.handleRequest(nullptr), nullptr);
}

TEST_F(ScanAgentListTest, ScanRunnerNotConfiguredDoesNotThrow)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, {});

    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke([&](const std::string&, const nlohmann::json&) { return emptyResponse; }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    EXPECT_TRUE(result->m_agentsWithIncompletedScan.empty());
}

TEST_F(ScanAgentListTest, ScanRunnerThrowsAddsAgentToRescanList)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    auto scanRunner = [](std::shared_ptr<ScanContext>)
    {
        throw std::runtime_error("scan failed");
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke([&](const std::string&, const nlohmann::json&) { return emptyResponse; }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    try
    {
        scanAgents.handleRequest(data);
        FAIL() << "Expected AgentReScanListException";
    }
    catch (const AgentReScanListException& e)
    {
        ASSERT_EQ(e.agentList().size(), 1u);
        EXPECT_EQ(e.agentList()[0].id, "003");
    }
}

TEST_F(ScanAgentListTest, BuildsPackageContextFromDocIdSuffix)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    const auto osResponse = makeSearchResponse(nlohmann::json::array({makeOsHit()}));
    const auto packageResponse = makeSearchResponse(nlohmann::json::array({makePackageHit("wazuh_003_4a08e5")}));
    const auto hotfixResponse = makeSearchResponse(nlohmann::json::array({makeHotfixHit()}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(OS_INDEX))
                {
                    return osResponse;
                }
                if (index == std::string(PACKAGE_INDEX))
                {
                    return packageResponse;
                }
                if (index == std::string(HOTFIX_INDEX))
                {
                    return hotfixResponse;
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(scans.front()->packageCount(), 1u);
    EXPECT_EQ(scans.front()->hotfixCount(), 1u);
    EXPECT_EQ(std::string(scans.front()->osName()), "Ubuntu");
    EXPECT_NE(scans.front()->findPackageByDetectionBase("003_4a08e5"), nullptr);
}

TEST_F(ScanAgentListTest, UsesAgentOsWhenNoOsInventory)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke([&](const std::string&, const nlohmann::json&) { return emptyResponse; }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(std::string(scans.front()->osName()), "Ubuntu");
    EXPECT_EQ(std::string(scans.front()->osArchitecture()), "x86_64");
}

TEST_F(ScanAgentListTest, UsesInventoryDataEvenWhenIncomplete)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    nlohmann::json osHit = {{"_id", "os_001"}, {"_source", {{"host", {{"os", {{"name", "Debian"}}}}}}}};
    const auto osResponse = makeSearchResponse(nlohmann::json::array({osHit}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(OS_INDEX))
                {
                    return osResponse;
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(std::string(scans.front()->osName()), "Debian");
    EXPECT_EQ(std::string(scans.front()->osArchitecture()), "");
    EXPECT_EQ(std::string(scans.front()->osHostName()), "");
    EXPECT_EQ(std::string(scans.front()->osPlatform()), "");
    EXPECT_EQ(std::string(scans.front()->osKernelSysName()), "");
    EXPECT_EQ(std::string(scans.front()->osVersion()), "");
}

TEST_F(ScanAgentListTest, PaginatesInventoryResultsWhenPageIsFull)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    nlohmann::json firstPage = nlohmann::json::array();
    for (size_t i = 0; i < 1000; ++i)
    {
        firstPage.push_back(makeOsHitWithId("os_" + std::to_string(i)));
    }
    const auto osResponseFirst = makeSearchResponse(firstPage);
    const auto osResponseSecond = makeSearchResponse(nlohmann::json::array({makeOsHitWithId("os_last")}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    size_t osCalls = 0;
    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(OS_INDEX))
                {
                    ++osCalls;
                    return osCalls == 1 ? osResponseFirst : osResponseSecond;
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(osCalls, 2u);
    EXPECT_EQ(std::string(scans.front()->osName()), "Ubuntu");
}

TEST_F(ScanAgentListTest, SkipsHotfixWhenNameMissing)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    nlohmann::json hotfixHit = {{"_id", "hf_001"}, {"_source", {{"package", {{"hotfix", {{"name", ""}}}}}}}};
    const auto hotfixResponse = makeSearchResponse(nlohmann::json::array({hotfixHit}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(HOTFIX_INDEX))
                {
                    return hotfixResponse;
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(scans.front()->hotfixCount(), 0u);
}

TEST_F(ScanAgentListTest, HandlesOsQueryExceptionAndUsesAgentFallback)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(OS_INDEX))
                {
                    throw std::runtime_error("os query failed");
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(std::string(scans.front()->osName()), "Ubuntu");
    EXPECT_EQ(std::string(scans.front()->osArchitecture()), "x86_64");
}

TEST_F(ScanAgentListTest, HandlesPackageQueryExceptionAndKeepsOsData)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    const auto osResponse = makeSearchResponse(nlohmann::json::array({makeOsHit()}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(OS_INDEX))
                {
                    return osResponse;
                }
                if (index == std::string(PACKAGE_INDEX))
                {
                    throw std::runtime_error("package query failed");
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(std::string(scans.front()->osName()), "Ubuntu");
    EXPECT_EQ(scans.front()->packageCount(), 0u);
}

TEST_F(ScanAgentListTest, HandlesHotfixQueryExceptionAndKeepsPackages)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    const auto osResponse = makeSearchResponse(nlohmann::json::array({makeOsHit()}));
    const auto packageResponse = makeSearchResponse(nlohmann::json::array({makePackageHit("wazuh_003_deadbeef")}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(OS_INDEX))
                {
                    return osResponse;
                }
                if (index == std::string(PACKAGE_INDEX))
                {
                    return packageResponse;
                }
                if (index == std::string(HOTFIX_INDEX))
                {
                    throw std::runtime_error("hotfix query failed");
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(scans.front()->packageCount(), 1u);
    EXPECT_EQ(scans.front()->hotfixCount(), 0u);
}

TEST_F(ScanAgentListTest, ParsesOsDistributionAndKernelData)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    nlohmann::json osHit = {{"_id", "os_001"},
                            {"_source",
                             {{"host",
                               {{"architecture", "x86_64"},
                                {"hostname", "test-host"},
                                {"os",
                                 {{"name", "Ubuntu"},
                                  {"platform", "ubuntu"},
                                  {"type", "linux"},
                                  {"version", "22.04"},
                                  {"full", "Ubuntu 22.04.3 LTS"},
                                  {"distribution", {{"release", "jammy"}}},
                                  {"kernel", {{"version", "5.15.0"}, {"release", "5.15.0-100"}}}}}}}}}};
    const auto osResponse = makeSearchResponse(nlohmann::json::array({osHit}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(OS_INDEX))
                {
                    return osResponse;
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(std::string(scans.front()->osDisplayVersion()), "Ubuntu 22.04.3 LTS");
    EXPECT_EQ(std::string(scans.front()->osRelease()), "jammy");
    EXPECT_EQ(std::string(scans.front()->osKernelVersion()), "5.15.0");
    EXPECT_EQ(std::string(scans.front()->osKernelRelease()), "5.15.0-100");
}

TEST_F(ScanAgentListTest, UsesDocIdWhenNoSeparator)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    const auto packageResponse = makeSearchResponse(nlohmann::json::array({makePackageHit("packageid")}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(PACKAGE_INDEX))
                {
                    return packageResponse;
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(scans.front()->packageCount(), 1u);
    EXPECT_NE(scans.front()->findPackageByDetectionBase("003_packageid"), nullptr);
}

TEST_F(ScanAgentListTest, SkipsPackageWhenDocIdMissingOrEmptySuffix)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    nlohmann::json missingIdHit = {{"_source", {{"package", {{"name", "pkg"}}}}}};
    const auto packageResponse =
        makeSearchResponse(nlohmann::json::array({missingIdHit, makePackageHit("wazuh_003_")}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(PACKAGE_INDEX))
                {
                    return packageResponse;
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(scans.front()->packageCount(), 0u);
}

TEST_F(ScanAgentListTest, SkipsMalformedInventoryResponses)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    const auto missingHitsArray = nlohmann::json {{"hits", nlohmann::json::object()}};
    const auto hitsNotArray = nlohmann::json {{"hits", {{"hits", nlohmann::json::object()}}}};

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(OS_INDEX))
                {
                    return missingHitsArray;
                }
                if (index == std::string(PACKAGE_INDEX))
                {
                    return hitsNotArray;
                }
                if (index == std::string(HOTFIX_INDEX))
                {
                    return missingHitsArray;
                }
                return nlohmann::json::object();
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(scans.front()->packageCount(), 0u);
    EXPECT_EQ(scans.front()->hotfixCount(), 0u);
    EXPECT_EQ(std::string(scans.front()->osName()), "Ubuntu");
    EXPECT_EQ(std::string(scans.front()->osArchitecture()), "x86_64");
}

TEST_F(ScanAgentListTest, SkipsPackageWhenNameMissing)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    nlohmann::json noNameHit = {{"_id", "wazuh_003_noname"}, {"_source", {{"package", {{"version", "1.0"}}}}}};
    const auto packageResponse = makeSearchResponse(nlohmann::json::array({noNameHit}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(PACKAGE_INDEX))
                {
                    return packageResponse;
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(scans.front()->packageCount(), 0u);
    EXPECT_EQ(scans.front()->findPackageByDetectionBase("003_noname"), nullptr);
}

TEST_F(ScanAgentListTest, BuildsPackageContextWithSizeAndVendor)
{
    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    std::vector<std::shared_ptr<ScanContext>> scans;
    auto scanRunner = [&](std::shared_ptr<ScanContext> ctx)
    {
        scans.push_back(std::move(ctx));
    };
    TScanAgentList<ScanContext, MockIndexerConnector> scanAgents(indexerConnector, scanRunner);

    nlohmann::json packageHit = {{"_id", "wazuh_003_deadbeef"},
                                 {"_source",
                                  {{"package",
                                    {{"name", "pkg"},
                                     {"version", "1.0"},
                                     {"architecture", "x86_64"},
                                     {"type", "deb"},
                                     {"vendor", "Acme"},
                                     {"description", "desc"},
                                     {"installed", "2026-01-01T00:00:00Z"},
                                     {"path", "/opt/pkg"},
                                     {"priority", "required"},
                                     {"source", "src"},
                                     {"multiarch", "same"},
                                     {"category", "base"},
                                     {"size", 42}}}}}};
    const auto packageResponse = makeSearchResponse(nlohmann::json::array({packageHit}));
    const auto emptyResponse = makeSearchResponse(nlohmann::json::array());

    EXPECT_CALL(*indexerConnector, executeSearchQuery(_, _))
        .WillRepeatedly(Invoke(
            [&](const std::string& index, const nlohmann::json&)
            {
                if (index == std::string(PACKAGE_INDEX))
                {
                    return packageResponse;
                }
                return emptyResponse;
            }));

    auto data = std::make_shared<ScanContext>();
    data->m_agents.emplace_back(makeAgent("003"));

    auto result = scanAgents.handleRequest(data);
    ASSERT_NE(result, nullptr);
    ASSERT_EQ(scans.size(), 1u);
    EXPECT_EQ(scans.front()->packageCount(), 1u);

    const auto* pkg = scans.front()->findPackageByDetectionBase("003_deadbeef");
    ASSERT_NE(pkg, nullptr);
    EXPECT_EQ(pkg->size, 42u);
    EXPECT_EQ(pkg->vendor, "Acme");
    EXPECT_EQ(pkg->description, "desc");
    EXPECT_EQ(pkg->groups, "base");
    EXPECT_EQ(pkg->location, "/opt/pkg");
    EXPECT_EQ(pkg->priority, "required");
    EXPECT_EQ(pkg->source, "src");
    EXPECT_EQ(pkg->multiarch, "same");
    EXPECT_EQ(pkg->architecture, "x86_64");
    EXPECT_EQ(pkg->format, "deb");
    EXPECT_EQ(pkg->install_time, "2026-01-01T00:00:00Z");
}
