/*
 * Wazuh databaseFeedManager
 * Copyright (C) 2015, Wazuh Inc.
 * September 22, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "databaseFeedManager_test.h"
#include "MockContentRegister.hpp"
#include "MockPolicyManager.hpp"
#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/idl.h"
#include <atomic>
#include <filesystem>
#include <string_view>

using ::testing::_;
using ::testing::Return;

constexpr auto COMMON_DATABASE_DIR {"queue/vd"};        //<<Used for all databases
constexpr auto COMMON_UPDATER_DIR {"queue/vd_updater"}; //<<Used for all updaters
constexpr auto CVEID_TEST_OK {"cveid_test_ok"};
constexpr auto CVEID_TEST_NOT_FOUND {"cveid_test_not_found"};
constexpr auto CVEID_TEST_CORRUPTED {"cveid_test_corrupted"};
constexpr auto CVE_ID {"CVE-2024-1111"};
const std::string CANDIDATE_FLATBUFFER_SCHEMA {FLATBUFFER_SCHEMAS_DIR "/vulnerabilityCandidate.fbs"};
const std::string TRANSLATION_FLATBUFFER_SCHEMA {FLATBUFFER_SCHEMAS_DIR "/packageTranslation.fbs"};

// Variables used for candidate tests
const std::string VULNERABILITY_CANDIDATE_EXAMPLE = R"(
[
    {
        "candidates": [
            {
                "cveId": "CVE-1999-1234",
                "defaultStatus": "unaffected",
                "platforms": [
                    "ubuntu"
                ],
                "versions": [
                    {
                        "status": "affected",
                        "version": "1.0.2"
                    },
                    {
                        "lessThan": "1.1.5-1",
                        "status": "affected",
                        "version": "0",
                        "versionType": "deb"
                    },
                    {
                        "lessThan": "*",
                        "status": "affected",
                        "version": "0",
                        "versionType": "custom"
                    }
                ]
            }
        ]
    },
    {
        "candidates": [
            {
                "cveId": "CVE-1999-1235",
                "defaultStatus": "unaffected",
                "platforms": [
                    "ubuntu"
                ],
                "versions": [
                    {
                        "status": "affected",
                        "version": "1.0.2"
                    },
                    {
                        "lessThan": "1.1.5-1",
                        "status": "affected",
                        "version": "0",
                        "versionType": "deb"
                    },
                    {
                        "lessThan": "*",
                        "status": "affected",
                        "version": "0",
                        "versionType": "custom"
                    }
                ]
            }
        ]
    }
]
)";

const std::string TRANSLATION_EXAMPLE = R"***(
{
    "target": [
        "windows"
    ],
    "source":
    {
        "vendor": "Microsoft Corporation",
        "product": "^Microsoft ASP.NET Core ([0-9]\\.*[0-9]*\\.*[0-9]*)",
        "version": "^Microsoft ASP.NET Core ([0-9]\\.*[0-9]*\\.*[0-9]*)"
    },
    "translation":
    [
        {
            "vendor": "microsoft",
            "product": "asp.net_core",
            "version": ""
        }
    ],
    "action":
    [
        "replace_vendor",
        "set_version_if_product_matches",
        "replace_product"
    ]
}
)***";

const std::string CNA_NAME {"cnaName"};
const std::string PACKAGE_NAME {"libmagic-mgc"};
const std::string CORRUPTED_PACKAGE_NAME {"libcorrupted"};
const nlohmann::json CNA_MAPPINGS = R"***(
{
  "cnaMapping": {
    "alas": "alas_$(MAJOR_VERSION)",
    "alma": "alma_$(MAJOR_VERSION)",
    "redhat": "redhat_$(MAJOR_VERSION)",
    "suse": "$(PLATFORM)_$(MAJOR_VERSION)"
  },
  "majorVersionEquivalence": {
    "amzn": {
      "2018": "1"
    }
  },
  "platformEquivalence": {
    "sled": "suse_desktop",
    "sles": "suse_server"
  }
}
)***"_json;

// External shared pointers definitions
std::shared_ptr<MockPolicyManager> spPolicyManagerMock;
std::shared_ptr<MockContentRegister> spContentRegisterMock;

void DatabaseFeedManagerTest::SetUp()
{
    // Initialize database
    Utils::RocksDBWrapper rocksDBWrapper(DATABASE_PATH);
    std::filesystem::create_directories(COMMON_DATABASE_DIR);

    // Common variables
    uint8_t* buffer;
    std::string schemaStr;
    nlohmann::json jsonData;
    flatbuffers::Parser parser;

    if (!rocksDBWrapper.columnExists(CNA_NAME))
    {
        rocksDBWrapper.createColumn(CNA_NAME);
    }
    jsonData = nlohmann::json::parse(VULNERABILITY_CANDIDATE_EXAMPLE);
    assert(!jsonData.empty());
    assert(flatbuffers::LoadFile(CANDIDATE_FLATBUFFER_SCHEMA.c_str(), false, &schemaStr) == true);
    assert(parser.Parse(schemaStr.c_str()) == true);

    for (const auto& item : jsonData)
    {
        assert(parser.Parse(item.dump().c_str()) == true);

        buffer = parser.builder_.GetBufferPointer();
        const rocksdb::Slice vulnerabilityCandidate(reinterpret_cast<const char*>(buffer), parser.builder_.GetSize());

        rocksDBWrapper.put(PACKAGE_NAME + "_" + item.at("candidates").at(0).at("cveId").get<std::string>(),
                           vulnerabilityCandidate,
                           CNA_NAME);

        parser.builder_.Clear();
    }

    // Create columns
    if (!rocksDBWrapper.columnExists(TRANSLATIONS_COLUMN))
    {
        rocksDBWrapper.createColumn(TRANSLATIONS_COLUMN);
    }

    jsonData = nlohmann::json::parse(TRANSLATION_EXAMPLE);
    assert(!jsonData.empty());
    assert(flatbuffers::LoadFile(TRANSLATION_FLATBUFFER_SCHEMA.c_str(), false, &schemaStr) == true);
    assert(parser.Parse(schemaStr.c_str()) == true);
    assert(parser.Parse(jsonData.dump().c_str()) == true);

    buffer = parser.builder_.GetBufferPointer();
    const rocksdb::Slice translation(reinterpret_cast<const char*>(buffer), parser.builder_.GetSize());

    rocksDBWrapper.put("TID-001", translation, TRANSLATIONS_COLUMN);

    if (!rocksDBWrapper.columnExists(VENDOR_MAP_COLUMN))
    {
        rocksDBWrapper.createColumn(VENDOR_MAP_COLUMN);
    }
    auto map = R"({"prefix": [],
                   "contains": [],
                   "format": [],
                   "source": [],
                   "adp_descriptions" : {
                        "nvd" : {
                            "cvss" : "nvd",
                            "description" : "nvd"
                        },
                        "canonical" : {
                            "cvss" : "canonical",
                            "description" : "nvd"
                        },
                        "vendor" : {
                            "cvss" : "vendor",
                            "description" : "nvd",
                            "reference" : "vendor"
                        },
                        "incomplete_vendor" : {
                            "cvss" : "incomplete_vendor",
                            "description" : "incomplete_vendor"
                        }
                    }
                })";

    rocksDBWrapper.put("FEED-GLOBAL", map, VENDOR_MAP_COLUMN);

    // Mock os cpe rules
    if (!rocksDBWrapper.columnExists(OS_CPE_RULES_COLUMN))
    {
        rocksDBWrapper.createColumn(OS_CPE_RULES_COLUMN);
    }
    auto osCpeRules = R"({})";

    rocksDBWrapper.put("OSCPE-GLOBAL", osCpeRules, OS_CPE_RULES_COLUMN);

    // Mock cna mapping
    if (!rocksDBWrapper.columnExists(CNA_MAPPING_COLUMN))
    {
        rocksDBWrapper.createColumn(CNA_MAPPING_COLUMN);
    }
    rocksDBWrapper.put("CNA-MAPPING-GLOBAL", CNA_MAPPINGS.dump(), CNA_MAPPING_COLUMN);

    // Mock NVD description data
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto nvdDescriptionOffset =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     "AccessComplexityStrNvd",
                                                                     "AssignerStr",
                                                                     "AttackVectorStrNvd",
                                                                     "AuthenticationStrNvd",
                                                                     "AvailabilityStrNvd",
                                                                     "ClassificationStrNvd",
                                                                     "ConfidentialityImpactStrNvd",
                                                                     "CWEIdStrNvd",
                                                                     "DataPublishedStr",
                                                                     "DataUpdatedStr",
                                                                     "DescriptionStrNvd",
                                                                     "IntegrityImpactStrNvd",
                                                                     "PrivilegesRequiredStrNvd",
                                                                     "ReferenceStrNvd",
                                                                     "ScopeStrNvd",
                                                                     1,
                                                                     "ScoreVersionStrNvd",
                                                                     "SeverityStrNvd",
                                                                     "UserInteractionStrNvd");

    fbBuilder.Finish(nvdDescriptionOffset);

    auto descriptionColumn = std::string(DESCRIPTIONS_COLUMN) + "_" + DEFAULT_ADP;
    if (!rocksDBWrapper.columnExists(descriptionColumn))
    {
        rocksDBWrapper.createColumn(descriptionColumn);
    }
    rocksdb::Slice nvdDescriptionSlice(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()),
                                       fbBuilder.GetSize());

    rocksDBWrapper.put(CVE_ID, nvdDescriptionSlice, descriptionColumn);

    if (!rocksDBWrapper.columnExists(std::string(DESCRIPTIONS_COLUMN) + "_empty"))
    {
        rocksDBWrapper.createColumn(std::string(DESCRIPTIONS_COLUMN) + "_empty");
    }
};

void DatabaseFeedManagerTest::TearDown()
{
    spPolicyManagerMock.reset();
    spContentRegisterMock.reset();
    std::filesystem::remove_all(COMMON_DATABASE_DIR);
};

/**
 * @brief Test the getVulnerabilityDescriptiveInformation method.
 *
 */
TEST_F(DatabaseFeedManagerTest, getVulnerabilityDescriptiveInformation)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return FileProcessingResult {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    std::shared_mutex mutex;

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription> container;

    EXPECT_TRUE(spDatabaseFeedManager->getVulnerabilityDescriptiveInformation(CVE_ID, DEFAULT_ADP, container));
    EXPECT_STREQ(container.data->accessComplexity()->c_str(), "AccessComplexityStrNvd");
    EXPECT_STREQ(container.data->assignerShortName()->c_str(), "AssignerStr");
    EXPECT_STREQ(container.data->attackVector()->c_str(), "AttackVectorStrNvd");
    EXPECT_STREQ(container.data->authentication()->c_str(), "AuthenticationStrNvd");
    EXPECT_STREQ(container.data->availabilityImpact()->c_str(), "AvailabilityStrNvd");
    EXPECT_STREQ(container.data->classification()->c_str(), "ClassificationStrNvd");
    EXPECT_STREQ(container.data->confidentialityImpact()->c_str(), "ConfidentialityImpactStrNvd");
    EXPECT_STREQ(container.data->cweId()->c_str(), "CWEIdStrNvd");
    EXPECT_STREQ(container.data->datePublished()->c_str(), "DataPublishedStr");
    EXPECT_STREQ(container.data->dateUpdated()->c_str(), "DataUpdatedStr");
    EXPECT_STREQ(container.data->description()->c_str(), "DescriptionStrNvd");
    EXPECT_STREQ(container.data->integrityImpact()->c_str(), "IntegrityImpactStrNvd");
    EXPECT_STREQ(container.data->privilegesRequired()->c_str(), "PrivilegesRequiredStrNvd");
    EXPECT_STREQ(container.data->reference()->c_str(), "ReferenceStrNvd");
    EXPECT_STREQ(container.data->scope()->c_str(), "ScopeStrNvd");
    EXPECT_FLOAT_EQ(container.data->scoreBase(), 1);
    EXPECT_STREQ(container.data->scoreVersion()->c_str(), "ScoreVersionStrNvd");
    EXPECT_STREQ(container.data->severity()->c_str(), "SeverityStrNvd");
    EXPECT_STREQ(container.data->userInteraction()->c_str(), "UserInteractionStrNvd");

    // Retrieve from empty source
    EXPECT_FALSE(spDatabaseFeedManager->getVulnerabilityDescriptiveInformation(CVE_ID, "empty", container));
    EXPECT_EQ(container.data, nullptr);

    // Retrieve from non-existing CVE
    EXPECT_FALSE(
        spDatabaseFeedManager->getVulnerabilityDescriptiveInformation("non_existing_cve", DEFAULT_ADP, container));
    EXPECT_EQ(container.data, nullptr);

    // Retrieve from non-existing source
    EXPECT_THROW(
        spDatabaseFeedManager->getVulnerabilityDescriptiveInformation(CVE_ID, "non_existing_source", container);
        , std::runtime_error);
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityCandidatesCorrupted)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return FileProcessingResult {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;

    {
        uint8_t corruptedData[] = {
            0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF};
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(DATABASE_PATH);
        rocksdb::Slice dbValue(reinterpret_cast<const char*>(corruptedData), sizeof(corruptedData));
        dbWrapper->put(std::string(CORRUPTED_PACKAGE_NAME) + "_CVE-2023-7845", dbValue, CNA_NAME);
    }

    auto pDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    PackageData package = {.name = CORRUPTED_PACKAGE_NAME};

    EXPECT_THROW(
        {
            pDatabaseFeedManager->getVulnerabilitiesCandidates(
                CNA_NAME,
                package,
                [&](const std::string& cnaName,
                    const PackageData& package,
                    const NSVulnerabilityScanner::ScanVulnerabilityCandidate& candidate) -> bool { return true; });
        },
        std::runtime_error);
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityCandidatesNoPackageName)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return FileProcessingResult {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;

    auto pDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    PackageData package = {.name = ""};

    EXPECT_ANY_THROW({
        pDatabaseFeedManager->getVulnerabilitiesCandidates(
            CNA_NAME,
            package,
            [&](const std::string& cnaName,
                const PackageData& package,
                const NSVulnerabilityScanner::ScanVulnerabilityCandidate& candidate) -> bool { return true; });
    });
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityRemediation_ValidData)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return FileProcessingResult {0, "", true};
    };

    {
        spContentRegisterMock = std::make_shared<MockContentRegister>(
            configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

        {
            std::string key_dummy {"CVE-2023-2609"};
            flatbuffers::FlatBufferBuilder builder;
            auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(DATABASE_PATH);

            std::vector<flatbuffers::Offset<flatbuffers::String>> updates_vec;
            updates_vec.push_back(builder.CreateString("KB2023"));
            auto updates = builder.CreateVector(updates_vec);
            auto dummy = CreateRemediationInfo(builder, updates);
            builder.Finish(dummy);

            rocksdb::Slice value(reinterpret_cast<const char*>(builder.GetBufferPointer()), builder.GetSize());

            if (!dbWrapper->columnExists(REMEDIATIONS_COLUMN))
            {
                dbWrapper->createColumn(REMEDIATIONS_COLUMN);
            }
            dbWrapper->put(key_dummy, value, REMEDIATIONS_COLUMN);
        }

        auto shouldStop {std::make_shared<ConditionSync>(false)};
        std::shared_mutex mutex;

        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        // Variables setup
        std::string cveId {"CVE-2023-2609"};
        FlatbufferDataPair<RemediationInfo> dtoVulnRemediation;

        // Asserts
        ASSERT_NO_THROW(spDatabaseFeedManager->getVulnerabilityRemediation(cveId, dtoVulnRemediation));
        ASSERT_STREQ(dtoVulnRemediation.data->updates()->Get(0)->str().c_str(), "KB2023");
    }
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityRemediation_DataNotFound)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return FileProcessingResult {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    std::string cveId {"CVE-2023-5678"};
    FlatbufferDataPair<RemediationInfo> dtoVulnRemediation;

    ASSERT_THROW(spDatabaseFeedManager->getVulnerabilityRemediation(cveId, dtoVulnRemediation), std::runtime_error);
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityRemediation_InvalidData)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return FileProcessingResult {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    {
        uint8_t corruptedData[] = {
            0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF};
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(DATABASE_PATH);
        rocksdb::Slice dbValue(reinterpret_cast<const char*>(corruptedData), sizeof(corruptedData));
        dbWrapper->put("CVE-2023-2609", dbValue);
    }

    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    std::string cveId {"CVE-2023-2609"};
    FlatbufferDataPair<RemediationInfo> dtoVulnRemediation;

    ASSERT_THROW(spDatabaseFeedManager->getVulnerabilityRemediation(cveId, dtoVulnRemediation), std::runtime_error);
}

void databaseFeedManagerTestGracefulShutdown()
{
    // Test setup
    nlohmann::json jsonFileContent;
    nlohmann::json jsonItem = R"(
        {
            "offset": 0,
            "type": "create",
            "version": 1,
            "context": "all_vendors_071123",
            "resource": "CVE-0000-0000",
            "payload": {
                "containers": {
                    "cna": {
                        "providerMetadata": {
                            "dateUpdated": "2017-05-11T14:29:20Z",
                            "orgId": "00000000-0000-4000-A000-000000000003",
                            "shortName": "nvd"
                        },
                        "rejectedReasons": [
                            {
                                "lang": "en",
                                "value": "** REJECT **"
                            }
                        ]
                    }
                },
                "cveMetadata": {
                    "assignerOrgId": "00000000-0000-4000-A000-000000000003",
                    "assignerShortName": "nvd",
                    "cveId": "CVE-0000-0000",
                    "datePublished": "2017-05-11T14:29:20Z",
                    "dateUpdated": "2017-05-11T14:29:20Z",
                    "state": "REJECTED"
                },
                "dataType": "CVE_RECORD",
                "dataVersion": "5.0"
            }
        }
    )"_json;
    int cveNumber = 1;
    for (auto itemNumber = 0; itemNumber < 1000; itemNumber++)
    {
        jsonItem["offset"] = 57001 + itemNumber;
        std::ostringstream itemCVEId;
        itemCVEId << "CVE-" << std::dec << std::setw(4) << std::setfill('0') << (std::rand() % 20 + 2000) << "-"
                  << std::dec << std::setw(4) << std::setfill('0') << itemNumber;
        jsonItem["resource"] = itemCVEId.str();
        jsonItem["payload"]["cveMetadata"]["cveId"] = itemCVEId.str();
        jsonFileContent["data"].push_back(jsonItem);
    }

    std::ofstream file {"GracefulShutdown.json"};
    file << jsonFileContent.dump();

    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return FileProcessingResult {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    auto messageJson = R"(
    {
        "type": "offsets",
        "offset": 57000,
        "paths":
        [
            "GracefulShutdown.json"
        ],
        "stageStatus":
        [
            {
                "stage": "download",
                "status": "ok"
            }
        ]
    }
    )"_json;

    message = messageJson.dump();
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;

    auto gracefullShutdownElements =
        static_cast<int>(nlohmann::json::parse(std::ifstream("GracefulShutdown.json")).at("data").size());

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister2>>(mutex, updaterConfig, translationLruSize)};

    std::this_thread::sleep_for(std::chrono::seconds(1));
    spDatabaseFeedManager.reset();

    std::remove("GracefulShutdown.json");
}

TEST_F(DatabaseFeedManagerTest, GracefulShutdown)
{
    EXPECT_NO_THROW(databaseFeedManagerTestGracefulShutdown());
}

/**
 * @brief SetUp.
 *
 */
void DatabaseFeedManagerMessageProcessorTest::SetUp()
{
    std::ofstream file1 {"file1.json"};
    file1 << R"({invalid:json})";

    std::ofstream file2 {"file2.json"};
    file2 << R"({"field":"value"})";

    std::ofstream file3 {"file3.json"};
    file3 << R"({"data": [{"resource":"element1","offset":1}]})";

    std::ofstream file4 {"file4.json"};
    // add feed-global to db
    file4
        << R"({"name": "FEED-GLOBAL", "offset": 1234, "payload":{"prefix": [],"contains": [],"format": [], "source": []}})";
    // Add new line
    file4 << "\n";
    // add oscpe-global to db
    file4 << R"({"name": "OSCPE-GLOBAL", "offset": 1234, "payload":{}})";

    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    std::filesystem::create_directories(COMMON_DATABASE_DIR);
    auto spRocksDBWrapper = std::make_unique<Utils::RocksDBWrapper>(DATABASE_PATH);

    if (!spRocksDBWrapper->columnExists(VENDOR_MAP_COLUMN))
    {
        spRocksDBWrapper->createColumn(VENDOR_MAP_COLUMN);
    }

    auto map = R"({"prefix": [],"contains": [],"format": [], "source": []})";

    spRocksDBWrapper->put("FEED-GLOBAL", map, VENDOR_MAP_COLUMN);

    // Mock os cpe rules
    if (!spRocksDBWrapper->columnExists(OS_CPE_RULES_COLUMN))
    {
        spRocksDBWrapper->createColumn(OS_CPE_RULES_COLUMN);
    }
    auto osCpeRules = R"({})";

    spRocksDBWrapper->put("OSCPE-GLOBAL", osCpeRules, OS_CPE_RULES_COLUMN);

    // Mock cna mapping
    if (!spRocksDBWrapper->columnExists(CNA_MAPPING_COLUMN))
    {
        spRocksDBWrapper->createColumn(CNA_MAPPING_COLUMN);
    }
    spRocksDBWrapper->put("CNA-MAPPING-GLOBAL", CNA_MAPPINGS.dump(), CNA_MAPPING_COLUMN);

    // Mock translations
    if (!spRocksDBWrapper->columnExists(TRANSLATIONS_COLUMN))
    {
        spRocksDBWrapper->createColumn(TRANSLATIONS_COLUMN);
    }

    spRocksDBWrapper.reset();
};

/**
 * @brief TearDown.
 *
 */
void DatabaseFeedManagerMessageProcessorTest::TearDown()
{
    std::remove("file1.json");
    std::remove("file2.json");
    std::remove("file3.json");
    std::remove("file4.json");

    // Reset shared_ptr owner
    spPolicyManagerMock.reset();
    spContentRegisterMock.reset();
    std::filesystem::remove_all(COMMON_DATABASE_DIR);
};

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestInvalidJson)
{
    std::string message = R"({invalid_json})";

    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    try
    {
        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        spDatabaseFeedManager->processMessage(message, dbWrapper);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid message. Missing required fields.");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestNoType)
{
    std::string message = R"({"field":"value","paths":["file1.json"]})";
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    try
    {
        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        spDatabaseFeedManager->processMessage(message, dbWrapper);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid message. Missing required fields.");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestInvalidType)
{
    std::string message = R"({"type":"invalid","offset":1234,"paths":["file1.json"]})";
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    try
    {
        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        spDatabaseFeedManager->processMessage(message, dbWrapper);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid message. Unknown type.");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestNoPaths)
{
    std::string message = R"({"type":"offsets","offset":1234,"field":"value"})";
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    try
    {
        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        spDatabaseFeedManager->processMessage(message, dbWrapper);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid message. Missing required fields.");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestOffsetFileWithInvalidJson)
{
    std::string message = R"({"type":"offsets","offset":1234,"paths":["file1.json"]})";

    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    try
    {
        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        spDatabaseFeedManager->processMessage(message, dbWrapper);

        FAIL() << "Expected parse_error exception";
    }
    catch (const nlohmann::detail::parse_error& e)
    {
        EXPECT_STREQ(e.what(),
                     "[json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing "
                     "object key - invalid literal; last read: '{i'; expected string literal");
    }
    catch (const std::exception& e)
    {
        FAIL() << "Expect another exception, throw message: " << e.what();
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestOffsetFileWithNoData)
{
    std::string message = R"({"type":"offsets","offset":1234,"paths":["file2.json"]})";
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    try
    {
        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        spDatabaseFeedManager->processMessage(message, dbWrapper);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "The target array does not exist.");
    }
    catch (const std::exception& e)
    {
        FAIL() << "Expect another exception, throw message: " << e.what();
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestOffsetFileWithDataSuccess)
{
    std::string message = R"({"type":"offsets","offset":1234,"paths":["file3.json"]})";

    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return FileProcessingResult {0, "", true};
    };

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    EXPECT_NO_THROW(spDatabaseFeedManager->processMessage(message, dbWrapper));
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestRawFileWithNonExistingFile)
{
    std::string message = R"({"type":"raw","offset":1234,"paths":["non_existing.json"]})";
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop = std::make_shared<ConditionSync>(false);
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    try
    {
        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        spDatabaseFeedManager->processMessage(message, dbWrapper);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Unable to open input file: non_existing.json");
    }
    catch (const std::exception& e)
    {
        FAIL() << "Expect another exception, throw message: " << e.what();
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestRawFileWithInvalidLine)
{
    std::string message = R"({"type":"raw","offset":1234,"paths":["file1.json"]})";
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop = std::make_shared<ConditionSync>(false);
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    try
    {
        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        spDatabaseFeedManager->processMessage(message, dbWrapper);
        FAIL() << "Expected parse_error exception";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid line found in file: file1.json");
    }
    catch (const std::exception& e)
    {
        FAIL() << "Expect another exception, throw message: " << e.what();
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestRawFileLineWithNoName)
{
    std::string message = R"({"type":"raw","offset":1234,"paths":["file2.json"]})";
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    try
    {
        auto spDatabaseFeedManager {std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(
            mutex, updaterConfig, translationLruSize)};

        spDatabaseFeedManager->processMessage(message, dbWrapper);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid line found in file: file2.json");
    }
    catch (const std::exception& e)
    {
        FAIL() << "Expect another exception, throw message: " << e.what();
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestRawFileWithDataSuccess)
{
    std::string message = R"({"type":"raw","offset":1234,"paths":["file4.json"], "fileMetadata": {"hash": "1234"}})";
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    EXPECT_NO_THROW(spDatabaseFeedManager->processMessage(message, dbWrapper));
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestProcessingStop)
{
    std::string message = R"({"paths":["file5.json"],"type":"offsets","offset":1234,"fileMetadata":{"hash":"1234"}})";
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    int totalElements {10};
    auto fileData = R"({"data": []})"_json;
    for (auto i = 0; i < totalElements; i++)
    {
        nlohmann::json element;
        element["resource"] = "element" + std::to_string(i);
        element["offset"] = i;
        fileData["data"].push_back(element);
    }

    {
        std::ofstream file5 {"file5.json"};
        file5 << fileData.dump();
    }

    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return {0, "", true};
    };

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    EXPECT_NO_THROW(spDatabaseFeedManager->processMessage(message, dbWrapper));

    std::remove("file5.json");
    SUCCEED();
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestNoVendorMap)
{
    {
        auto spRocksDBWrapper = std::make_unique<Utils::RocksDBWrapper>(DATABASE_PATH);
        spRocksDBWrapper->delete_("FEED-GLOBAL", VENDOR_MAP_COLUMN);
    }

    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    std::filesystem::create_directories(COMMON_UPDATER_DIR);
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    EXPECT_FALSE(std::filesystem::exists(COMMON_UPDATER_DIR));
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestInvalidVendorMap)
{
    {
        auto spRocksDBWrapper = std::make_unique<Utils::RocksDBWrapper>(DATABASE_PATH);
        spRocksDBWrapper->put("FEED-GLOBAL", "invalid", VENDOR_MAP_COLUMN);
    }

    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    std::filesystem::create_directories(COMMON_UPDATER_DIR);

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};
    EXPECT_FALSE(std::filesystem::exists(COMMON_UPDATER_DIR));
}

void DatabaseFeedManagerVendorMapTest::SetUp()
{
    std::filesystem::create_directories(COMMON_DATABASE_DIR);
    m_spRocksDBWrapper = std::make_unique<Utils::RocksDBWrapper>(DATABASE_PATH);

    if (!m_spRocksDBWrapper->columnExists(VENDOR_MAP_COLUMN))
    {
        m_spRocksDBWrapper->createColumn(VENDOR_MAP_COLUMN);
    }

    if (!m_spRocksDBWrapper->columnExists(OS_CPE_RULES_COLUMN))
    {
        m_spRocksDBWrapper->createColumn(OS_CPE_RULES_COLUMN);
    }

    if (!m_spRocksDBWrapper->columnExists(TRANSLATIONS_COLUMN))
    {
        m_spRocksDBWrapper->createColumn(TRANSLATIONS_COLUMN);
    }

    auto map = R"(
          {
            "prefix": [
                {"Canonical":{"cna":"canonical", "platforms":["ubuntu"]}},
                {"Ubuntu": {"cna":"canonical", "platforms":["ubuntu"]}},
                {"CentOS": {"cna":"redhat", "platforms":["centos"]}}
            ],
            "contains": [
                {"@ubuntu.com": {"cna":"canonical", "platforms":["ubuntu"]}}
            ],
            "format": [
                {"pypi": "pypi"},
                {"npm": "npm"}
            ],
            "source": [
                {"homebrew": "homebrew"}
            ]
          })";

    auto oscpe_rules = R"({})";

    m_spRocksDBWrapper->put("FEED-GLOBAL", map, VENDOR_MAP_COLUMN);
    m_spRocksDBWrapper->put("OSCPE-GLOBAL", oscpe_rules, OS_CPE_RULES_COLUMN);

    m_spRocksDBWrapper.reset();

    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return FileProcessingResult {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    std::shared_mutex mutex;

    m_spDatabaseFeedManager =
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize);
}

void DatabaseFeedManagerVendorMapTest::TearDown()
{
    spPolicyManagerMock.reset();
    spContentRegisterMock.reset();
    m_spDatabaseFeedManager.reset();
    std::filesystem::remove_all(COMMON_DATABASE_DIR);
}

TEST_F(DatabaseFeedManagerVendorMapTest, TestGetCnaNameByFormat)
{
    auto cnaName = m_spDatabaseFeedManager->getCnaNameByFormat("pypi");
    EXPECT_EQ(cnaName, "pypi");

    cnaName = m_spDatabaseFeedManager->getCnaNameByFormat("PyPi");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByFormat("PyPi format");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByFormat("Formatted as PyPi package");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByFormat("npm");
    EXPECT_EQ(cnaName, "npm");

    cnaName = m_spDatabaseFeedManager->getCnaNameByFormat("NPM");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByFormat("NPM format");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByFormat("Formatted as NPM package");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByFormat("invalid");
    EXPECT_EQ(cnaName, "");
}

TEST_F(DatabaseFeedManagerVendorMapTest, TestGetCnaNameByPrefix)
{
    auto cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("Canonical", "ubuntu");
    EXPECT_EQ(cnaName, "canonical");

    cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("canonical", "ubuntu");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("Ubuntu", "ubuntu");
    EXPECT_EQ(cnaName, "canonical");

    cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("ubuntu", "ubuntu");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("This is a Canonical package", "ubuntu");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("CentOS", "centos");
    EXPECT_EQ(cnaName, "redhat");

    cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("centos", "centos");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("This is a CentOS package", "centos");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("invalid", "centos");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByPrefix("Ubuntu", "centos");
    EXPECT_EQ(cnaName, "");
}

TEST_F(DatabaseFeedManagerVendorMapTest, TestGetCnaNameByContains)
{
    auto cnaName = m_spDatabaseFeedManager->getCnaNameByContains("This is an Ubuntu package", "ubuntu");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByContains("John Doe <jdoe@ubuntu.com>", "ubuntu");
    EXPECT_EQ(cnaName, "canonical");

    cnaName = m_spDatabaseFeedManager->getCnaNameByContains("@ubuntu.com", "ubuntu");
    EXPECT_EQ(cnaName, "canonical");

    cnaName = m_spDatabaseFeedManager->getCnaNameByContains("@Ubuntu", "ubuntu");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByContains("invalid", "ubuntu");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameByContains("@ubuntu.com", "centos");
    EXPECT_EQ(cnaName, "");
}

TEST_F(DatabaseFeedManagerVendorMapTest, TestGetCnaNameBySource)
{
    auto cnaName = m_spDatabaseFeedManager->getCnaNameBySource(" ");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameBySource("linux-meta");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameBySource("python-click");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameBySource("util-linux");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameBySource("invalid");
    EXPECT_EQ(cnaName, "");

    cnaName = m_spDatabaseFeedManager->getCnaNameBySource("homebrew");
    EXPECT_EQ(cnaName, "homebrew");
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, FileProcessingOffsetAndHashUpdate)
{
    const auto databasePath =
        std::string(DATABASE_PATH) + "/" + ::testing::UnitTest::GetInstance()->current_test_info()->name();
    auto dbWrapper = std::make_shared<Utils::RocksDBWrapper>(databasePath);
    auto shouldStop {std::make_shared<ConditionSync>(false)};
    std::shared_mutex mutex;
    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};
    std::string message {R"(
        {
            "type": "raw",
            "offset": 0,
            "paths": [ "file4.json"],
            "fileMetadata": {
                "hash": "hash_value"
            }
        }
    )"};

    const auto [offset, hash, status] = spDatabaseFeedManager->processMessage(message, dbWrapper);
    EXPECT_EQ(offset, 1234);
    EXPECT_EQ(hash, "hash_value");
    EXPECT_EQ(status, true);
}

/**
 * @brief Test getHotfixVulnerabilities - Valid hotfix with vulnerabilities
 */
TEST_F(DatabaseFeedManagerTest, GetHotfixVulnerabilities_ValidHotfix)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    {
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(DATABASE_PATH);

        if (!dbWrapper->columnExists(HOTFIXES_APPLICATIONS_COLUMN))
        {
            dbWrapper->createColumn(HOTFIXES_APPLICATIONS_COLUMN);
        }

        dbWrapper->put("KB123456_CVE-2023-0001", "data1", HOTFIXES_APPLICATIONS_COLUMN);
        dbWrapper->put("KB123456_CVE-2023-0002", "data2", HOTFIXES_APPLICATIONS_COLUMN);
        dbWrapper->put("KB123456_CVE-2023-0003", "data3", HOTFIXES_APPLICATIONS_COLUMN);
    }

    std::shared_mutex mutex;
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    auto vulnerabilities = spDatabaseFeedManager->getHotfixVulnerabilities("KB123456");

    EXPECT_EQ(vulnerabilities.size(), 3);
    EXPECT_TRUE(vulnerabilities.find("KB123456_CVE-2023-0001") != vulnerabilities.end());
    EXPECT_TRUE(vulnerabilities.find("KB123456_CVE-2023-0002") != vulnerabilities.end());
    EXPECT_TRUE(vulnerabilities.find("KB123456_CVE-2023-0003") != vulnerabilities.end());
}

/**
 * @brief Test getHotfixVulnerabilities - Hotfix not found
 */
TEST_F(DatabaseFeedManagerTest, GetHotfixVulnerabilities_HotfixNotFound)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    std::shared_mutex mutex;
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    auto vulnerabilities = spDatabaseFeedManager->getHotfixVulnerabilities("KB999999");

    EXPECT_EQ(vulnerabilities.size(), 0);
}

/**
 * @brief Test getHotfixVulnerabilities - Column doesn't exist
 */
TEST_F(DatabaseFeedManagerTest, GetHotfixVulnerabilities_ColumnDoesNotExist)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    std::shared_mutex mutex;
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    auto vulnerabilities = spDatabaseFeedManager->getHotfixVulnerabilities("KB123456");

    EXPECT_EQ(vulnerabilities.size(), 0);
}

/**
 * @brief Test getCVEDatabase - Returns valid reference
 */
TEST_F(DatabaseFeedManagerTest, GetCVEDatabase_ValidReference)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    std::shared_mutex mutex;
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    auto& database = spDatabaseFeedManager->getCVEDatabase();

    EXPECT_NO_THROW({
        std::string testKey = "test_key";
        std::string testValue = "test_value";
        database.put(testKey, testValue);

        std::string retrievedValue;
        database.get(testKey, retrievedValue);
        EXPECT_EQ(retrievedValue, testValue);
    });
}

/**
 * @brief Test update - Changes scheduler interval
 */
TEST_F(DatabaseFeedManagerTest, Update_ChangesSchedulerInterval)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    bool callbackCalled = false;
    FileProcessingCallback dummyCallback = [&callbackCalled](const std::string& message) -> FileProcessingResult
    {
        callbackCalled = true;
        return {0, "", true};
    };

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    EXPECT_CALL(*spContentRegisterMock, changeSchedulerInterval(3600)).Times(1);

    std::shared_mutex mutex;
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    nlohmann::json updateData = {{"updater", {{"interval", 3600}}}};

    EXPECT_NO_THROW(spDatabaseFeedManager->update(updateData));
}

/**
 * @brief Test getCacheSizeFromConfig - Returns correct size
 */
TEST_F(DatabaseFeedManagerTest, GetCacheSizeFromConfig_ReturnsCorrectSize)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    std::shared_mutex mutex;
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    auto cacheSize = spDatabaseFeedManager->getCacheSizeFromConfig();

    EXPECT_EQ(cacheSize, 2048);
}

/**
 * @brief Test getTranslationFromL2 - Platform mismatch
 */
TEST_F(DatabaseFeedManagerTest, GetTranslationFromL2_PlatformMismatch)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    std::shared_mutex mutex;
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    PackageData package = {
        .name = "Microsoft ASP.NET Core 5.0.1", .vendor = "Microsoft Corporation", .format = "deb", .version = "5.0.1"};

    auto translations = spDatabaseFeedManager->getTranslationFromL2(package, "linux");

    EXPECT_TRUE(translations.empty());
}

/**
 * @brief Test getTranslationFromL2 - Product name doesn't match regex
 */
TEST_F(DatabaseFeedManagerTest, GetTranslationFromL2_ProductMismatch)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    std::shared_mutex mutex;
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    PackageData package = {
        .name = "Different Product Name", .vendor = "Microsoft Corporation", .format = "win", .version = "5.0.1"};

    auto translations = spDatabaseFeedManager->getTranslationFromL2(package, "windows");

    EXPECT_TRUE(translations.empty());
}

/**
 * @brief Test getTranslationFromL2 - Vendor doesn't match regex
 */
TEST_F(DatabaseFeedManagerTest, GetTranslationFromL2_VendorMismatch)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    FileProcessingCallback dummyCallback = [](const std::string& message) -> FileProcessingResult
    {
        return {0, "", true};
    };

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));
    EXPECT_CALL(*spPolicyManagerMock, getTranslationLRUSize()).WillRepeatedly(Return(2048));

    const auto updaterConfig = spPolicyManagerMock->getUpdaterConfiguration();
    const auto translationLruSize = spPolicyManagerMock->getTranslationLRUSize();

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters, dummyCallback);

    std::shared_mutex mutex;
    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineContentRegister>>(mutex, updaterConfig, translationLruSize)};

    PackageData package = {
        .name = "Microsoft ASP.NET Core 5.0.1", .vendor = "Different Vendor", .format = "win", .version = "5.0.1"};

    auto translations = spDatabaseFeedManager->getTranslationFromL2(package, "windows");

    EXPECT_TRUE(translations.empty());
}
