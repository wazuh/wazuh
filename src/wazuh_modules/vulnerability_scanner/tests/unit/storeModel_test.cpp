/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "storeModel_test.hpp"
#include "databaseFeedManager/eventContext.hpp"
#include "databaseFeedManager/storeModel.hpp"
#include "flatbuffers/idl.h"
#include <memory>
#include <string>
#include <vector>

const char* INCLUDE_DIRECTORIES[] = {FLATBUFFER_SCHEMAS_DIR, nullptr};
const std::string CVE5_FLATBUFFER_SCHEMA_PATH {FLATBUFFER_SCHEMAS_DIR "/cve5.fbs"};
const std::string CVE_UPDATE_EXAMPLE_SUCCESS {"CVE-2022-0605"};

const std::string CVE5_ENTRY_PUBLISHED = R"(
{
    "containers": {
        "cna": {
            "providerMetadata": {
                "dateUpdated": "2022-04-11T09:33:00Z",
                "orgId": "00000000-0000-4000-A000-000000000003",
                "shortName": "nvd"
            },
            "descriptions": [
                {
                    "lang": "en",
                    "value": "Use after free in Webstore API in Google Chrome prior to 98.0.4758.102"
                }
            ]
        }
    },
    "cveMetadata": {
        "assignerOrgId": "00000000-0000-4000-A000-000000000003",
        "assignerShortName": "nvd",
        "cveId": "CVE-2022-0605",
        "datePublished": "2022-04-05T00:15:00Z",
        "dateUpdated": "2022-04-11T09:33:00Z",
        "state": "PUBLISHED"
    },
    "dataType": "CVE_RECORD",
    "dataVersion": "5.0"
}
)";

const std::string CVE5_ENTRY_REJECTED = R"(
        {
            "containers": {
                "cna": {
                    "providerMetadata": {
                        "dateUpdated": "2023-03-09T14:02:53Z",
                        "orgId": "00000000-0000-4000-A000-000000000003",
                        "shortName": "nvd"
                    },
                    "rejectedReasons": [
                        {
                            "lang": "en",
                            "value": "This candidate was in a CNA pool that was not assigned to any issues during 2022."
                        }
                    ]
                }
            },
            "cveMetadata": {
                "assignerOrgId": "00000000-0000-4000-A000-000000000003",
                "assignerShortName": "nvd",
                "cveId": "CVE-2022-26053",
                "datePublished": "2023-03-07T23:15:10Z",
                "dateUpdated": "2023-03-09T14:02:53Z",
                "state": "REJECTED"
            },
            "dataType": "CVE_RECORD",
            "dataVersion": "5.0"
        }
    )";

const std::string CVE5_ENTRY_INVALID_STATE = R"(
        {
            "containers": {
                "cna": {
                    "providerMetadata": {
                        "dateUpdated": "2023-03-09T14:02:53Z",
                        "orgId": "00000000-0000-4000-A000-000000000003",
                        "shortName": "nvd"
                    },
                    "rejectedReasons": [
                        {
                            "lang": "en",
                            "value": "This candidate was in a CNA pool that was not assigned to any issues during 2022."
                        }
                    ]
                }
            },
            "cveMetadata": {
                "assignerOrgId": "00000000-0000-4000-A000-000000000003",
                "assignerShortName": "nvd",
                "cveId": "CVE-2022-26053",
                "datePublished": "2023-03-07T23:15:10Z",
                "dateUpdated": "2023-03-09T14:02:53Z",
                "state": "INVALID"
            },
            "dataType": "CVE_RECORD",
            "dataVersion": "5.0"
        }
    )";

/*
 * @brief Test handleRequest of the StoreModel class.
 */
TEST_F(StoreModelTest, TestHandleRequestCreate)
{
    std::string message;
    nlohmann::json resource;
    resource["type"] = "create";
    resource["offset"] = 123456;

    // Load schema from file
    std::string cve5SchemaStr;
    ASSERT_TRUE(flatbuffers::LoadFile(CVE5_FLATBUFFER_SCHEMA_PATH.c_str(), false, &cve5SchemaStr));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(cve5SchemaStr.c_str(), INCLUDE_DIRECTORIES) && parser.Parse(CVE5_ENTRY_PUBLISHED.c_str()));

    flatbuffers::FlatBufferBuilder& builder = parser.builder_;

    auto feedDatabase = std::make_shared<Utils::RocksDBWrapper>("temp");
    auto eventContext = std::make_shared<EventContext>(EventContext {
        .message = message, .resource = resource, .feedDatabase = feedDatabase, .resourceType = ResourceType::CVE});

    eventContext->cve5Buffer = builder.Release();

    std::shared_ptr<StoreModel> storeModel;

    EXPECT_NO_THROW(storeModel = std::make_shared<StoreModel>());

    // HandleRequest
    EXPECT_NO_THROW(storeModel->handleRequest(eventContext));
}

TEST_F(StoreModelTest, TestHandleRequestUpdate)
{
    std::string message;
    nlohmann::json resource;
    resource["type"] = "update";
    resource["offset"] = 123456;

    // Load schema from file
    std::string cve5SchemaStr;
    ASSERT_TRUE(flatbuffers::LoadFile(CVE5_FLATBUFFER_SCHEMA_PATH.c_str(), false, &cve5SchemaStr));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(cve5SchemaStr.c_str(), INCLUDE_DIRECTORIES) && parser.Parse(CVE5_ENTRY_PUBLISHED.c_str()));

    flatbuffers::FlatBufferBuilder& builder = parser.builder_;

    auto feedDatabase = std::make_shared<Utils::RocksDBWrapper>("temp");
    auto eventContext = std::make_shared<EventContext>(EventContext {
        .message = message, .resource = resource, .feedDatabase = feedDatabase, .resourceType = ResourceType::CVE});

    eventContext->cve5Buffer = builder.Release();

    std::shared_ptr<StoreModel> storeModel;

    EXPECT_NO_THROW(storeModel = std::make_shared<StoreModel>());

    // HandleRequest
    EXPECT_NO_THROW(storeModel->handleRequest(eventContext));
}

TEST_F(StoreModelTest, TestInvalidEventType)
{
    std::string message;
    nlohmann::json resource;

    // Load schema from file
    std::string cve5SchemaStr;
    ASSERT_TRUE(flatbuffers::LoadFile(CVE5_FLATBUFFER_SCHEMA_PATH.c_str(), false, &cve5SchemaStr));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(cve5SchemaStr.c_str(), INCLUDE_DIRECTORIES) && parser.Parse(CVE5_ENTRY_PUBLISHED.c_str()));

    flatbuffers::FlatBufferBuilder& builder = parser.builder_;

    auto feedDatabase = std::make_shared<Utils::RocksDBWrapper>("temp");
    auto eventContext = std::make_shared<EventContext>(EventContext {
        .message = message, .resource = resource, .feedDatabase = feedDatabase, .resourceType = ResourceType::CVE});

    eventContext->cve5Buffer = builder.Release();

    std::shared_ptr<StoreModel> storeModel;

    EXPECT_NO_THROW(storeModel = std::make_shared<StoreModel>());

    // HandleRequest
    EXPECT_THROW(storeModel->handleRequest(eventContext), std::runtime_error);
}

TEST_F(StoreModelTest, TestInvalidEntryState)
{
    std::string message;
    nlohmann::json resource;
    resource["type"] = "update";

    // Load schema from file
    std::string cve5SchemaStr;
    ASSERT_TRUE(flatbuffers::LoadFile(CVE5_FLATBUFFER_SCHEMA_PATH.c_str(), false, &cve5SchemaStr));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(cve5SchemaStr.c_str(), INCLUDE_DIRECTORIES) &&
                parser.Parse(CVE5_ENTRY_INVALID_STATE.c_str()));

    flatbuffers::FlatBufferBuilder& builder = parser.builder_;

    auto feedDatabase = std::make_shared<Utils::RocksDBWrapper>("temp");
    auto eventContext = std::make_shared<EventContext>(EventContext {
        .message = message, .resource = resource, .feedDatabase = feedDatabase, .resourceType = ResourceType::CVE});

    eventContext->cve5Buffer = builder.Release();

    std::shared_ptr<StoreModel> storeModel;

    EXPECT_NO_THROW(storeModel = std::make_shared<StoreModel>());

    // HandleRequest
    EXPECT_THROW(storeModel->handleRequest(eventContext), std::runtime_error);
}

TEST_F(StoreModelTest, TestEmptyBuffer)
{
    std::string message;
    nlohmann::json resource;
    resource["type"] = "update";

    auto feedDatabase = std::make_shared<Utils::RocksDBWrapper>("temp");
    auto eventContext = std::make_shared<EventContext>(EventContext {
        .message = message, .resource = resource, .feedDatabase = feedDatabase, .resourceType = ResourceType::CVE});

    std::shared_ptr<StoreModel> storeModel;

    EXPECT_NO_THROW(storeModel = std::make_shared<StoreModel>());

    // HandleRequest
    EXPECT_THROW(storeModel->handleRequest(eventContext), std::runtime_error);
}
