/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * July 16, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "scanInventory_test.hpp"
#include "MockScanContext.hpp"
#include "mocks/chainOfResponsabilityMock.h"
#include "scanContext.hpp"
#include "scanOrchestrator.hpp"

using ::testing::_;
using ::testing::NiceMock; // NiceMock is used to create a mock object that does not require expectations to be set.
using ::testing::Return;

void ScanInventorySyncTest::SetUp()
{
    m_inventoryDatabase = std::make_unique<Utils::RocksDBWrapper>(INVENTORY_DB_PATH);
    for (const auto& element : AFFECTED_COMPONENT_COLUMNS)
    {
        if (!m_inventoryDatabase->columnExists(element.second))
        {
            m_inventoryDatabase->createColumn(element.second);
        }
    }
}

void ScanInventorySyncTest::TearDown()
{
    m_inventoryDatabase->deleteAll();
    m_inventoryDatabase.reset();
    std::filesystem::remove_all(INVENTORY_DB_PATH);
}

TEST_F(ScanInventorySyncTest, UpgradeOSWithOldContent)
{
    // Simulate legacy scan result already in DB (pre-upgrade).
    m_inventoryDatabase->put("001_Redhat", "CVE-2021-33560,CVE-2019-13627,CVE-2021-40528", OS);

    // Create sub-orchestration mock.
    using SpecializedHandler = MockAbstractHandler<std::shared_ptr<MockScanContext>>;
    auto spSubOrchestration = std::make_shared<SpecializedHandler>();

    // Expect one call for deletion (each old CVE triggers one context to delete).
    EXPECT_CALL(*spSubOrchestration, handleRequest(testing::_)).Times(3);

    // Class under test.
    auto scanInventory = std::make_shared<TScanInventorySync<MockScanContext, SpecializedHandler>>(*m_inventoryDatabase,
                                                                                                   spSubOrchestration);

    // Create the mock scan context.
    auto scanContext = std::make_shared<NiceMock<MockScanContext>>();

    // Expectations for mocked methods.
    EXPECT_CALL(*scanContext, agentId()).WillRepeatedly(Return("001"));
    EXPECT_CALL(*scanContext, clusterStatus()).WillRepeatedly(Return(false));
    EXPECT_CALL(*scanContext, clusterNodeName()).WillRepeatedly(Return(""));
    EXPECT_CALL(*scanContext, affectedComponentType()).WillRepeatedly(Return(AffectedComponentType::Os));
    EXPECT_CALL(*scanContext, osName()).WillRepeatedly(Return("RedHat"));
    EXPECT_CALL(*scanContext, osVersion()).WillRepeatedly(Return("8.8.8"));

    // Simulate the scan now returns a different CVE (new OS).
    scanContext->m_elements.emplace("CVE-2026-2026", nlohmann::json::object());

    // Act
    EXPECT_NO_THROW(scanInventory->handleRequest(scanContext));

    // Assert legacy key was deleted.
    std::string legacyInventory;
    EXPECT_FALSE(m_inventoryDatabase->get("001_Redhat", legacyInventory, OS));

    // Assert new inventory was stored correctly.
    std::string newInventory;
    std::string newKey = "001_RedHat_8.8.8";
    EXPECT_TRUE(m_inventoryDatabase->get(newKey, newInventory, OS));
    EXPECT_THAT(newInventory, ::testing::HasSubstr("CVE-2026-2026"));
}

TEST_F(ScanInventorySyncTest, FirstScanWithoutPreviousInventory)
{
    // Sub-orchestration should not be called (no deletions).
    using SpecializedHandler = MockAbstractHandler<std::shared_ptr<MockScanContext>>;
    auto spSubOrchestration = std::make_shared<SpecializedHandler>();
    EXPECT_CALL(*spSubOrchestration, handleRequest(testing::_)).Times(0);

    auto scanInventory = std::make_shared<TScanInventorySync<MockScanContext, SpecializedHandler>>(*m_inventoryDatabase,
                                                                                                   spSubOrchestration);

    auto scanContext = std::make_shared<NiceMock<MockScanContext>>();
    EXPECT_CALL(*scanContext, agentId()).WillRepeatedly(Return("001"));
    EXPECT_CALL(*scanContext, clusterStatus()).WillRepeatedly(Return(false));
    EXPECT_CALL(*scanContext, clusterNodeName()).WillRepeatedly(Return(""));
    EXPECT_CALL(*scanContext, affectedComponentType()).WillRepeatedly(Return(AffectedComponentType::Os));
    EXPECT_CALL(*scanContext, osName()).WillRepeatedly(Return("Debian"));
    EXPECT_CALL(*scanContext, osVersion()).WillRepeatedly(Return("12.1"));

    // First scan CVEs
    scanContext->m_elements.emplace("CVE-1000-0001", nlohmann::json::object());
    scanContext->m_elements.emplace("CVE-1000-0002", nlohmann::json::object());

    // Act
    auto result = scanInventory->handleRequest(scanContext);

    // Assert inventory was created
    std::string key = "001_Debian_12.1";
    std::string stored;
    EXPECT_TRUE(m_inventoryDatabase->get(key, stored, OS));
    EXPECT_THAT(stored, ::testing::HasSubstr("CVE-1000-0001"));
    EXPECT_THAT(stored, ::testing::HasSubstr("CVE-1000-0002"));

    // Assert initial scan timestamp recorded
    std::string ts;
    EXPECT_TRUE(m_inventoryDatabase->get("001", ts, OS_INITIAL_SCAN));

    // Assert both CVEs marked as INSERTED
    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->m_elements.size(), 2);
    for (auto& [cve, el] : result->m_elements)
    {
        EXPECT_EQ(el["operation"], "INSERTED");
        EXPECT_THAT(el["id"], ::testing::HasSubstr(key + "_" + cve));
    }
}

TEST_F(ScanInventorySyncTest, ClusterAgentUsesPrefixedKey)
{
    // Setup cluster agent context
    using SpecializedHandler = MockAbstractHandler<std::shared_ptr<MockScanContext>>;
    auto spSubOrchestration = std::make_shared<SpecializedHandler>();

    // No deletions expected since it's a first scan
    EXPECT_CALL(*spSubOrchestration, handleRequest(testing::_)).Times(0);

    auto scanInventory = std::make_shared<TScanInventorySync<MockScanContext, SpecializedHandler>>(*m_inventoryDatabase,
                                                                                                   spSubOrchestration);

    auto scanContext = std::make_shared<NiceMock<MockScanContext>>();
    EXPECT_CALL(*scanContext, agentId()).WillRepeatedly(Return("000")); // Cluster agent
    EXPECT_CALL(*scanContext, clusterStatus()).WillRepeatedly(Return(true));
    EXPECT_CALL(*scanContext, clusterNodeName()).WillRepeatedly(Return("node-alpha"));

    EXPECT_CALL(*scanContext, affectedComponentType()).WillRepeatedly(Return(AffectedComponentType::Os));
    EXPECT_CALL(*scanContext, osName()).WillRepeatedly(Return("ClusterOS"));
    EXPECT_CALL(*scanContext, osVersion()).WillRepeatedly(Return("1.0"));

    // New CVE found
    scanContext->m_elements.emplace("CVE-CLUSTER-0001", nlohmann::json::object());

    // Act
    auto result = scanInventory->handleRequest(scanContext);

    // Assert correct key is used (prefix with cluster node name)
    std::string expectedKey = "node-alpha_000_ClusterOS_1.0";
    std::string stored;
    EXPECT_TRUE(m_inventoryDatabase->get(expectedKey, stored, OS));
    EXPECT_THAT(stored, ::testing::HasSubstr("CVE-CLUSTER-0001"));

    // Validate initial scan timestamp also recorded
    std::string ts;
    EXPECT_TRUE(m_inventoryDatabase->get("000", ts, OS_INITIAL_SCAN));

    // Validate result contains inserted element with correct ID
    ASSERT_NE(result, nullptr);
    ASSERT_TRUE(result->m_elements.find("CVE-CLUSTER-0001") != result->m_elements.end());
    EXPECT_EQ(result->m_elements["CVE-CLUSTER-0001"]["operation"], "INSERTED");
    EXPECT_EQ(result->m_elements["CVE-CLUSTER-0001"]["id"], expectedKey + "_CVE-CLUSTER-0001");
}
