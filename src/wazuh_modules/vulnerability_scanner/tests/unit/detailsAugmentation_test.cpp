/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * January 2, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "detailsAugmentation_test.hpp"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_deltas_generated.h"
#include "../../../../shared_modules/utils/flatbuffers/include/syscollector_deltas_schema.h"
#include "../scanOrchestrator/detailsAugmentation.hpp"
#include "MockDatabaseFeedManager.hpp"
#include "MockOsDataCache.hpp"
#include "TrampolineOsDataCache.hpp"
#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "json.hpp"

using ::testing::_;

const std::string DELTA_MSG =
    R"(
        {
            "agent_info": {
                "agent_id": "001",
                "agent_ip": "192.168.33.20",
                "agent_name": "focal",
                "node_name": "node01"
            },
            "data_type": "dbsync_packages",
            "data": {
                "architecture": "amd64",
                "checksum": "1e6ce14f97f57d1bbd46ff8e5d3e133171a1bbce",
                "description": "library for GIF images library",
                "format": "deb",
                "groups": "libs",
                "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
                "multiarch": "same",
                "name": "libgif7",
                "priority": "optional",
                "scan_time": "2023/08/04 19:56:11",
                "size": 72,
                "source": "giflib",
                "vendor": "Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>",
                "version": "5.1.9-1",
                "install_time": "1577890801"
            },
            "operation": "INSERTED"
        }
    )";

const std::string CVEID {"CVE-2024-1234"};

// External shared pointers definitions
std::shared_ptr<MockOsDataCache> spOsDataCacheMock;

void DetailsAugmentationTest::SetUp()
{
    std::filesystem::create_directories("queue/vd");

    // Policy manager initialization.
    const auto& configJson {nlohmann::json::parse(R"({
    "vulnerability-detection": {
        "enabled": "yes",
        "index-status": "yes",
        "cti-url": "cti-url.com"
    },
    "osdataLRUSize":1000
    })")};
    PolicyManager::instance().initialize(configJson);
}

void DetailsAugmentationTest::TearDown()
{
    spOsDataCacheMock.reset();
    PolicyManager::instance().teardown();
    std::filesystem::remove_all("queue/vd");
}

TEST_F(DetailsAugmentationTest, TestSuccessful)
{
    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vulnerabilityDescriptionData =
        NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                     8.3,
                                                                     "classification_test_string",
                                                                     "description_test_string",
                                                                     "severity_test_string",
                                                                     "scoreVersion_test_string",
                                                                     "reference_test_string");
    fbBuilder.Finish(vulnerabilityDescriptionData);

    auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(DESCRIPTION_DATABASE_PATH);
    rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
    dbWrapper->put(CVEID, dbValue);

    auto mockGetVulnerabiltyDescriptiveInformation =
        [&](const std::string_view cveId,
            FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription>& resultContainer)
    {
        dbWrapper->get(std::string(cveId), resultContainer.slice);
        resultContainer.data = const_cast<NSVulnerabilityScanner::VulnerabilityDescription*>(
            NSVulnerabilityScanner::GetVulnerabilityDescription(resultContainer.slice.data()));
    };

    Os osData {.hostName = "osdata_hostname",
               .architecture = "osdata_architecture",
               .name = "osdata_name",
               .codeName = "osdata_codeName",
               .majorVersion = "osdata_majorVersion",
               .minorVersion = "osdata_minorVersion",
               .patch = "osdata_patch",
               .build = "osdata_build",
               .platform = "osdata_platform",
               .version = "osdata_version",
               .release = "osdata_release",
               .displayVersion = "osdata_displayVersion",
               .sysName = "osdata_sysName",
               .kernelVersion = "osdata_kernelVersion",
               .kernelRelease = "osdata_kernelRelease"};

    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    EXPECT_CALL(*spOsDataCacheMock, getOsData(_)).WillRepeatedly(testing::Return(osData));

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabiltyDescriptiveInformation(_, _))
        .WillRepeatedly(testing::Invoke(mockGetVulnerabiltyDescriptiveInformation));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> syscollectorDelta =
        SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache>>(syscollectorDelta);
    scanContextOriginal->m_elements[CVEID] = nlohmann::json::object(); // Mock one vulnerability

    TDetailsAugmentation<MockDatabaseFeedManager, TScanContext<TrampolineOsDataCache>> detailsAugmentation(
        spDatabaseFeedManagerMock);

    std::shared_ptr<TScanContext<TrampolineOsDataCache>> scanContextResult;
    EXPECT_NO_THROW(scanContextResult = detailsAugmentation.handleRequest(scanContextOriginal));

    EXPECT_EQ(scanContextResult->m_elements.size(), 1);
    EXPECT_NE(scanContextResult->m_elements.find(CVEID), scanContextResult->m_elements.end());

    auto& element = scanContextResult->m_elements[CVEID];

    EXPECT_STREQ(element.at("operation").get_ref<const std::string&>().c_str(), "INSERTED");
    std::string elementId = std::string(scanContextOriginal->agentNodeName()) + "_" +
                            std::string(scanContextOriginal->agentId()) + "_" +
                            std::string(scanContextOriginal->packageItemId()) + "_" + CVEID;
    EXPECT_STREQ(element.at("id").get_ref<const std::string&>().c_str(), elementId.c_str());

    auto& elementData = scanContextResult->m_elements[CVEID].at("data");

    EXPECT_STREQ(elementData.at("agent").at("build").at("original").get_ref<const std::string&>().c_str(), "");
    EXPECT_STREQ(elementData.at("agent").at("ephemeral_id").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->agentNodeName().data());
    EXPECT_STREQ(elementData.at("agent").at("id").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->agentId().data());
    EXPECT_STREQ(elementData.at("agent").at("name").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->agentName().data());
    EXPECT_STREQ(elementData.at("agent").at("type").get_ref<const std::string&>().c_str(), "wazuh");
    EXPECT_STREQ(elementData.at("agent").at("version").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->agentVersion().data());

    EXPECT_STREQ(elementData.at("ecs").at("version").get_ref<const std::string&>().c_str(), "8.11.0");

    EXPECT_STREQ(elementData.at("package").at("architecture").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->packageArchitecture().data());
    EXPECT_STREQ(elementData.at("package").at("build_version").get_ref<const std::string&>().c_str(), "");
    EXPECT_STREQ(elementData.at("package").at("checksum").get_ref<const std::string&>().c_str(), "");
    EXPECT_STREQ(elementData.at("package").at("description").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->packageDescription().data());
    EXPECT_STREQ(elementData.at("package").at("install_scope").get_ref<const std::string&>().c_str(), "");
    EXPECT_STREQ(elementData.at("package").at("license").get_ref<const std::string&>().c_str(), "");
    EXPECT_STREQ(elementData.at("package").at("name").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->packageName().data());
    EXPECT_STREQ(elementData.at("package").at("path").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->packageLocation().data());
    EXPECT_STREQ(elementData.at("package").at("reference").get_ref<const std::string&>().c_str(), "");
    EXPECT_EQ(elementData.at("package").at("size").get_ref<const uint64_t&>(), scanContextOriginal->packageSize());
    EXPECT_STREQ(elementData.at("package").at("type").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->packageFormat().data());
    EXPECT_STREQ(elementData.at("package").at("version").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->packageVersion().data());

    EXPECT_STREQ(elementData.at("host").at("os").at("family").get_ref<const std::string&>().c_str(), "");
    std::string elementOsFullName;
    elementOsFullName.append(scanContextOriginal->osName().data());
    elementOsFullName.append(" ");
    elementOsFullName.append(scanContextOriginal->osPlatform().compare("darwin") == 0
                                 ? scanContextOriginal->osCodeName().data()
                                 : scanContextOriginal->osVersion().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("full").get_ref<const std::string&>().c_str(),
                 elementOsFullName.c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("kernel").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->osKernelRelease().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("name").get_ref<const std::string&>().c_str(),
                 scanContextOriginal->osName().data());
    EXPECT_STREQ(elementData.at("host").at("os").at("platform").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContextOriginal->osPlatform().data()).c_str());
    EXPECT_STREQ(elementData.at("host").at("os").at("type").get_ref<const std::string&>().c_str(),
                 Utils::toLowerCase(scanContextOriginal->osPlatform().compare("darwin") == 0
                                        ? "macos"
                                        : scanContextOriginal->osPlatform().data())
                     .c_str());
    std::string elementOsVersion = scanContextOriginal->osMajorVersion().data();
    if (!scanContextOriginal->osMinorVersion().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContextOriginal->osMinorVersion();
    }
    if (!scanContextOriginal->osPatch().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContextOriginal->osPatch();
    }
    if (!scanContextOriginal->osBuild().empty())
    {
        elementOsVersion += ".";
        elementOsVersion += scanContextOriginal->osBuild();
    }
    EXPECT_STREQ(elementData.at("host").at("os").at("version").get_ref<const std::string&>().c_str(),
                 elementOsVersion.c_str());

    EXPECT_STREQ(elementData.at("vulnerability").at("category").get_ref<const std::string&>().c_str(), "Packages");
    EXPECT_STREQ(elementData.at("vulnerability").at("classification").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->classification()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("description").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->description()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("enumeration").get_ref<const std::string&>().c_str(), "CVE");
    EXPECT_STREQ(elementData.at("vulnerability").at("id").get_ref<const std::string&>().c_str(), CVEID.c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("reference").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->reference()->c_str());
    EXPECT_STREQ(elementData.at("vulnerability").at("report_id").get_ref<const std::string&>().c_str(), "");
    EXPECT_STREQ(elementData.at("vulnerability").at("scanner").at("vendor").get_ref<const std::string&>().c_str(),
                 "Wazuh");
    EXPECT_DOUBLE_EQ(
        elementData.at("vulnerability").at("score").at("base").get_ref<const double&>(),
        Utils::floatToDoubleRound(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreBase(), 2));
    EXPECT_DOUBLE_EQ(elementData.at("vulnerability").at("score").at("environmental").get_ref<const double&>(), 0.0f);
    EXPECT_DOUBLE_EQ(elementData.at("vulnerability").at("score").at("temporal").get_ref<const double&>(), 0.0f);
    EXPECT_STREQ(elementData.at("vulnerability").at("score").at("version").get_ref<const std::string&>().c_str(),
                 GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->scoreVersion()->c_str());
    EXPECT_STREQ(
        elementData.at("vulnerability").at("severity").get_ref<const std::string&>().c_str(),
        Utils::toSentenceCase(GetVulnerabilityDescription(fbBuilder.GetBufferPointer())->severity()->str()).c_str());
    auto vulnerabilityDetection = PolicyManager::instance().getVulnerabilityDetection();
    EXPECT_STREQ(elementData.at("wazuh").at("cluster").at("name").get_ref<const std::string&>().c_str(),
                 vulnerabilityDetection.contains("clusterName")
                     ? vulnerabilityDetection.at("clusterName").get_ref<const std::string&>().c_str()
                     : "");
}
