/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "packageScanner_test.hpp"
#include "MockDatabaseFeedManager.hpp"
#include "MockGlobalData.hpp"
#include "MockOsDataCache.hpp"
#include "TrampolineGlobalData.hpp"
#include "TrampolineOsDataCache.hpp"
#include "factory/packageScanner.hpp"
#include "flatbuffers/idl.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include <memory>

using ::testing::_;
using ::testing::Invoke;
using ::testing::Return;
using ::testing::ReturnRef;

namespace
{
    const nlohmann::json CNA_MAPPINGS = {
        {"cnaMapping",
         {{"deb", "ubuntu_$(MAJOR_VERSION)"},
          {"rpm", "redhat_$(MAJOR_VERSION)"},
          {"alas", "alas_$(MAJOR_VERSION)"},
          {"custom", "custom_$(PLATFORM)_$(MAJOR_VERSION)"}}},
        {"platformEquivalence", {{"ubuntu", "ubuntu-lts"}, {"centos", "rhel"}}},
        {"majorVersionEquivalence", {{"amzn", {{"2018", "1"}}}, {"ubuntu", {{"20.04", "20"}}}}}};

    const nlohmann::json EMPTY_VENDOR_MAPS = nlohmann::json::object();

    const nlohmann::json VENDOR_MAPS_WITH_ADP = {{"adp_default_array", {"nvd", "cisa"}}};

    const nlohmann::json EMPTY_OS_CPE_MAPS = nlohmann::json::object();
} // namespace

void PackageScannerTest::SetUp()
{
    // Initialize global mock BEFORE any other initialization
    spGlobalDataMock = std::make_shared<MockGlobalData>();

    // Set up default mock behavior
    EXPECT_CALL(*spGlobalDataMock, cnaMappings()).WillRepeatedly(ReturnRef(CNA_MAPPINGS));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(ReturnRef(EMPTY_VENDOR_MAPS));
    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(ReturnRef(EMPTY_OS_CPE_MAPS));
}

void PackageScannerTest::TearDown()
{
    spGlobalDataMock.reset();
    spOsDataCacheMock.reset();
}

std::vector<uint8_t> createVulnerabilityCandidateFB(const std::string& cveId,
                                                    const std::string& status = "affected",
                                                    const std::string& version = "",
                                                    const std::string& lessThan = "",
                                                    const std::string& lessThanOrEqual = "",
                                                    const std::vector<std::string>& platforms = {},
                                                    const std::string& vendor = "")
{
    flatbuffers::FlatBufferBuilder builder(1024);

    auto cveIdOffset = builder.CreateString(cveId);

    std::vector<flatbuffers::Offset<NSVulnerabilityScanner::Version>> versionVector;

    if (!version.empty() || !lessThan.empty() || !lessThanOrEqual.empty())
    {
        auto versionStrOffset = version.empty() ? 0 : builder.CreateString(version);
        auto lessThanOffset = lessThan.empty() ? 0 : builder.CreateString(lessThan);
        auto lessThanOrEqualOffset = lessThanOrEqual.empty() ? 0 : builder.CreateString(lessThanOrEqual);

        NSVulnerabilityScanner::Status statusEnum = NSVulnerabilityScanner::Status::Status_affected;
        if (status == "unaffected")
        {
            statusEnum = NSVulnerabilityScanner::Status::Status_unaffected;
        }

        auto versionEntry = NSVulnerabilityScanner::CreateVersion(
            builder, statusEnum, versionStrOffset, lessThanOffset, lessThanOrEqualOffset);
        versionVector.push_back(versionEntry);
    }

    auto versionsOffset = versionVector.empty() ? 0 : builder.CreateVector(versionVector);

    std::vector<flatbuffers::Offset<flatbuffers::String>> platformVector;
    for (const auto& platform : platforms)
    {
        platformVector.push_back(builder.CreateString(platform));
    }
    auto platformsOffset = platformVector.empty() ? 0 : builder.CreateVector(platformVector);

    auto vendorOffset = vendor.empty() ? 0 : builder.CreateString(vendor);

    NSVulnerabilityScanner::Status defaultStatus = NSVulnerabilityScanner::Status::Status_unaffected;
    if (status == "affected" && version.empty() && lessThan.empty() && lessThanOrEqual.empty())
    {
        defaultStatus = NSVulnerabilityScanner::Status::Status_affected;
    }

    auto candidateOffset = NSVulnerabilityScanner::CreateScanVulnerabilityCandidate(
        builder, cveIdOffset, defaultStatus, platformsOffset, versionsOffset, vendorOffset);

    builder.Finish(candidateOffset);

    return std::vector<uint8_t>(builder.GetBufferPointer(), builder.GetBufferPointer() + builder.GetSize());
}

/**
 * @brief Helper to create Context structure for TScanContext initialization
 */
Context createContext(const std::string& agentId,
                      const std::string& agentName = "test-agent",
                      const std::string& osname = "Ubuntu",
                      const std::string& osplatform = "ubuntu")
{
    Context ctx;
    ctx.agentId = agentId;
    ctx.agentName = agentName;
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "x86_64";
    ctx.hostname = "test-host";
    ctx.osname = osname;
    ctx.osplatform = osplatform;
    ctx.ostype = "linux";
    ctx.osversion = "20.04";
    return ctx;
}

TEST_F(PackageScannerTest, TestHandleRequestEmptyPackages)
{
    auto ctx = createContext("001", "test-agent-1");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestSkipsDeleteOperation)
{
    auto ctx = createContext("002", "test-agent-2");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("002_test-package_1.0.0", pkg, ElementOperation::Delete);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat(_)).Times(0);
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates(_, _, _)).Times(0);

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestVersionLessThan)
{
    auto ctx = createContext("003", "test-agent-3", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "openssl";
    pkg.version = "1.1.1f";
    pkg.format = "deb";

    scanContext->addPackageToContext("003_openssl_1.1.1f", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0001", "affected", "0", "1.1.1k");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);

    auto detectedCVEs = result->detectedCVEs();
    EXPECT_EQ(detectedCVEs.size(), 1);

    auto it = detectedCVEs.begin();
    EXPECT_EQ(it->second.cveId, "CVE-2024-0001");
    EXPECT_EQ(it->second.conditionType, MatchRuleCondition::LessThan);
}

TEST_F(PackageScannerTest, TestHandleRequestVersionLessThanOrEqual)
{
    auto ctx = createContext("004", "test-agent-4", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "nginx";
    pkg.version = "1.18.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("004_nginx_1.18.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0002", "affected", "0", "", "1.18.0");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);

    auto detectedCVEs = result->detectedCVEs();
    auto it = detectedCVEs.begin();
    EXPECT_EQ(it->second.cveId, "CVE-2024-0002");
    EXPECT_EQ(it->second.conditionType, MatchRuleCondition::LessThanOrEqual);
}

TEST_F(PackageScannerTest, TestHandleRequestDefaultStatusAffected)
{
    auto ctx = createContext("005", "test-agent-5", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "vulnerable-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("005_vulnerable-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                // No version rules, just default status affected
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0003", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);

    auto detectedCVEs = result->detectedCVEs();
    auto it = detectedCVEs.begin();
    EXPECT_EQ(it->second.cveId, "CVE-2024-0003");
    EXPECT_EQ(it->second.conditionType, MatchRuleCondition::DefaultStatus);
}

TEST_F(PackageScannerTest, TestHandleRequestMultiplePackages)
{
    auto ctx = createContext("006", "test-agent-6", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg1;
    pkg1.name = "package1";
    pkg1.version = "1.0.0";
    pkg1.format = "deb";
    scanContext->addPackageToContext("006_package1_1.0.0", pkg1, ElementOperation::Upsert);

    PackageContextData pkg2;
    pkg2.name = "package2";
    pkg2.version = "2.0.0";
    pkg2.format = "deb";
    scanContext->addPackageToContext("006_package2_2.0.0", pkg2, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).Times(2).WillRepeatedly(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .Times(2)
        .WillRepeatedly(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .Times(2)
        .WillRepeatedly(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-" + package.name, "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 2);
}

TEST_F(PackageScannerTest, TestHandleRequestVendorMismatch)
{
    auto ctx = createContext("007", "test-agent-7", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";
    pkg.vendor = "wrong-vendor";

    scanContext->addPackageToContext("007_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData =
                    createVulnerabilityCandidateFB("CVE-2024-0004", "affected", "", "", "", {}, "correct-vendor");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestTranslationL2)
{
    auto ctx = createContext("008", "test-agent-8", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "original-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";
    pkg.vendor = "original-vendor";

    scanContext->addPackageToContext("008_original-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    TranslatedData translation;
    translation.translatedProduct = "translated-package";
    translation.translatedVendor = "translated-vendor";

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {translation}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                EXPECT_EQ(package.name, "translated-package");
                EXPECT_EQ(package.vendor, "translated-vendor");

                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0005", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestNoVulnerabilities)
{
    auto ctx = createContext("009", "test-agent-9", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "safe-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("009_safe-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _)).WillOnce(Return());

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestDefaultCNAFallback)
{
    auto ctx = createContext("010", "test-agent-10", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "unknown";

    scanContext->addPackageToContext("010_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("unknown")).WillOnce(Return(""));
    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _)).WillOnce(Return());

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestExactVersionMatch)
{
    auto ctx = createContext("011", "test-agent-11", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "exact-match-package";
    pkg.version = "1.2.3";
    pkg.format = "deb";

    scanContext->addPackageToContext("011_exact-match-package_1.2.3", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0006", "affected", "1.2.3");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);

    auto detectedCVEs = result->detectedCVEs();
    auto it = detectedCVEs.begin();
    EXPECT_EQ(it->second.cveId, "CVE-2024-0006");
    EXPECT_EQ(it->second.conditionType, MatchRuleCondition::Equal);
    EXPECT_EQ(it->second.matchCondition, "1.2.3");
}

TEST_F(PackageScannerTest, TestHandleRequestVersionBelowLowerBound)
{
    auto ctx = createContext("012", "test-agent-12", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "old-version-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("012_old-version-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0007", "affected", "2.0.0", "3.0.0");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestHotfixRemediation)
{
    auto ctx = createContext("013", "test-agent-13", "Microsoft Windows 7", "windows");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    // Add a hotfix to the context
    HotfixContextData hotfix;
    hotfix.hotfixName = "KB123456";
    scanContext->addHotfixToContext(hotfix);

    PackageContextData pkg;
    pkg.name = "vulnerable-windows-package";
    pkg.version = "1.0.0";
    pkg.format = "win";

    scanContext->addPackageToContext("013_vulnerable-windows-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("win")).WillOnce(Return("windows"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("windows", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0008", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityRemediation("CVE-2024-0008", _))
        .WillOnce(Invoke([](const std::string& cveId,
                            FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& remediations) {}));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);

    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestCNAPriorityMultipleCNAs)
{
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(ReturnRef(VENDOR_MAPS_WITH_ADP));

    auto ctx = createContext("014", "test-agent-14", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "unknown";

    scanContext->addPackageToContext("014_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("unknown")).WillOnce(Return(""));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .Times(2) // Once for each CNA
        .WillRepeatedly(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0009", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("cisa", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0010", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 2);
}

TEST_F(PackageScannerTest, TestHandleRequestVersionAboveUpperBound)
{
    auto ctx = createContext("015", "test-agent-15", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "new-version-package";
    pkg.version = "4.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("015_new-version-package_4.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0011", "affected", "0", "3.0.0");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestPlatformMismatch)
{
    auto ctx = createContext("016", "test-agent-16", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "platform-specific";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("016_platform-specific_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                // CVE only affects Windows platform
                auto fbData = createVulnerabilityCandidateFB(
                    "CVE-2024-0012", "affected", "", "", "", {"cpe:2.3:o:microsoft:windows"});
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestTranslationL1Cache)
{
    auto ctx = createContext("017", "test-agent-17", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg1;
    pkg1.name = "cached-package";
    pkg1.version = "1.0.0";
    pkg1.format = "deb";
    pkg1.vendor = "test-vendor";
    scanContext->addPackageToContext("017_cached-package_1.0.0_1", pkg1, ElementOperation::Upsert);

    PackageContextData pkg2;
    pkg2.name = "cached-package";
    pkg2.version = "1.0.1";
    pkg2.format = "deb";
    pkg2.vendor = "test-vendor";
    scanContext->addPackageToContext("017_cached-package_1.0.1_2", pkg2, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).Times(2).WillRepeatedly(Return("ubuntu"));

    TranslatedData translation;
    translation.translatedProduct = "translated-cached-package";

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {translation}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .Times(2)
        .WillRepeatedly(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                EXPECT_EQ(package.name, "translated-cached-package");
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0013", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 2);
}

TEST_F(PackageScannerTest, TestHandleRequestExactVersionUnaffected)
{
    auto ctx = createContext("018", "test-agent-18", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "patched-package";
    pkg.version = "2.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("018_patched-package_2.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                flatbuffers::FlatBufferBuilder builder(1024);
                auto cveIdOffset = builder.CreateString("CVE-2024-0014");
                auto versionOffset = builder.CreateString("2.0.0");

                // Create version with status=unaffected
                auto versionEntry = NSVulnerabilityScanner::CreateVersion(
                    builder, NSVulnerabilityScanner::Status::Status_unaffected, versionOffset, 0, 0);

                std::vector<flatbuffers::Offset<NSVulnerabilityScanner::Version>> versionVector;
                versionVector.push_back(versionEntry);
                auto versionsOffset = builder.CreateVector(versionVector);

                auto candidateOffset = NSVulnerabilityScanner::CreateScanVulnerabilityCandidate(
                    builder, cveIdOffset, NSVulnerabilityScanner::Status::Status_unaffected, 0, versionsOffset, 0);

                builder.Finish(candidateOffset);

                std::vector<uint8_t> fbData(builder.GetBufferPointer(), builder.GetBufferPointer() + builder.GetSize());

                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestTranslationWithVersion)
{
    auto ctx = createContext("019", "test-agent-19", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "package-with-version-translation";
    pkg.version = "1.0.0";
    pkg.format = "deb";
    pkg.vendor = "original-vendor";

    scanContext->addPackageToContext("019_package-with-version-translation_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    TranslatedData translation;
    translation.translatedProduct = "translated-package";
    translation.translatedVendor = "translated-vendor";
    translation.translatedVersion = "2.0.0";

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {translation}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                EXPECT_EQ(package.version, "2.0.0");

                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0019", "affected", "", "3.0.0");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestCNABySource)
{
    auto ctx = createContext("020", "test-agent-20", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "unknown-format";
    pkg.source = "custom-source";

    scanContext->addPackageToContext("020_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("unknown-format")).WillOnce(Return(""));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameBySource("custom-source")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0020", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestCNAByPrefix)
{
    auto ctx = createContext("021", "test-agent-21", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "unknown-format";
    pkg.vendor = "custom-vendor";

    scanContext->addPackageToContext("021_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("unknown-format")).WillOnce(Return(""));
    // When format is empty and vendor is present, it calls prefix/contains directly without source
    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByPrefix("custom-vendor", "ubuntu")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0021", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestCNAByContains)
{
    auto ctx = createContext("022", "test-agent-22", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "unknown-format";
    pkg.vendor = "contains-vendor";

    scanContext->addPackageToContext("022_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("unknown-format")).WillOnce(Return(""));
    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByPrefix(_, _)).WillOnce(Return(""));
    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByContains("contains-vendor", "ubuntu"))
        .WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0022", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestPlatformMatchByCodeName)
{
    auto ctx = createContext("023", "test-agent-23", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("023_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0023", "affected", "", "2.0.0");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestEmptyVendor)
{
    auto ctx = createContext("024", "test-agent-24", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";
    pkg.vendor = "";

    scanContext->addPackageToContext("024_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData =
                    createVulnerabilityCandidateFB("CVE-2024-0024", "affected", "", "2.0.0", "", {}, "required-vendor");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestSpaceVendor)
{
    auto ctx = createContext("025", "test-agent-25", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";
    pkg.vendor = " ";

    scanContext->addPackageToContext("025_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData =
                    createVulnerabilityCandidateFB("CVE-2024-0025", "affected", "", "2.0.0", "", {}, "required-vendor");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

TEST_F(PackageScannerTest, TestHandleRequestNoHotfixesInstalled)
{
    auto ctx = createContext("026", "test-agent-26", "Windows", "windows");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "win";

    scanContext->addPackageToContext("026_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("win")).WillOnce(Return("microsoft"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("microsoft", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0026", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    auto builder = std::make_shared<flatbuffers::FlatBufferBuilder>(1024);
    std::vector<flatbuffers::Offset<flatbuffers::String>> updates;
    updates.push_back(builder->CreateString("KB1234567"));
    auto updatesVector = builder->CreateVector(updates);
    auto remediationOffset = NSVulnerabilityScanner::CreateRemediationInfo(*builder, updatesVector);
    builder->Finish(remediationOffset);

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilityRemediation("CVE-2024-0026", _))
        .WillOnce(Invoke(
            [builder](const std::string&, FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo>& output)
            {
                // Directly set the data pointer without copying the FlatbufferDataPair
                output.data =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::RemediationInfo>(builder->GetBufferPointer());
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestCNAWithPlatformEquivalence)
{
    auto ctx = createContext("027", "test-agent-27", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    const Os osData {.hostName = "test-host",
                     .architecture = "x86_64",
                     .name = "Ubuntu",
                     .codeName = "focal",
                     .majorVersion = "20",
                     .minorVersion = "04",
                     .patch = "",
                     .build = "",
                     .platform = "ubuntu",
                     .version = "20.04",
                     .release = "",
                     .displayVersion = "20.04",
                     .sysName = "Linux",
                     .kernelVersion = "5.4.0",
                     .kernelRelease = "5.4.0-42-generic"};

    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    EXPECT_CALL(*spOsDataCacheMock, getOsData(_, _))
        .WillRepeatedly(testing::Invoke(
            [osData](const std::string&, Os& osDataResult)
            {
                osDataResult = osData;
                return true;
            }));

    // Reinitialize scanContext with Os data
    scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "custom";

    scanContext->addPackageToContext("027_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("custom")).WillOnce(Return("custom_ubuntu-lts_20"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("custom_ubuntu-lts_20", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0027", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestCNAWithMajorVersionEquivalence)
{
    auto ctx = createContext("028", "test-agent-28", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    const Os osData {.hostName = "test-host",
                     .architecture = "x86_64",
                     .name = "Ubuntu",
                     .codeName = "focal",
                     .majorVersion = "20.04",
                     .minorVersion = "",
                     .patch = "",
                     .build = "",
                     .platform = "ubuntu",
                     .version = "20.04",
                     .release = "",
                     .displayVersion = "20.04",
                     .sysName = "Linux",
                     .kernelVersion = "5.4.0",
                     .kernelRelease = "5.4.0-42-generic"};

    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    EXPECT_CALL(*spOsDataCacheMock, getOsData(_, _))
        .WillRepeatedly(testing::Invoke(
            [osData](const std::string&, Os& osDataResult)
            {
                osDataResult = osData;
                return true;
            }));

    scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("028_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu_20"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu_20", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0028", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

TEST_F(PackageScannerTest, TestHandleRequestCNAWithBothEquivalences)
{
    auto ctx = createContext("029", "test-agent-29", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    // Setup Os data with both mappings
    const Os osData {.hostName = "test-host",
                     .architecture = "x86_64",
                     .name = "Ubuntu",
                     .codeName = "focal",
                     .majorVersion = "20.04", // Mapped to "20"
                     .minorVersion = "",
                     .patch = "",
                     .build = "",
                     .platform = "ubuntu", // Mapped to "ubuntu-lts"
                     .version = "20.04",
                     .release = "",
                     .displayVersion = "20.04",
                     .sysName = "Linux",
                     .kernelVersion = "5.4.0",
                     .kernelRelease = "5.4.0-42-generic"};

    spOsDataCacheMock = std::make_shared<MockOsDataCache>();
    EXPECT_CALL(*spOsDataCacheMock, getOsData(_, _))
        .WillRepeatedly(testing::Invoke(
            [osData](const std::string&, Os& osDataResult)
            {
                osDataResult = osData;
                return true;
            }));

    // Reinitialize scanContext with Os data
    scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "custom"; // Uses "custom_$(PLATFORM)_$(MAJOR_VERSION)" mapping

    scanContext->addPackageToContext("029_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("custom")).WillOnce(Return("custom_ubuntu-lts_20"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("custom_ubuntu-lts_20", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0029", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}
