/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "packageScanner_test.hpp"
#include "MockDatabaseFeedManager.hpp"
#include "MockGlobalData.hpp"
#include "TrampolineGlobalData.hpp"
#include "TrampolineOsDataCache.hpp"
#include "TrampolineRemediationDataCache.hpp"
#include "factory/packageScanner.hpp"
#include "flatbuffers/idl.h"
#include "policyManager.hpp"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include <memory>

using ::testing::_;
using ::testing::Invoke;
using ::testing::Return;
using ::testing::ReturnRef;

namespace
{
    const nlohmann::json CNA_MAPPINGS = {
        {"cnaMapping",
         {{"deb", "ubuntu_$(MAJOR_VERSION)"}, {"rpm", "redhat_$(MAJOR_VERSION)"}, {"alas", "alas_$(MAJOR_VERSION)"}}},
        {"majorVersionEquivalence", {{"amzn", {{"2018", "1"}}}}}};

    const nlohmann::json EMPTY_VENDOR_MAPS = nlohmann::json::object();

    const nlohmann::json VENDOR_MAPS_WITH_ADP = {{"_default", {"nvd", "cisa"}}};

    const nlohmann::json EMPTY_OS_CPE_MAPS = nlohmann::json::object();
} // namespace

void PackageScannerTest::SetUp()
{
    // Initialize global mock BEFORE any other initialization
    spGlobalDataMock = std::make_shared<MockGlobalData>();

    // Set up default mock behavior
    EXPECT_CALL(*spGlobalDataMock, cnaMappings()).WillRepeatedly(ReturnRef(CNA_MAPPINGS));
    EXPECT_CALL(*spGlobalDataMock, vendorMaps()).WillRepeatedly(ReturnRef(EMPTY_VENDOR_MAPS));
    EXPECT_CALL(*spGlobalDataMock, osCpeMaps()).WillRepeatedly(ReturnRef(EMPTY_OS_CPE_MAPS));

    // Policy manager initialization
    const auto& configJson {nlohmann::json::parse(R"({
        "vulnerability-detection": {
            "enabled": "yes",
            "cti-url": "cti-url.com"
        }
    })")};
    PolicyManager::instance().initialize(configJson);
}

void PackageScannerTest::TearDown()
{
    PolicyManager::instance().teardown();
    spGlobalDataMock.reset();
}

/**
 * @brief Helper function to create a FlatBuffer vulnerability candidate
 */
std::vector<uint8_t> createVulnerabilityCandidateFB(const std::string& cveId,
                                                    const std::string& status = "affected",
                                                    const std::string& version = "",
                                                    const std::string& lessThan = "",
                                                    const std::string& lessThanOrEqual = "",
                                                    const std::vector<std::string>& platforms = {},
                                                    const std::string& vendor = "")
{
    flatbuffers::FlatBufferBuilder builder(1024);

    // Create CVE ID
    auto cveIdOffset = builder.CreateString(cveId);

    // Create version entries
    std::vector<flatbuffers::Offset<NSVulnerabilityScanner::Version>> versionVector;

    if (!version.empty() || !lessThan.empty() || !lessThanOrEqual.empty())
    {
        auto versionStrOffset = version.empty() ? 0 : builder.CreateString(version);
        auto lessThanOffset = lessThan.empty() ? 0 : builder.CreateString(lessThan);
        auto lessThanOrEqualOffset = lessThanOrEqual.empty() ? 0 : builder.CreateString(lessThanOrEqual);

        NSVulnerabilityScanner::Status statusEnum = NSVulnerabilityScanner::Status::Status_affected;
        if (status == "unaffected")
        {
            statusEnum = NSVulnerabilityScanner::Status::Status_unaffected;
        }

        auto versionEntry = NSVulnerabilityScanner::CreateVersion(
            builder, statusEnum, versionStrOffset, lessThanOffset, lessThanOrEqualOffset);
        versionVector.push_back(versionEntry);
    }

    auto versionsOffset = versionVector.empty() ? 0 : builder.CreateVector(versionVector);

    // Create platforms
    std::vector<flatbuffers::Offset<flatbuffers::String>> platformVector;
    for (const auto& platform : platforms)
    {
        platformVector.push_back(builder.CreateString(platform));
    }
    auto platformsOffset = platformVector.empty() ? 0 : builder.CreateVector(platformVector);

    // Create vendor
    auto vendorOffset = vendor.empty() ? 0 : builder.CreateString(vendor);

    // Determine default status
    NSVulnerabilityScanner::Status defaultStatus = NSVulnerabilityScanner::Status::Status_unaffected;
    if (status == "affected" && version.empty() && lessThan.empty() && lessThanOrEqual.empty())
    {
        defaultStatus = NSVulnerabilityScanner::Status::Status_affected;
    }

    // Create the candidate
    auto candidateOffset = NSVulnerabilityScanner::CreateScanVulnerabilityCandidate(
        builder, cveIdOffset, defaultStatus, platformsOffset, versionsOffset, vendorOffset);

    builder.Finish(candidateOffset);

    return std::vector<uint8_t>(builder.GetBufferPointer(), builder.GetBufferPointer() + builder.GetSize());
}

/**
 * @brief Helper to create Context structure for TScanContext initialization
 */
Context createContext(const std::string& agentId,
                      const std::string& agentName = "test-agent",
                      const std::string& osname = "Ubuntu",
                      const std::string& osplatform = "ubuntu")
{
    Context ctx;
    ctx.agentId = agentId;
    ctx.agentName = agentName;
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "x86_64";
    ctx.hostname = "test-host";
    ctx.osname = osname;
    ctx.osplatform = osplatform;
    ctx.ostype = "linux";
    ctx.osversion = "20.04";
    return ctx;
}

// TEST 1: Empty packages - no packages to scan
TEST_F(PackageScannerTest, TestHandleRequestEmptyPackages)
{
    auto ctx = createContext("001", "test-agent-1");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

// TEST 2: Skip DELETE operation
TEST_F(PackageScannerTest, TestHandleRequestSkipsDeleteOperation)
{
    auto ctx = createContext("002", "test-agent-2");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("002_test-package_1.0.0", pkg, ElementOperation::Delete);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    // Should NOT call any feed manager methods for DELETE operations
    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat(_)).Times(0);
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates(_, _, _)).Times(0);

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

// TEST 3: Version range - lessThan
TEST_F(PackageScannerTest, TestHandleRequestVersionLessThan)
{
    auto ctx = createContext("003", "test-agent-3", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "openssl";
    pkg.version = "1.1.1f";
    pkg.format = "deb";

    scanContext->addPackageToContext("003_openssl_1.1.1f", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0001", "affected", "0", "1.1.1k");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);

    auto detectedCVEs = result->detectedCVEs();
    EXPECT_EQ(detectedCVEs.size(), 1);

    auto it = detectedCVEs.begin();
    EXPECT_EQ(it->second.cveId, "CVE-2024-0001");
    EXPECT_EQ(it->second.conditionType, MatchRuleCondition::LessThan);
}

// TEST 4: Version range - lessThanOrEqual
TEST_F(PackageScannerTest, TestHandleRequestVersionLessThanOrEqual)
{
    auto ctx = createContext("004", "test-agent-4", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "nginx";
    pkg.version = "1.18.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("004_nginx_1.18.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0002", "affected", "0", "", "1.18.0");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);

    auto detectedCVEs = result->detectedCVEs();
    auto it = detectedCVEs.begin();
    EXPECT_EQ(it->second.cveId, "CVE-2024-0002");
    EXPECT_EQ(it->second.conditionType, MatchRuleCondition::LessThanOrEqual);
}

// TEST 5: Default status affected (no version rules)
TEST_F(PackageScannerTest, TestHandleRequestDefaultStatusAffected)
{
    auto ctx = createContext("005", "test-agent-5", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "vulnerable-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("005_vulnerable-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                // No version rules, just default status affected
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0003", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);

    auto detectedCVEs = result->detectedCVEs();
    auto it = detectedCVEs.begin();
    EXPECT_EQ(it->second.cveId, "CVE-2024-0003");
    EXPECT_EQ(it->second.conditionType, MatchRuleCondition::DefaultStatus);
}

// TEST 6: Multiple packages - scan all
TEST_F(PackageScannerTest, TestHandleRequestMultiplePackages)
{
    auto ctx = createContext("006", "test-agent-6", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    // Package 1
    PackageContextData pkg1;
    pkg1.name = "package1";
    pkg1.version = "1.0.0";
    pkg1.format = "deb";
    scanContext->addPackageToContext("006_package1_1.0.0", pkg1, ElementOperation::Upsert);

    // Package 2
    PackageContextData pkg2;
    pkg2.name = "package2";
    pkg2.version = "2.0.0";
    pkg2.format = "deb";
    scanContext->addPackageToContext("006_package2_2.0.0", pkg2, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).Times(2).WillRepeatedly(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .Times(2)
        .WillRepeatedly(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .Times(2)
        .WillRepeatedly(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-" + package.name, "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 2);
}

// TEST 7: Vendor mismatch - should not detect vulnerability
TEST_F(PackageScannerTest, TestHandleRequestVendorMismatch)
{
    auto ctx = createContext("007", "test-agent-7", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";
    pkg.vendor = "wrong-vendor";

    scanContext->addPackageToContext("007_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                // CVE requires specific vendor
                auto fbData =
                    createVulnerabilityCandidateFB("CVE-2024-0004", "affected", "", "", "", {}, "correct-vendor");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0); // Should not match due to vendor mismatch
}

// TEST 8: Translation L2 cache hit
TEST_F(PackageScannerTest, TestHandleRequestTranslationL2)
{
    auto ctx = createContext("008", "test-agent-8", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "original-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";
    pkg.vendor = "original-vendor";

    scanContext->addPackageToContext("008_original-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    // Return translation data
    TranslatedData translation;
    translation.translatedProduct = "translated-package";
    translation.translatedVendor = "translated-vendor";

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {translation}));

    // Should call with translated name
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                // Verify we're getting translated name
                EXPECT_EQ(package.name, "translated-package");
                EXPECT_EQ(package.vendor, "translated-vendor");

                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0005", "affected");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);
}

// TEST 9: No vulnerabilities found
TEST_F(PackageScannerTest, TestHandleRequestNoVulnerabilities)
{
    auto ctx = createContext("009", "test-agent-9", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "safe-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("009_safe-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    // No vulnerabilities returned
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _)).WillOnce(Return());

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

// TEST 10: Default CNA fallback - unknown format uses nvd
TEST_F(PackageScannerTest, TestHandleRequestDefaultCNAFallback)
{
    auto ctx = createContext("010", "test-agent-10", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "test-package";
    pkg.version = "1.0.0";
    pkg.format = "unknown"; // Will fall back to default CNA (nvd)

    scanContext->addPackageToContext("010_test-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    // Format not found, will use default CNA
    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("unknown")).WillOnce(Return(""));

    // Since format is empty and package has no source/vendor, it won't call these
    // getCNA will return DEFAULT_CNA directly

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    // Should call with default CNA (nvd)
    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("nvd", _, _)).WillOnce(Return());

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0);
}

// TEST 11: Exact version match with affected status
TEST_F(PackageScannerTest, TestHandleRequestExactVersionMatch)
{
    auto ctx = createContext("011", "test-agent-11", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "exact-match-package";
    pkg.version = "1.2.3";
    pkg.format = "deb";

    scanContext->addPackageToContext("011_exact-match-package_1.2.3", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                // Exact version match
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0006", "affected", "1.2.3");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 1);

    auto detectedCVEs = result->detectedCVEs();
    auto it = detectedCVEs.begin();
    EXPECT_EQ(it->second.cveId, "CVE-2024-0006");
    EXPECT_EQ(it->second.conditionType, MatchRuleCondition::Equal);
    EXPECT_EQ(it->second.matchCondition, "1.2.3");
}

// ============================================================================
// TEST 12: Version below lower bound - should not match
// ============================================================================
TEST_F(PackageScannerTest, TestHandleRequestVersionBelowLowerBound)
{
    auto ctx = createContext("012", "test-agent-12", "Ubuntu", "ubuntu");
    auto scanContext = std::make_shared<TScanContext<TrampolineOsDataCache, TrampolineGlobalData>>(ctx);

    PackageContextData pkg;
    pkg.name = "old-version-package";
    pkg.version = "1.0.0";
    pkg.format = "deb";

    scanContext->addPackageToContext("012_old-version-package_1.0.0", pkg, ElementOperation::Upsert);

    auto spDatabaseFeedManagerMock = std::make_shared<MockDatabaseFeedManager>();

    EXPECT_CALL(*spDatabaseFeedManagerMock, getCnaNameByFormat("deb")).WillOnce(Return("ubuntu"));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getTranslationFromL2(_, _))
        .WillOnce(Return(std::vector<TranslatedData> {}));

    EXPECT_CALL(*spDatabaseFeedManagerMock, getVulnerabilitiesCandidates("ubuntu", _, _))
        .WillOnce(Invoke(
            [](const std::string& cnaName,
               const PackageData& package,
               const std::function<bool(
                   const std::string&, const PackageData&, const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>&
                   callback)
            {
                // Version range: 2.0.0 <= version < 3.0.0
                // Our package (1.0.0) is below lower bound
                auto fbData = createVulnerabilityCandidateFB("CVE-2024-0007", "affected", "2.0.0", "3.0.0");
                auto candidate =
                    flatbuffers::GetRoot<NSVulnerabilityScanner::ScanVulnerabilityCandidate>(fbData.data());
                callback(cnaName, package, *candidate);
                return true;
            }));

    TPackageScanner<MockDatabaseFeedManager,
                    TScanContext<TrampolineOsDataCache, TrampolineGlobalData>,
                    TrampolineGlobalData>
        packageScanner(spDatabaseFeedManagerMock);

    auto result = packageScanner.handleRequest(scanContext);

    ASSERT_NE(result, nullptr);
    EXPECT_EQ(result->cveCount(), 0); // Should not match - below lower bound
}
