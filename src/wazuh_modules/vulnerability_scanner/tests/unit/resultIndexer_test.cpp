/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "resultIndexer_test.hpp"
#include "../../src/scanOrchestrator/factory/resultIndexer.hpp"
#include "../../src/scanOrchestrator/scanContext.hpp"
#include "MockIndexerConnector.hpp"
#include "TrampolineIndexerConnector.hpp"
#include "TrampolineOsDataCache.hpp"
#include "json.hpp"

using ::testing::_;

const std::string CVEID {"CVE-2024-1234"};

std::shared_ptr<MockIndexerConnector> spIndexerConnectorMock;

void ResultIndexerTest::SetUp() {}

void ResultIndexerTest::TearDown()
{
    spIndexerConnectorMock.reset();
}

/*
 * @brief Test handleRequest of the ResultIndexer class with Upsert operation.
 */
TEST_F(ResultIndexerTest, TestHandleRequest)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // Expect bulkIndex to be called once with correct parameters
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, "wazuh-states-vulnerabilities", _)).Times(1);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "amd64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";
    
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);
    
    // Use new API with Delete operation
    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    std::string detectionId = "001_libgif7_" + CVEID;
    scanContextOriginal->addDetectedCVE(detectionId, std::move(detection));
    
    // Add ECS event
    nlohmann::json ecsEvent;
    ecsEvent["vulnerability"]["id"] = CVEID;
    ecsEvent["vulnerability"]["category"] = "Package";
    scanContextOriginal->addECSEvent(detectionId, ecsEvent.dump());

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestNoEcsEvent)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // No bulkIndex should be called if there's no ECS event
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, _, _)).Times(0);
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, _)).Times(0);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "amd64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";
    
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);
    
    // Add detection but NO ECS event - should skip indexing
    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("detection_id", std::move(detection));
    // Intentionally NOT adding ECS event

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestEmptyContext)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // No indexing should happen with empty context
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, _, _)).Times(0);
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, _)).Times(0);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "amd64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";
    
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);
    // No detections added - empty context

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestDeleteOperation)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // Expect bulkDelete to be called once for Delete operation
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, "wazuh-states-vulnerabilities")).Times(1);
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, _, _)).Times(0);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "amd64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";
    
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);
    
    // Use new API with Delete operation
    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = ElementOperation::Delete;  // Delete operation
    detection.componentType = AffectedComponentType::Package;
    std::string detectionId = "001_libgif7_" + CVEID;
    scanContextOriginal->addDetectedCVE(detectionId, std::move(detection));
    
    // Add ECS event (even for delete, we need it to process)
    nlohmann::json ecsEvent;
    ecsEvent["vulnerability"]["id"] = CVEID;
    scanContextOriginal->addECSEvent(detectionId, ecsEvent.dump());

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestMultipleDetections)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // Expect 2 bulkIndex calls and 1 bulkDelete call
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, "wazuh-states-vulnerabilities", _)).Times(2);
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, "wazuh-states-vulnerabilities")).Times(1);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "amd64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";
    
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    // Add multiple detections with different operations
    CVEDetectionResult detection1;
    detection1.cveId = "CVE-2023-1111";
    detection1.operation = ElementOperation::Upsert;
    detection1.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("001_pkg1_CVE-2023-1111", std::move(detection1));
    nlohmann::json ecs1;
    ecs1["vulnerability"]["id"] = "CVE-2023-1111";
    scanContextOriginal->addECSEvent("001_pkg1_CVE-2023-1111", ecs1.dump());

    CVEDetectionResult detection2;
    detection2.cveId = "CVE-2023-2222";
    detection2.operation = ElementOperation::Upsert;
    detection2.componentType = AffectedComponentType::Os;
    scanContextOriginal->addDetectedCVE("002_os_CVE-2023-2222", std::move(detection2));
    nlohmann::json ecs2;
    ecs2["vulnerability"]["id"] = "CVE-2023-2222";
    scanContextOriginal->addECSEvent("002_os_CVE-2023-2222", ecs2.dump());

    CVEDetectionResult detection3;
    detection3.cveId = "CVE-2023-3333";
    detection3.operation = ElementOperation::Delete;
    detection3.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("003_pkg2_CVE-2023-3333", std::move(detection3));
    nlohmann::json ecs3;
    ecs3["vulnerability"]["id"] = "CVE-2023-3333";
    scanContextOriginal->addECSEvent("003_pkg2_CVE-2023-3333", ecs3.dump());

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestMixedWithAndWithoutEcsEvents)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // Only 1 bulkIndex for the detection with ECS event
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, "wazuh-states-vulnerabilities", _)).Times(1);
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, _)).Times(0);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "amd64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";
    
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);

    // Detection WITH ECS event
    CVEDetectionResult detection1;
    detection1.cveId = "CVE-WITH-ECS";
    detection1.operation = ElementOperation::Upsert;
    detection1.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("detection_with_ecs", std::move(detection1));
    nlohmann::json ecs1;
    ecs1["vulnerability"]["id"] = "CVE-WITH-ECS";
    scanContextOriginal->addECSEvent("detection_with_ecs", ecs1.dump());

    // Detection WITHOUT ECS event - should be skipped
    CVEDetectionResult detection2;
    detection2.cveId = "CVE-WITHOUT-ECS";
    detection2.operation = ElementOperation::Upsert;
    detection2.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("detection_without_ecs", std::move(detection2));
    // Intentionally NOT adding ECS event for this one

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

/*
 * @brief Test that handleRequest returns the scan context (chain of responsibility pattern).
 */
TEST_F(ResultIndexerTest, TestHandleRequestReturnsContext)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, "wazuh-states-vulnerabilities", _)).Times(1);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "amd64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";
    
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);
    
    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    std::string detectionId = "001_libgif7_" + CVEID;
    scanContextOriginal->addDetectedCVE(detectionId, std::move(detection));
    
    nlohmann::json ecsEvent;
    ecsEvent["vulnerability"]["id"] = CVEID;
    scanContextOriginal->addECSEvent(detectionId, ecsEvent.dump());

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData>>>(
        pIndexerConnectorTrap);

    // Verify handleRequest returns a valid context pointer
    auto returnedContext = spResultIndexer->handleRequest(scanContextOriginal);
    EXPECT_NE(returnedContext, nullptr);
    EXPECT_EQ(returnedContext->agentId(), "001");
}

/*
 * @brief Test handling of detection with unrecognized operation type.
 * Should not call bulkIndex or bulkDelete for operations other than Upsert/Delete.
 */
TEST_F(ResultIndexerTest, TestHandleRequestUnknownOperation)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // No indexing should happen for unknown operations
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, _, _)).Times(0);
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, _)).Times(0);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "amd64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";
    
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);
    
    // Add detection with an operation that's not explicitly handled
    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = static_cast<ElementOperation>(999); // Invalid operation
    detection.componentType = AffectedComponentType::Package;
    std::string detectionId = "001_unknown_" + CVEID;
    scanContextOriginal->addDetectedCVE(detectionId, std::move(detection));
    
    // Add ECS event to ensure detection is processed
    nlohmann::json ecsEvent;
    ecsEvent["vulnerability"]["id"] = CVEID;
    scanContextOriginal->addECSEvent(detectionId, ecsEvent.dump());

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData>>>(
        pIndexerConnectorTrap);

    // Should not throw, but also should not index/delete
    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

/*
 * @brief Test that indexName uses correct string "wazuh-states-vulnerabilities".
 */
TEST_F(ResultIndexerTest, TestHandleRequestVerifyIndexName)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    
    // Verify the exact index name is used
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, "wazuh-states-vulnerabilities", _))
        .Times(1)
        .WillOnce(testing::Return());

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    Context ctx;
    ctx.agentId = "001";
    ctx.agentName = "focal";
    ctx.agentVersion = "4.5.0";
    ctx.architecture = "amd64";
    ctx.hostname = "test-host";
    ctx.osname = "Ubuntu";
    ctx.osplatform = "ubuntu";
    ctx.ostype = "Linux";
    ctx.osversion = "20.04";
    
    auto scanContextOriginal = std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData>>(ctx);
    
    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    std::string detectionId = "001_verify_index_" + CVEID;
    scanContextOriginal->addDetectedCVE(detectionId, std::move(detection));
    
    nlohmann::json ecsEvent;
    ecsEvent["vulnerability"]["id"] = CVEID;
    ecsEvent["@timestamp"] = "2024-01-01T00:00:00.000Z";
    scanContextOriginal->addECSEvent(detectionId, ecsEvent.dump());

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}


