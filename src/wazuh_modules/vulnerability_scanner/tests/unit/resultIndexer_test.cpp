/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "resultIndexer_test.hpp"
#include "../scanOrchestrator/resultIndexer.hpp"
#include "../scanOrchestrator/scanContext.hpp"
#include "MockIndexerConnector.hpp"
#include "MockOsDataCache.hpp"
#include "TrampolineIndexerConnector.hpp"
#include "TrampolineOsDataCache.hpp"
#include "TrampolineRemediationDataCache.hpp"
#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "json.hpp"

using ::testing::_;

namespace NSResultIndexerTest
{
    const std::string DELTA_PACKAGES_INSERTED_MSG =
        R"(
            {
                "agent_info": {
                    "agent_id": "001",
                    "agent_ip": "192.168.33.20",
                    "agent_name": "focal"
                },
                "data_type": "dbsync_packages",
                "data": {
                    "architecture": "amd64",
                    "checksum": "1e6ce14f97f57d1bbd46ff8e5d3e133171a1bbce",
                    "description": "library for GIF images library",
                    "format": "deb",
                    "groups": "libs",
                    "item_id": "ec465b7eb5fa011a336e95614072e4c7f1a65a53",
                    "multiarch": "same",
                    "name": "libgif7",
                    "priority": "optional",
                    "scan_time": "2023/08/04 19:56:11",
                    "size": 72,
                    "source": "giflib",
                    "vendor": "Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>",
                    "version": "5.1.9-1",
                    "install_time": "1577890801"
                },
                "operation": "INSERTED"
            }
        )";

    const std::string CVEID {"CVE-2024-1234"};

    // Helpers

    const Os osData {.hostName = "osdata_hostname",
                     .architecture = "osdata_architecture",
                     .name = "osdata_name",
                     .codeName = "osdata_codeName",
                     .majorVersion = "osdata_majorVersion",
                     .minorVersion = "osdata_minorVersion",
                     .patch = "osdata_patch",
                     .build = "osdata_build",
                     .platform = "osdata_platform",
                     .version = "osdata_version",
                     .release = "osdata_release",
                     .displayVersion = "osdata_displayVersion",
                     .sysName = "osdata_sysName",
                     .kernelVersion = "osdata_kernelVersion",
                     .kernelRelease = "osdata_kernelRelease"};

    void expectOsData()
    {
        spOsDataCacheMock = std::make_shared<MockOsDataCache>();
        EXPECT_CALL(*spOsDataCacheMock, getOsData(_, _))
            .WillOnce(testing::Invoke(
                [](const std::string&, Os& osDataResult)
                {
                    osDataResult = osData;
                    return true;
                }));
    }
} // namespace NSResultIndexerTest

using namespace NSResultIndexerTest;

std::shared_ptr<MockIndexerConnector> spIndexerConnectorMock;

void ResultIndexerTest::SetUp() {}

void ResultIndexerTest::TearDown()
{
    spIndexerConnectorMock.reset();
    spOsDataCacheMock.reset();
    spRemediationDataCacheMock.reset();
}

/*
 * @brief Test handleRequest of the ResultIndexer class with Upsert operation.
 */
TEST_F(ResultIndexerTest, TestHandleRequest)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // Expect bulkIndex to be called once with correct parameters
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, "wazuh-states-vulnerabilities", _)).Times(1);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContextOriginal =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    
    // Use new API: add detection and ECS event
    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    std::string detectionId = "001_libgif7_" + CVEID;
    scanContextOriginal->addDetectedCVE(detectionId, std::move(detection));
    
    // Add ECS event
    nlohmann::json ecsEvent;
    ecsEvent["vulnerability"]["id"] = CVEID;
    ecsEvent["vulnerability"]["category"] = "Package";
    scanContextOriginal->addECSEvent(detectionId, ecsEvent.dump());

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestNoEcsEvent)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // No bulkIndex should be called if there's no ECS event
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, _, _)).Times(0);
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, _)).Times(0);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContextOriginal =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    
    // Add detection but NO ECS event - should skip indexing
    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = ElementOperation::Upsert;
    detection.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("detection_id", std::move(detection));
    // Intentionally NOT adding ECS event

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestEmptyContext)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // No indexing should happen with empty context
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, _, _)).Times(0);
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, _)).Times(0);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContextOriginal =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    // No detections added - empty context

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestDeleteOperation)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // Expect bulkDelete to be called once for Delete operation
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, "wazuh-states-vulnerabilities")).Times(1);
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, _, _)).Times(0);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContextOriginal =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);
    
    // Use new API with Delete operation
    CVEDetectionResult detection;
    detection.cveId = CVEID;
    detection.operation = ElementOperation::Delete;  // Delete operation
    detection.componentType = AffectedComponentType::Package;
    std::string detectionId = "001_libgif7_" + CVEID;
    scanContextOriginal->addDetectedCVE(detectionId, std::move(detection));
    
    // Add ECS event (even for delete, we need it to process)
    nlohmann::json ecsEvent;
    ecsEvent["vulnerability"]["id"] = CVEID;
    scanContextOriginal->addECSEvent(detectionId, ecsEvent.dump());

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestMultipleDetections)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // Expect 2 bulkIndex calls and 1 bulkDelete call
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, "wazuh-states-vulnerabilities", _)).Times(2);
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, "wazuh-states-vulnerabilities")).Times(1);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContextOriginal =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);

    // Add multiple detections with different operations
    CVEDetectionResult detection1;
    detection1.cveId = "CVE-2023-1111";
    detection1.operation = ElementOperation::Upsert;
    detection1.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("001_pkg1_CVE-2023-1111", std::move(detection1));
    nlohmann::json ecs1;
    ecs1["vulnerability"]["id"] = "CVE-2023-1111";
    scanContextOriginal->addECSEvent("001_pkg1_CVE-2023-1111", ecs1.dump());

    CVEDetectionResult detection2;
    detection2.cveId = "CVE-2023-2222";
    detection2.operation = ElementOperation::Upsert;
    detection2.componentType = AffectedComponentType::Os;
    scanContextOriginal->addDetectedCVE("002_os_CVE-2023-2222", std::move(detection2));
    nlohmann::json ecs2;
    ecs2["vulnerability"]["id"] = "CVE-2023-2222";
    scanContextOriginal->addECSEvent("002_os_CVE-2023-2222", ecs2.dump());

    CVEDetectionResult detection3;
    detection3.cveId = "CVE-2023-3333";
    detection3.operation = ElementOperation::Delete;
    detection3.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("003_pkg2_CVE-2023-3333", std::move(detection3));
    nlohmann::json ecs3;
    ecs3["vulnerability"]["id"] = "CVE-2023-3333";
    scanContextOriginal->addECSEvent("003_pkg2_CVE-2023-3333", ecs3.dump());

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}

TEST_F(ResultIndexerTest, TestHandleRequestMixedWithAndWithoutEcsEvents)
{
    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    // Only 1 bulkIndex for the detection with ECS event
    EXPECT_CALL(*spIndexerConnectorMock, bulkIndex(_, "wazuh-states-vulnerabilities", _)).Times(1);
    EXPECT_CALL(*spIndexerConnectorMock, bulkDelete(_, _)).Times(0);

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    expectOsData();

    spRemediationDataCacheMock = std::make_shared<MockRemediationDataCache>();
    EXPECT_CALL(*spRemediationDataCacheMock, getRemediationData(_)).WillRepeatedly(testing::Return(Remediation {}));

    flatbuffers::Parser parser;
    ASSERT_TRUE(parser.Parse(syscollector_deltas_SCHEMA));
    ASSERT_TRUE(parser.Parse(DELTA_PACKAGES_INSERTED_MSG.c_str()));
    uint8_t* buffer = parser.builder_.GetBufferPointer();
    std::variant<const SyscollectorDeltas::Delta*, const Synchronization::SyncMsg*, const nlohmann::json*>
        syscollectorDelta = SyscollectorDeltas::GetDelta(reinterpret_cast<const char*>(buffer));
    auto scanContextOriginal =
        std::make_shared<TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>(
            syscollectorDelta);

    // Detection WITH ECS event
    CVEDetectionResult detection1;
    detection1.cveId = "CVE-WITH-ECS";
    detection1.operation = ElementOperation::Upsert;
    detection1.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("detection_with_ecs", std::move(detection1));
    nlohmann::json ecs1;
    ecs1["vulnerability"]["id"] = "CVE-WITH-ECS";
    scanContextOriginal->addECSEvent("detection_with_ecs", ecs1.dump());

    // Detection WITHOUT ECS event - should be skipped
    CVEDetectionResult detection2;
    detection2.cveId = "CVE-WITHOUT-ECS";
    detection2.operation = ElementOperation::Upsert;
    detection2.componentType = AffectedComponentType::Package;
    scanContextOriginal->addDetectedCVE("detection_without_ecs", std::move(detection2));
    // Intentionally NOT adding ECS event for this one

    auto spResultIndexer = std::make_shared<
        TResultIndexer<TrampolineIndexerConnector,
                       TScanContext<TrampolineOsDataCache, GlobalData, TrampolineRemediationDataCache>>>(
        pIndexerConnectorTrap);

    EXPECT_NO_THROW(spResultIndexer->handleRequest(scanContextOriginal));
}
