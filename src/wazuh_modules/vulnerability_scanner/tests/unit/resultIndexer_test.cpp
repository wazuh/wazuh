/*
 * Wazuh Vulnerability Scanner - Unit Tests
 * Copyright (C) 2015, Wazuh Inc.
 * September 21, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "MockIndexerConnector.hpp"
#include "scanOrchestrator/factory/resultIndexer.hpp"
#include "schemaValidator.hpp"
#include "gmock/gmock.h"
#include "gtest/gtest.h"

using ::testing::_;
using ::testing::A;
using ::testing::Return;

namespace
{
    class MockSchemaValidatorEngine : public SchemaValidator::ISchemaValidatorEngine
    {
    public:
        MOCK_METHOD(SchemaValidator::ValidationResult, validate, (const std::string&), (override));
        MOCK_METHOD(SchemaValidator::ValidationResult, validate, (const nlohmann::json&), (override));
        MOCK_METHOD(std::string, getSchemaName, (), (const, override));
    };

    class SchemaValidatorGuard
    {
    public:
        SchemaValidatorGuard() = default;
        ~SchemaValidatorGuard()
        {
            SchemaValidator::SchemaValidatorFactory::getInstance().reset();
        }
    };

    std::shared_ptr<ScanContext>
    buildScanContext(const std::string& detectionId, ElementOperation operation, const std::string& ecsEvent)
    {
        auto context = std::make_shared<ScanContext>();

        CVEDetectionResult detection {};
        detection.operation = operation;
        context->addDetectedCVE(detectionId, std::move(detection));
        context->addECSEvent(detectionId, std::string {ecsEvent});

        return context;
    }

    void addDetection(std::shared_ptr<ScanContext> context,
                      const std::string& detectionId,
                      ElementOperation operation,
                      const std::optional<std::string>& ecsEvent = std::nullopt)
    {
        CVEDetectionResult detection {};
        detection.operation = operation;
        context->addDetectedCVE(detectionId, std::move(detection));
        if (ecsEvent)
        {
            context->addECSEvent(detectionId, std::string {*ecsEvent});
        }
    }
} // namespace

TEST(ResultIndexerTest, IndexesWhenValidatorNotInitialized)
{
    SchemaValidatorGuard guard;

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);

    auto context = buildScanContext("agent_pkg_cve", ElementOperation::Upsert, "{}");

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(1);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, SkipsIndexingWhenValidationFails)
{
    SchemaValidatorGuard guard;

    auto validator = std::make_shared<MockSchemaValidatorEngine>();
    SchemaValidator::ValidationResult failure;
    failure.isValid = false;
    failure.errors = {"missing field"};

    EXPECT_CALL(*validator, validate(A<const std::string&>())).WillOnce(Return(failure));

    std::map<std::string, std::shared_ptr<SchemaValidator::ISchemaValidatorEngine>> validators;
    validators["wazuh-states-vulnerabilities"] = validator;
    SchemaValidator::SchemaValidatorFactory::getInstance().initialize(std::move(validators));

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);
    auto context = buildScanContext("agent_pkg_cve", ElementOperation::Upsert, "{}");

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(0);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, IndexesWhenValidationSucceeds)
{
    SchemaValidatorGuard guard;

    auto validator = std::make_shared<MockSchemaValidatorEngine>();
    SchemaValidator::ValidationResult success;
    success.isValid = true;

    EXPECT_CALL(*validator, validate(A<const std::string&>())).WillOnce(Return(success));

    std::map<std::string, std::shared_ptr<SchemaValidator::ISchemaValidatorEngine>> validators;
    validators["wazuh-states-vulnerabilities"] = validator;
    SchemaValidator::SchemaValidatorFactory::getInstance().initialize(std::move(validators));

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);
    auto context = buildScanContext("agent_pkg_cve", ElementOperation::Upsert, "{}");

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(1);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, IndexesWhenValidatorForIndexIsMissing)
{
    SchemaValidatorGuard guard;

    std::map<std::string, std::shared_ptr<SchemaValidator::ISchemaValidatorEngine>> validators;
    validators["other-index"] = std::make_shared<MockSchemaValidatorEngine>();
    SchemaValidator::SchemaValidatorFactory::getInstance().initialize(std::move(validators));

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);
    auto context = buildScanContext("agent_pkg_cve", ElementOperation::Upsert, "{}");

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(1);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, DeletesWhenDetectionIsMarkedForDelete)
{
    SchemaValidatorGuard guard;

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);

    auto context = buildScanContext("agent_pkg_cve", ElementOperation::Delete, "{}");

    EXPECT_CALL(*indexerConnector, bulkDelete(_, _)).Times(1);
    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(0);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, SkipsWhenECSEventIsMissing)
{
    SchemaValidatorGuard guard;

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);

    auto context = std::make_shared<ScanContext>();
    CVEDetectionResult detection {};
    detection.operation = ElementOperation::Upsert;
    context->addDetectedCVE("agent_pkg_cve", std::move(detection));

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(0);
    EXPECT_CALL(*indexerConnector, bulkDelete(_, _)).Times(0);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, SkipsWhenNoDetectionsExist)
{
    SchemaValidatorGuard guard;

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);

    auto context = std::make_shared<ScanContext>();

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(0);
    EXPECT_CALL(*indexerConnector, bulkDelete(_, _)).Times(0);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, IndexesMultipleDetections)
{
    SchemaValidatorGuard guard;

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);

    auto context = std::make_shared<ScanContext>();
    addDetection(context, "001_pkg1_CVE-2023-1111", ElementOperation::Upsert, "{}");
    addDetection(context, "002_os_CVE-2023-2222", ElementOperation::Upsert, "{}");
    addDetection(context, "003_pkg2_CVE-2023-3333", ElementOperation::Delete, "{}");

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(2);
    EXPECT_CALL(*indexerConnector, bulkDelete(_, _)).Times(1);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, IndexesOnlyDetectionsWithECSEvent)
{
    SchemaValidatorGuard guard;

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);

    auto context = std::make_shared<ScanContext>();
    addDetection(context, "detection_with_ecs", ElementOperation::Upsert, "{}");
    addDetection(context, "detection_without_ecs", ElementOperation::Upsert, std::nullopt);

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(1);
    EXPECT_CALL(*indexerConnector, bulkDelete(_, _)).Times(0);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, ReturnsContextAfterHandling)
{
    SchemaValidatorGuard guard;

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);

    auto context = buildScanContext("agent_pkg_cve", ElementOperation::Upsert, "{}");

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(1);
    auto returned = indexer.handleRequest(context);
    EXPECT_EQ(returned.get(), context.get());
}

TEST(ResultIndexerTest, IgnoresUnknownOperation)
{
    SchemaValidatorGuard guard;

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);

    auto context = std::make_shared<ScanContext>();
    addDetection(context, "unknown_op", static_cast<ElementOperation>(999), "{}");

    EXPECT_CALL(*indexerConnector, bulkIndex(_, _, _)).Times(0);
    EXPECT_CALL(*indexerConnector, bulkDelete(_, _)).Times(0);
    indexer.handleRequest(context);
}

TEST(ResultIndexerTest, UsesVulnerabilitiesIndexName)
{
    SchemaValidatorGuard guard;

    auto indexerConnector = std::make_shared<MockIndexerConnector>();
    TResultIndexer<MockIndexerConnector> indexer(indexerConnector);
    auto context = buildScanContext("agent_pkg_cve", ElementOperation::Upsert, "{}");

    EXPECT_CALL(*indexerConnector, bulkIndex(_, "wazuh-states-vulnerabilities", _)).Times(1);
    indexer.handleRequest(context);
}
