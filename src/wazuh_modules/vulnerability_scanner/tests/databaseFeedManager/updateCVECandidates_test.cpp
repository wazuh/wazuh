/*
 * Wazuh databaseFeedManager
 * Copyright (C) 2015, Wazuh Inc.
 * October 9, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "updateCVECandidates_test.hpp"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "flatbuffers/verifier.h"
#include "rocksDBWrapper.hpp"
#include "updateCVECandidates.hpp"
#include <unordered_map>

const std::string cve5FlatbufferSchemaPath {FLATBUFFER_SCHEMAS_DIR "/cve5.fbs"};
const std::string vulnerabilityCandidateFlatbufferSchemaPath {FLATBUFFER_SCHEMAS_DIR "/vulnerabilityCandidate.fbs"};
const char* INCLUDE_DIRECTORIES[] = {FLATBUFFER_SCHEMAS_DIR, nullptr};

const std::string cveId = "CVE-2010-0002";

const std::string cveInput = R"(
    {
    "containers": {
        "adp": [
            {
                "affected": [
                    {
                        "defaultStatus": "unknown",
                        "product": "bash",
                        "vendor" : "canonical",
                        "platforms": [
                            "upstream"
                        ],
                        "versions": [
                            {
                                "lessThan": "98.0.4758.102",
                                "status": "affected",
                                "version": "0",
                                "versionType": "custom"
                            }
                        ]
                    },
                    {
                        "defaultStatus": "unaffected",
                        "product": "bash",
                        "vendor" : "canonical",
                        "platforms": [
                            "dapper",
                            "hardy",
                            "intrepid",
                            "jaunty",
                            "karmic",
                            "lucid"
                        ]
                    }
                ],
                "descriptions": [
                    {
                        "lang": "en",
                        "value": "The /etc/profile.d/60alias.sh script in the Mandriva bash package for Bash\n2.05b, 3.0, 3.2, 3.2.48, and 4.0 enables the --show-control-chars option in\nLS_OPTIONS, which allows local users to send escape sequences to terminal\nemulators, or hide the existence of a file, via a crafted filename."
                    },
                    {
                        "lang": "en",
                        "value": "Mandriva-specific"
                    }
                ],
                "providerMetadata": {
                    "orgId": "00000000-0000-4000-A000-000000000000",
                    "shortName" : "canonical"
                },
                "references": [
                    {
                        "url": "https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0002"
                    }
                ]
            },
            {
                "affected": [
                    {
                        "defaultStatus": "unaffected",
                        "platforms": [
                            "bookworm",
                            "bullseye",
                            "buster",
                            "sid",
                            "trixie"
                        ],
                        "product": "bash",
                        "vendor": "debian"
                    }
                ],
                "descriptions": [
                    {
                        "lang": "en",
                        "value": "The /etc/profile.d/60alias.sh script in the Mandriva bash package for Bash 2.05b, 3.0, 3.2, 3.2.48, and 4.0 enables the --show-control-chars option in LS_OPTIONS, which allows local users to send escape sequences to terminal emulators, or hide the existence of a file, via a crafted filename."
                    }
                ],
                "providerMetadata": {
                    "orgId": "79363d38-fa19-49d1-9214-5f28da3f3ac5",
                    "shortName" : "debian"
                },
                "references": [
                    {
                        "url": "https://security-tracker.debian.org/tracker/CVE-2010-0002"
                    }
                ]
            }
        ],
        "cna": {
            "affected": [
                {
                    "cpes": [
                        "cpe:2.3:a:gnu:bash:3.2.48:*:*:*:*:*:*:*",
                        "cpe:2.3:a:gnu:bash:3.0:*:*:*:*:*:*:*",
                        "cpe:2.3:a:gnu:bash:4.0:*:*:*:*:*:*:*",
                        "cpe:2.3:a:gnu:bash:3.2:*:*:*:*:*:*:*"
                    ],
                    "defaultStatus": "unaffected",
                    "product": "bash",
                    "vendor": "gnu",
                    "versions": [
                        {
                            "status": "affected",
                            "version": "3.2.48"
                        },
                        {
                            "status": "affected",
                            "version": "3.0"
                        },
                        {
                            "status": "affected",
                            "version": "4.0"
                        },
                        {
                            "status": "affected",
                            "version": "3.2"
                        }
                    ]
                }
            ],
            "descriptions": [
                {
                    "lang": "en",
                    "value": "The /etc/profile.d/60alias.sh script in the Mandriva bash package for Bash 2.05b, 3.0, 3.2, 3.2.48, and 4.0 enables the --show-control-chars option in LS_OPTIONS, which allows local users to send escape sequences to terminal emulators, or hide the existence of a file, via a crafted filename."
                }
            ],
            "metrics": [
                {
                    "cvssV2_0": {
                        "accessComplexity": "LOW",
                        "accessVector": "LOCAL",
                        "authentication": "NONE",
                        "availabilityImpact": "PARTIAL",
                        "baseScore": 2.1,
                        "confidentialityImpact": "NONE",
                        "integrityImpact": "NONE",
                        "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P",
                        "version": "2.0"
                    },
                    "format": "CVSS"
                }
            ],
            "problemTypes": [
                {
                    "descriptions": [
                        {
                            "description": "CWE-20",
                            "lang": "en"
                        }
                    ]
                }
            ],
            "providerMetadata": {
                "orgId": "00000000-0000-4000-A000-000000000001",
                "shortName": "nvd"
            },
            "references": [
                {
                    "name": "https://qa.mandriva.com/show_bug.cgi?id=56882",
                    "url": "https://qa.mandriva.com/show_bug.cgi?id=56882"
                },
                {
                    "name": "MDVSA-2010:004",
                    "tags": [
                        "patch",
                        "vendor-advisory"
                    ],
                    "url": "http://www.mandriva.com/security/advisories?name=MDVSA-2010:004"
                }
            ]
        }
    },
    "cveMetadata": {
        "assignerOrgId": "00000000-0000-4000-A000-000000000000",
        "assignerShortName": "@redhat.com",
        "cveId": "CVE-2010-0002",
        "datePublished": "2010-01-14T18:30:00.000Z",
        "dateUpdated": "2011-08-08T04:00:00.000Z",
        "state": "PUBLISHED"
    },
    "dataType": "CVE_RECORD",
    "dataVersion": "5.0"
}
)";

TEST_F(UpdateCVECandidatesTest, UpdateCVECandidateSuccess)
{
    std::string cve5FlatbufferSchemaStr;

    // Read schemas from filesystem.
    bool valid = flatbuffers::LoadFile(cve5FlatbufferSchemaPath.c_str(), false, &cve5FlatbufferSchemaStr);
    ASSERT_EQ(valid, true);

    // Parse schemas and JSON example.
    flatbuffers::Parser parser;
    valid = (parser.Parse(cve5FlatbufferSchemaStr.c_str(), INCLUDE_DIRECTORIES) && parser.Parse(cveInput.c_str()));
    ASSERT_EQ(valid, true);

    // Get flatbuffer pointer
    uint8_t* buf = parser.builder_.GetBufferPointer();
    size_t flatbufferSize = parser.builder_.GetSize();

    // Verify flatbuffer.
    flatbuffers::Verifier verifierCVE5(buf, flatbufferSize);
    ASSERT_EQ(cve_v5::VerifyEntryBuffer(verifierCVE5), true);
    const cve_v5::Entry* cve5Flatbuffer = cve_v5::GetEntry(buf);

    // Call function.
    UpdateCVECandidates::storeVulnerabilityCandidate(cve5Flatbuffer, m_dbMap);

    // Verify Debian data
    rocksdb::PinnableSlice slice;
    EXPECT_NO_THROW(m_dbMap.at("debian")->get("bash_CVE-2010-0002", slice));

    flatbuffers::Verifier verifierVulnCandidate(reinterpret_cast<const uint8_t*>(slice.data()), slice.size());
    EXPECT_EQ(NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateArrayBuffer(verifierVulnCandidate), true);

    auto data = NSVulnerabilityScanner::GetScanVulnerabilityCandidateArray(slice.data());
    EXPECT_EQ(data->candidates()->size(), 1);
    auto debianData = data->candidates()->Get(0);

    // Verify Debian values
    EXPECT_EQ(debianData->cveId()->str(), cveId);
    EXPECT_EQ(debianData->defaultStatus(), NSVulnerabilityScanner::Status::Status_unaffected);
    EXPECT_EQ(debianData->platforms()->size(), 5);
    EXPECT_EQ(debianData->platforms()->Get(0)->str(), "bookworm");
    EXPECT_EQ(debianData->platforms()->Get(1)->str(), "bullseye");
    EXPECT_EQ(debianData->platforms()->Get(2)->str(), "buster");
    EXPECT_EQ(debianData->platforms()->Get(3)->str(), "sid");
    EXPECT_EQ(debianData->platforms()->Get(4)->str(), "trixie");
    EXPECT_EQ(debianData->versions()->size(), 0);

    // Verify NVD data
    EXPECT_NO_THROW(m_dbMap.at("nvd")->get("bash_CVE-2010-0002", slice));

    flatbuffers::Verifier verifierVulnCandidate2(reinterpret_cast<const uint8_t*>(slice.data()), slice.size());
    EXPECT_EQ(NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateArrayBuffer(verifierVulnCandidate2), true);

    data = NSVulnerabilityScanner::GetScanVulnerabilityCandidateArray(slice.data());
    EXPECT_EQ(data->candidates()->size(), 1);

    auto nvdData = data->candidates()->Get(0);

    // Verify NVD values
    EXPECT_EQ(nvdData->cveId()->str(), cveId);
    EXPECT_EQ(nvdData->defaultStatus(), NSVulnerabilityScanner::Status::Status_unaffected);
    EXPECT_EQ(nvdData->platforms()->size(), 0);
    EXPECT_EQ(nvdData->versions()->size(), 4);
    EXPECT_EQ(nvdData->versions()->Get(0)->status(), NSVulnerabilityScanner::Status::Status_affected);
    EXPECT_EQ(nvdData->versions()->Get(0)->version()->str(), "3.2.48");
    EXPECT_EQ(nvdData->versions()->Get(1)->status(), NSVulnerabilityScanner::Status::Status_affected);
    EXPECT_EQ(nvdData->versions()->Get(1)->version()->str(), "3.0");
    EXPECT_EQ(nvdData->versions()->Get(2)->status(), NSVulnerabilityScanner::Status::Status_affected);
    EXPECT_EQ(nvdData->versions()->Get(2)->version()->str(), "4.0");
    EXPECT_EQ(nvdData->versions()->Get(3)->status(), NSVulnerabilityScanner::Status::Status_affected);
    EXPECT_EQ(nvdData->versions()->Get(3)->version()->str(), "3.2");

    // Verify Canonical data
    EXPECT_NO_THROW(m_dbMap.at("canonical")->get("bash_CVE-2010-0002", slice));

    flatbuffers::Verifier verifierVulnCandidate3(reinterpret_cast<const uint8_t*>(slice.data()), slice.size());
    EXPECT_EQ(NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateArrayBuffer(verifierVulnCandidate3), true);

    data = NSVulnerabilityScanner::GetScanVulnerabilityCandidateArray(slice.data());
    EXPECT_EQ(data->candidates()->size(), 2);

    // Verify Canonical values
    auto canonicalData1 = data->candidates()->Get(0);
    auto canonicalData2 = data->candidates()->Get(1);

    EXPECT_EQ(canonicalData1->versions()->size(), 1);
    EXPECT_EQ(canonicalData1->versions()->Get(0)->status(), NSVulnerabilityScanner::Status::Status_affected);
    EXPECT_EQ(canonicalData1->versions()->Get(0)->version()->str(), "0");
    EXPECT_EQ(canonicalData1->versions()->Get(0)->versionType()->str(), "custom");
    EXPECT_EQ(canonicalData1->versions()->Get(0)->lessThan()->str(), "98.0.4758.102");
    EXPECT_EQ(canonicalData1->versions()->Get(0)->lessThanOrEqual(), nullptr);
    EXPECT_EQ(canonicalData1->cveId()->str(), cveId);
    EXPECT_EQ(canonicalData1->defaultStatus(), NSVulnerabilityScanner::Status::Status_unknown);
    EXPECT_EQ(canonicalData1->platforms()->size(), 1);
    EXPECT_EQ(canonicalData1->platforms()->Get(0)->str(), "upstream");

    EXPECT_EQ(canonicalData2->cveId()->str(), cveId);
    EXPECT_EQ(canonicalData2->defaultStatus(), NSVulnerabilityScanner::Status::Status_unaffected);
    EXPECT_EQ(canonicalData2->platforms()->size(), 6);
    EXPECT_EQ(canonicalData2->platforms()->Get(0)->str(), "dapper");
    EXPECT_EQ(canonicalData2->platforms()->Get(1)->str(), "hardy");
    EXPECT_EQ(canonicalData2->platforms()->Get(2)->str(), "intrepid");
    EXPECT_EQ(canonicalData2->platforms()->Get(3)->str(), "jaunty");
    EXPECT_EQ(canonicalData2->platforms()->Get(4)->str(), "karmic");
    EXPECT_EQ(canonicalData2->platforms()->Get(5)->str(), "lucid");
    EXPECT_EQ(canonicalData2->versions()->size(), 0);
}

TEST_F(UpdateCVECandidatesTest, RemoveCandidates)
{
    std::string cve5FlatbufferSchemaStr;

    // Read schemas from filesystem.
    bool valid = flatbuffers::LoadFile(cve5FlatbufferSchemaPath.c_str(), false, &cve5FlatbufferSchemaStr);
    ASSERT_EQ(valid, true);

    // Parse schemas and JSON example.
    flatbuffers::Parser parser;
    valid = (parser.Parse(cve5FlatbufferSchemaStr.c_str(), INCLUDE_DIRECTORIES) && parser.Parse(cveInput.c_str()));
    ASSERT_EQ(valid, true);

    // Get flatbuffer pointer
    uint8_t* buf = parser.builder_.GetBufferPointer();
    size_t flatbufferSize = parser.builder_.GetSize();

    // Verify flatbuffer.
    flatbuffers::Verifier verifierCVE5(buf, flatbufferSize);
    ASSERT_EQ(cve_v5::VerifyEntryBuffer(verifierCVE5), true);
    const cve_v5::Entry* cve5Flatbuffer = cve_v5::GetEntry(buf);

    // Call function.
    UpdateCVECandidates::storeVulnerabilityCandidate(cve5Flatbuffer, m_dbMap);

    // Verify data
    rocksdb::PinnableSlice slice;
    EXPECT_TRUE(m_dbMap.at("debian")->get("bash_CVE-2010-0002", slice));
    EXPECT_TRUE(m_dbMap.at("nvd")->get("bash_CVE-2010-0002", slice));
    EXPECT_TRUE(m_dbMap.at("canonical")->get("bash_CVE-2010-0002", slice));

    // Remove candidates
    EXPECT_NO_THROW(UpdateCVECandidates::removeVulnerabilityCandidate(cve5Flatbuffer, m_dbMap));

    // Verify data
    EXPECT_FALSE(m_dbMap.at("debian")->get("bash_CVE-2010-0002", slice));
    EXPECT_FALSE(m_dbMap.at("nvd")->get("bash_CVE-2010-0002", slice));
    EXPECT_FALSE(m_dbMap.at("canonical")->get("bash_CVE-2010-0002", slice));
}
