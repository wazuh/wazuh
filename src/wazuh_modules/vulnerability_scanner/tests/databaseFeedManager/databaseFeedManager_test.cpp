/*
 * Wazuh databaseFeedManager
 * Copyright (C) 2015, Wazuh Inc.
 * September 22, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */
#include "databaseFeedManager_test.h"
#include "MockContentRegister.hpp"
#include "MockIndexerConnector.hpp"
#include "MockPolicyManager.hpp"
#include "MockRouterSubscriber.hpp"
#include "TrampolineContentRegister.hpp"
#include "TrampolineIndexerConnector.hpp"
#include "TrampolinePolicyManager.hpp"
#include "TrampolineRouterSuscribe.hpp"
#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include <filesystem>
#include <string_view>

using ::testing::_;
using ::testing::Return;

constexpr auto COMMON_DATABASE_DIR {"queue/vd"}; //<<Used for all databases

constexpr auto CVEID_TEST_OK {"cveid_test_ok"};
constexpr auto CVEID_TEST_NOT_FOUND {"cveid_test_not_found"};
constexpr auto CVEID_TEST_CORRUPTED {"cveid_test_corrupted"};
const std::string FLATBUFFER_SCHEMA {FLATBUFFER_SCHEMAS_DIR "/vulnerabilityCandidate.fbs"};

// Variables used for candidate tests
const std::string VULNERABILITY_CANDIDATE_EXAMPLE {
    "[{\"cveId\":\"CVE-1999-1234\",\"defaultStatus\":\"unaffected\",\"platforms\":[\"ubuntu\"],"
    "\"versions\":[{\"status\":\"affected\",\"version\":\"1.0.2\"},{\"lessThan\":\"1.1.5-1\",\"status\":\"affected\","
    "\"version\":\"0\",\"versionType\":\"deb\"},"
    "{\"lessThan\":\"*\",\"status\":\"affected\",\"version\":\"0\",\"versionType\":\"custom\"}]},{\"cveId\":\"CVE-1999-"
    "1235\",\"defaultStatus\":\"unaffected\","
    "\"platforms\":[\"ubuntu\"],\"versions\":[{\"status\":\"affected\",\"version\":\"1.0.2\"},{\"lessThan\":\"1.1.5-"
    "1\",\"status\":\"affected\",\"version\":\"0\","
    "\"versionType\":\"deb\"},{\"lessThan\":\"*\",\"status\":\"affected\",\"version\":\"0\",\"versionType\":\"custom\"}"
    "]}]"};

const std::string PACKAGE_NAME {"libmagic-mgc"};

// External shared pointers definitions
std::shared_ptr<MockIndexerConnector> spIndexerConnectorMock;
std::shared_ptr<MockPolicyManager> spPolicyManagerMock;
std::shared_ptr<MockContentRegister> spContentRegisterMock;
std::shared_ptr<MockRouterSubscriber> spRouterSubscriberMock;

void DatabaseFeedManagerTest::SetUp()
{
    std::filesystem::create_directories(COMMON_DATABASE_DIR);

    std::string schemaStr;
    nlohmann::json jsonExample = nlohmann::json::parse(VULNERABILITY_CANDIDATE_EXAMPLE);

    bool valid = flatbuffers::LoadFile(FLATBUFFER_SCHEMA.c_str(), false, &schemaStr);
    assert(valid == true);
    assert(!jsonExample.empty());

    flatbuffers::Parser parser;
    valid = parser.Parse(schemaStr.c_str());
    assert(valid == true);

    Utils::RocksDBWrapper rocksDBWrapper(CANDIDATES_DATABASE_PATH);

    for (const auto& item : jsonExample)
    {
        valid = parser.Parse(item.dump().c_str());
        assert(valid == true);

        uint8_t* buf = parser.builder_.GetBufferPointer();
        const size_t flatbufferSize = parser.builder_.GetSize();

        const rocksdb::Slice vulnerabilityCandidate(reinterpret_cast<const char*>(buf), flatbufferSize);
        rocksDBWrapper.put(PACKAGE_NAME + "_" + item.at("cveId").get<std::string>(), vulnerabilityCandidate);
    }
};

void DatabaseFeedManagerTest::TearDown()
{
    // Reset shared_ptr owner
    spIndexerConnectorMock.reset();
    spPolicyManagerMock.reset();
    spContentRegisterMock.reset();
    spRouterSubscriberMock.reset();
    std::filesystem::remove_all(COMMON_DATABASE_DIR);
};

TEST_F(DatabaseFeedManagerTest, getVulnerabiltyDescriptiveInformation_Ok)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vdOriginalData = NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                                       999.99,
                                                                                       "classification_test_string",
                                                                                       "description_test_string",
                                                                                       "severity_test_string",
                                                                                       "scoreVersion_test_string",
                                                                                       "reference_test_string");
    fbBuilder.Finish(vdOriginalData);

    {
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(DESCRIPTION_DATABASE_PATH);
        rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
        dbWrapper->put(CVEID_TEST_OK, dbValue);
    }

    auto spTrampolineIndexerConnector = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spTrampolineIndexerConnector)};

    FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription> container;

    EXPECT_NO_THROW(spDatabaseFeedManager->getVulnerabiltyDescriptiveInformation(CVEID_TEST_OK, container));
    EXPECT_FLOAT_EQ(container.data->scoreBase(), 999.99);
    EXPECT_STREQ(container.data->classification()->c_str(), "classification_test_string");
    EXPECT_STREQ(container.data->description()->c_str(), "description_test_string");
    EXPECT_STREQ(container.data->severity()->c_str(), "severity_test_string");
    EXPECT_STREQ(container.data->scoreVersion()->c_str(), "scoreVersion_test_string");
    EXPECT_STREQ(container.data->reference()->c_str(), "reference_test_string");
}

TEST_F(DatabaseFeedManagerTest, getVulnerabiltyDescriptiveInformation_NotFound)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    flatbuffers::FlatBufferBuilder fbBuilder;
    auto vdOriginalData = NSVulnerabilityScanner::CreateVulnerabilityDescriptionDirect(fbBuilder,
                                                                                       999.99,
                                                                                       "classification_test_string",
                                                                                       "description_test_string",
                                                                                       "severity_test_string",
                                                                                       "scoreVersion_test_string",
                                                                                       "reference_test_string");
    fbBuilder.Finish(vdOriginalData);

    {
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(DESCRIPTION_DATABASE_PATH);
        rocksdb::Slice dbValue(reinterpret_cast<const char*>(fbBuilder.GetBufferPointer()), fbBuilder.GetSize());
        dbWrapper->put(CVEID_TEST_NOT_FOUND, dbValue);
    }

    auto spTrampolineIndexerConnector = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spTrampolineIndexerConnector)};

    FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription> container;

    EXPECT_THROW(spDatabaseFeedManager->getVulnerabiltyDescriptiveInformation("cveid_any", container),
                 std::runtime_error);
}

TEST_F(DatabaseFeedManagerTest, getVulnerabiltyDescriptiveInformation_Corrupted)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    {
        uint8_t corruptedData[] = {
            0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF};
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(DESCRIPTION_DATABASE_PATH);
        rocksdb::Slice dbValue(reinterpret_cast<const char*>(corruptedData), sizeof(corruptedData));
        dbWrapper->put(CVEID_TEST_CORRUPTED, dbValue);
    }

    auto spTrampolineIndexerConnector = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spTrampolineIndexerConnector)};

    FlatbufferDataPair<NSVulnerabilityScanner::VulnerabilityDescription> container;

    EXPECT_THROW(spDatabaseFeedManager->getVulnerabiltyDescriptiveInformation(CVEID_TEST_CORRUPTED, container),
                 std::runtime_error);
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityCandidatesSuccess)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    auto pDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(pIndexerConnectorTrap)};

    std::vector<std::vector<uint8_t>> vulnerabilities;

    pDatabaseFeedManager->getVulnerabilitiesCandidates(
        "cnaName",
        "libmagic-mgc",
        [&vulnerabilities](const char* data, const size_t size) -> bool
        {
            bool valid = false;
            uint8_t ret[size];
            std::memcpy(ret, data, size);
            flatbuffers::Verifier verifier(ret, size);
            if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier))
            {
                valid = true;
                vulnerabilities.emplace_back(std::move(std::vector<uint8_t>(ret, ret + size)));
            }

            return valid;
        });

    flatbuffers::Verifier verifier1(vulnerabilities[0].data(), vulnerabilities[0].size());
    if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier1))
    {
        const NSVulnerabilityScanner::ScanVulnerabilityCandidate* fb =
            NSVulnerabilityScanner::GetScanVulnerabilityCandidate(vulnerabilities[0].data());
        EXPECT_EQ(fb->cveId()->str(), "CVE-1999-1234");
    }

    flatbuffers::Verifier verifier2(vulnerabilities[1].data(), vulnerabilities[1].size());
    if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier2))
    {
        const NSVulnerabilityScanner::ScanVulnerabilityCandidate* fb =
            NSVulnerabilityScanner::GetScanVulnerabilityCandidate(vulnerabilities[1].data());
        EXPECT_EQ(fb->cveId()->str(), "CVE-1999-1235");
    }
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityCandidatesNoPackageName)
{
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();
    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    auto pIndexerConnectorTrap = std::make_shared<TrampolineIndexerConnector>();

    auto pDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(pIndexerConnectorTrap)};

    std::vector<std::vector<uint8_t>> vulnerabilities;

    EXPECT_ANY_THROW({
        pDatabaseFeedManager->getVulnerabilitiesCandidates(
            "cnaName",
            "",
            [&vulnerabilities](const char* data, const size_t size) -> bool
            {
                bool valid = false;
                uint8_t ret[size];
                std::memcpy(ret, data, size);
                flatbuffers::Verifier verifier(ret, size);
                if (NSVulnerabilityScanner::VerifyScanVulnerabilityCandidateBuffer(verifier))
                {
                    valid = true;
                    vulnerabilities.emplace_back(std::move(std::vector<uint8_t>(ret, ret + size)));
                }

                return valid;
            });
    });

    EXPECT_EQ(vulnerabilities.empty(), true);
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityRemediation_ValidData)
{
    // Test setup
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    std::shared_ptr<MockIndexerConnector> pIndexerConnectorMock;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    // Simulate saved data, store before variable instance.
    {
        std::string key_dummy {"CVE-2023-2609"};
        flatbuffers::FlatBufferBuilder builder;
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(REMEDIATIONS_DATABASE_PATH);

        std::vector<flatbuffers::Offset<flatbuffers::String>> updates_vec;
        updates_vec.push_back(builder.CreateString("KB2023"));
        auto updates = builder.CreateVector(updates_vec);
        auto dummy = CreateRemediationInfo(builder, updates);
        builder.Finish(dummy);

        rocksdb::Slice value(reinterpret_cast<const char*>(builder.GetBufferPointer()), builder.GetSize());
        dbWrapper->put(key_dummy, value);
    }

    auto spIndexerConnectorTramp = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spIndexerConnectorTramp)};

    // Variables setup
    std::string cveId {"CVE-2023-2609"};
    FlatbufferDataPair<RemediationInfo> dtoVulnRemediation;

    // Asserts
    ASSERT_NO_THROW(spDatabaseFeedManager->getVulnerabilityRemediation(cveId, dtoVulnRemediation));
    ASSERT_STREQ(dtoVulnRemediation.data->updates()->Get(0)->str().c_str(), "KB2023");
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityRemediation_DataNotFound)
{
    // Test setup
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    std::shared_ptr<MockIndexerConnector> pIndexerConnectorMock;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    auto spIndexerConnectorTramp = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spIndexerConnectorTramp)};

    // Variables setup
    std::string cveId {"CVE-2023-5678"};
    FlatbufferDataPair<RemediationInfo> dtoVulnRemediation;

    // Assert
    ASSERT_THROW(spDatabaseFeedManager->getVulnerabilityRemediation(cveId, dtoVulnRemediation), std::runtime_error);
}

TEST_F(DatabaseFeedManagerTest, GetVulnerabilityRemediation_InvalidData)
{
    // Test setup
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    std::shared_ptr<MockIndexerConnector> pIndexerConnectorMock;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    // Simulate corrupted data, store before variable instance.
    {
        uint8_t corruptedData[] = {
            0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF};
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(REMEDIATIONS_DATABASE_PATH);
        rocksdb::Slice dbValue(reinterpret_cast<const char*>(corruptedData), sizeof(corruptedData));
        dbWrapper->put("CVE-2023-2609", dbValue);
    }

    auto spIndexerConnectorTramp = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spIndexerConnectorTramp)};

    // Variables setup
    std::string cveId {"CVE-2023-2609"};
    FlatbufferDataPair<RemediationInfo> dtoVulnRemediation;

    // Assert
    ASSERT_THROW(spDatabaseFeedManager->getVulnerabilityRemediation(cveId, dtoVulnRemediation), std::runtime_error);
}

TEST_F(DatabaseFeedManagerTest, PackageTranslationCacheMiss)
{
    // Test setup
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    std::shared_ptr<MockIndexerConnector> pIndexerConnectorMock;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    // Simulate saved data, store before variable instance.
    {
        std::string idDummy {"WT_001"};
        flatbuffers::FlatBufferBuilder builder;
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(TRANSLATIONS_DATABASE_PATH);
        auto src = CreateTranslationInfoDirect(builder, "^The Apache Software", "^Apache Tomcat.*", "");
        auto tra = CreateTranslationInfoDirect(builder, "apache", "tomcat", "");
        std::vector<flatbuffers::Offset<TranslationInfo>> translations_vector;
        std::vector<int8_t> actions_vector;
        translations_vector.push_back(tra);
        actions_vector.push_back(Action_REP_PRODUCT);
        auto data = CreateTranslationEntryDirect(builder, &actions_vector, src, "windows", &translations_vector);
        builder.Finish(data);
        rocksdb::Slice value(reinterpret_cast<const char*>(builder.GetBufferPointer()), builder.GetSize());
        dbWrapper->put(idDummy, value);
    }

    auto spIndexerConnectorTramp = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spIndexerConnectorTramp)};

    // Variables setup
    std::string packageName {"Apache Tomcat.GenericVersion"};
    std::map<std::string, std::string> translations;

    spDatabaseFeedManager->getWazuhPackageTranslation(
        packageName,
        [&translations](const NSVulnerabilityScanner::TranslationEntry& translation)
        {
            for (auto index = 0u; index < translation.translation()->size(); index++)
            {
                for (auto indexAct = 0u; indexAct < translation.action()->size(); indexAct++)
                {
                    switch (translation.action()->Get(indexAct))
                    {
                        case Action_REP_PRODUCT:
                        {
                            translations.insert({translation.source()->product()->str(),
                                                 translation.translation()->Get(index)->product()->str()});
                            break;
                        }
                        case Action_REP_VENDOR:
                        {
                            translations.insert({translation.source()->vendor()->str(),
                                                 translation.translation()->Get(index)->vendor()->str()});
                            break;
                        }
                    }
                }
            }
        });
    // Assert
    EXPECT_EQ(translations.size(), 1);
    auto it = translations.begin();
    EXPECT_EQ(it->first, "^Apache Tomcat.*");
    EXPECT_EQ(it->second, "tomcat");
}

TEST_F(DatabaseFeedManagerTest, PackageTranslationCacheHit)
{
    // Test setup
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    std::shared_ptr<MockIndexerConnector> pIndexerConnectorMock;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    // Simulate saved data, store before variable instance.
    {
        std::string idDummy {"WT_001"};
        flatbuffers::FlatBufferBuilder builder;
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(TRANSLATIONS_DATABASE_PATH);
        auto src = CreateTranslationInfoDirect(builder, "^The Apache Software", "^Apache Tomcat.*", "");
        auto tra = CreateTranslationInfoDirect(builder, "apache", "tomcat", "");
        std::vector<flatbuffers::Offset<TranslationInfo>> translations_vector;
        std::vector<int8_t> actions_vector;
        translations_vector.push_back(tra);
        actions_vector.push_back(Action_REP_PRODUCT);
        auto data = CreateTranslationEntryDirect(builder, &actions_vector, src, "windows", &translations_vector);
        builder.Finish(data);
        rocksdb::Slice value(reinterpret_cast<const char*>(builder.GetBufferPointer()), builder.GetSize());
        dbWrapper->put(idDummy, value);
    }

    auto spIndexerConnectorTramp = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spIndexerConnectorTramp)};

    // Variables setup
    std::string packageName {"Apache Tomcat.GenericVersion"};
    std::map<std::string, std::string> translations;

    spDatabaseFeedManager->getWazuhPackageTranslation(
        packageName,
        [&translations](const NSVulnerabilityScanner::TranslationEntry& translation)
        {
            for (auto index = 0u; index < translation.translation()->size(); index++)
            {
                for (auto indexAct = 0u; indexAct < translation.action()->size(); indexAct++)
                {
                    switch (translation.action()->Get(indexAct))
                    {
                        case Action_REP_PRODUCT:
                        {
                            translations.insert({translation.source()->product()->str(),
                                                 translation.translation()->Get(index)->product()->str()});
                            break;
                        }
                        case Action_REP_VENDOR:
                        {
                            translations.insert({translation.source()->vendor()->str(),
                                                 translation.translation()->Get(index)->vendor()->str()});
                            break;
                        }
                    }
                }
            }
        });

    spDatabaseFeedManager->getWazuhPackageTranslation(
        packageName,
        [&translations](const NSVulnerabilityScanner::TranslationEntry& translation)
        {
            for (auto index = 0u; index < translation.translation()->size(); index++)
            {
                for (auto indexAct = 0u; indexAct < translation.action()->size(); indexAct++)
                {
                    switch (translation.action()->Get(indexAct))
                    {
                        case Action_REP_PRODUCT:
                        {
                            translations.insert({translation.source()->product()->str(),
                                                 translation.translation()->Get(index)->product()->str()});
                            break;
                        }
                        case Action_REP_VENDOR:
                        {
                            translations.insert({translation.source()->vendor()->str(),
                                                 translation.translation()->Get(index)->vendor()->str()});
                            break;
                        }
                    }
                }
            }
        });
    // Assert
    EXPECT_EQ(translations.size(), 1);
    auto it = translations.begin();
    EXPECT_EQ(it->first, "^Apache Tomcat.*");
    EXPECT_EQ(it->second, "tomcat");
}

TEST_F(DatabaseFeedManagerTest, PackageTranslationNoTranslationFound)
{
    // Test setup
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    std::shared_ptr<MockIndexerConnector> pIndexerConnectorMock;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    // Simulate saved data, store before variable instance.
    {
        std::string idDummy {"WT_001"};
        flatbuffers::FlatBufferBuilder builder;
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(TRANSLATIONS_DATABASE_PATH);
        auto src = CreateTranslationInfoDirect(builder, "^The Apache Software", "^Apache Tomcat.*", "");
        auto tra = CreateTranslationInfoDirect(builder, "apache", "tomcat", "");
        std::vector<flatbuffers::Offset<TranslationInfo>> translations_vector;
        std::vector<int8_t> actions_vector;
        translations_vector.push_back(tra);
        actions_vector.push_back(Action_REP_PRODUCT);
        auto data = CreateTranslationEntryDirect(builder, &actions_vector, src, "windows", &translations_vector);
        builder.Finish(data);
        rocksdb::Slice value(reinterpret_cast<const char*>(builder.GetBufferPointer()), builder.GetSize());
        dbWrapper->put(idDummy, value);
    }

    auto spIndexerConnectorTramp = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spIndexerConnectorTramp)};

    // Variables setup
    std::string packageName {"SQLite3"};
    std::map<std::string, std::string> translations;

    spDatabaseFeedManager->getWazuhPackageTranslation(
        packageName,
        [&translations](const NSVulnerabilityScanner::TranslationEntry& translation)
        {
            for (auto index = 0u; index < translation.translation()->size(); index++)
            {
                for (auto indexAct = 0u; indexAct < translation.action()->size(); indexAct++)
                {
                    switch (translation.action()->Get(indexAct))
                    {
                        case Action_REP_PRODUCT:
                        {
                            translations.insert({translation.source()->product()->str(),
                                                 translation.translation()->Get(index)->product()->str()});
                            break;
                        }
                        case Action_REP_VENDOR:
                        {
                            translations.insert({translation.source()->vendor()->str(),
                                                 translation.translation()->Get(index)->vendor()->str()});
                            break;
                        }
                    }
                }
            }
        });

    // Assert
    EXPECT_EQ(translations.size(), 0);
}

TEST_F(DatabaseFeedManagerTest, PackageTranslationInvalidDatabase)
{
    // Test setup
    const auto configurationParameters = R"( {"topicName": "topicNameTest"} )"_json;
    std::shared_ptr<MockIndexerConnector> pIndexerConnectorMock;

    spIndexerConnectorMock = std::make_shared<MockIndexerConnector>();

    spPolicyManagerMock = std::make_shared<MockPolicyManager>();
    EXPECT_CALL(*spPolicyManagerMock, getUpdaterConfiguration()).WillRepeatedly(Return(configurationParameters));

    spContentRegisterMock = std::make_shared<MockContentRegister>(
        configurationParameters.at("topicName").get<const std::string>(), configurationParameters);

    spRouterSubscriberMock = std::make_shared<MockRouterSubscriber>(
        configurationParameters.at("topicName").get<const std::string>(), "vulnerability_feed_manager");
    EXPECT_CALL(*spRouterSubscriberMock, subscribe(_));

    // Simulate corrupted data, store before variable instance.
    {
        uint8_t corruptedData[] = {
            0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF, 0x55, 0xCC, 0x00, 0xFF};
        auto dbWrapper = std::make_unique<Utils::RocksDBWrapper>(TRANSLATIONS_DATABASE_PATH);
        rocksdb::Slice dbValue(reinterpret_cast<const char*>(corruptedData), sizeof(corruptedData));
        dbWrapper->put("WT_001", dbValue);
    }

    auto spIndexerConnectorTramp = std::make_shared<TrampolineIndexerConnector>();

    auto spDatabaseFeedManager {
        std::make_shared<TDatabaseFeedManager<TrampolineIndexerConnector,
                                              TrampolinePolicyManager,
                                              TrampolineContentRegister,
                                              TrampolineRouterSubscriber>>(spIndexerConnectorTramp)};

    // Variables setup
    std::string packageName {"Apache Tomcat.GenericVersion"};

    EXPECT_THROW(spDatabaseFeedManager->getWazuhPackageTranslation(
                     packageName, [](const NSVulnerabilityScanner::TranslationEntry& translation) {}),
                 std::runtime_error);
}

TEST_F(DatabaseFeedManagerTest, PackageTranslationInvalidCache)
{
    // ToDo It's necessary the write function to store a value corrupted and run this test.
}

/* DatabaseFeedManagerMessageProcessor tests */

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestInvalidJson)
{
    std::string stdMessage = R"({invalid_json})";
    std::vector<char> message = std::vector<char>(stdMessage.begin(), stdMessage.end());

    auto testingLambda = [](const nlohmann::json& obj) {
    };

    try
    {
        DatabaseFeedManagerMessageProcessor::processMessage(message, testingLambda);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid message");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestNoPaths)
{
    std::string stdMessage = R"({"field":"value"})";
    std::vector<char> message = std::vector<char>(stdMessage.begin(), stdMessage.end());

    auto testingLambda = [](const nlohmann::json& obj) {
    };

    try
    {
        DatabaseFeedManagerMessageProcessor::processMessage(message, testingLambda);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid message");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestFileWithInvalidJson)
{
    std::string stdMessage = R"({"paths":["file1.json"]})";
    std::vector<char> message = std::vector<char>(stdMessage.begin(), stdMessage.end());

    auto testingLambda = [](const nlohmann::json& obj) {
    };

    try
    {
        DatabaseFeedManagerMessageProcessor::processMessage(message, testingLambda);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid file");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestFileWithNoData)
{
    std::string stdMessage = R"({"paths":["file2.json"]})";
    std::vector<char> message = std::vector<char>(stdMessage.begin(), stdMessage.end());

    auto testingLambda = [](const nlohmann::json& obj) {
    };

    try
    {
        DatabaseFeedManagerMessageProcessor::processMessage(message, testingLambda);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Invalid file");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestFileWithDataAndException)
{
    std::string stdMessage = R"({"paths":["file3.json"]})";
    std::vector<char> message = std::vector<char>(stdMessage.begin(), stdMessage.end());

    auto testingLambda = [](const nlohmann::json& obj)
    {
        throw std::runtime_error {"Error"};
    };

    try
    {
        DatabaseFeedManagerMessageProcessor::processMessage(message, testingLambda);
        FAIL() << "Expected std::runtime_error";
    }
    catch (const std::runtime_error& e)
    {
        EXPECT_STREQ(e.what(), "Error");
    }
    catch (...)
    {
        FAIL() << "Expected std::runtime_error";
    }
}

TEST_F(DatabaseFeedManagerMessageProcessorTest, TestFileWithDataSuccess)
{
    std::string stdMessage = R"({"paths":["file3.json"]})";
    std::vector<char> message = std::vector<char>(stdMessage.begin(), stdMessage.end());

    auto testingLambda = [](const nlohmann::json& obj) {
    };

    EXPECT_NO_THROW(DatabaseFeedManagerMessageProcessor::processMessage(message, testingLambda));
}
