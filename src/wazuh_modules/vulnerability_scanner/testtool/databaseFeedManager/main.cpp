/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * Oct 26, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "argsParser.hpp"
#include "databaseFeedManager.hpp"
#include "json.hpp"
#include "routerModule.hpp"
#include "routerProvider.hpp"
#include "singleton.hpp"
#include <filesystem>
#include <iostream>

/**
 * @brief Dummy class to replace real IndexerConnector.
 *
 */
class DummyIndexerConnector
{
public:
    /**
     * @brief No operation method.
     *
     * @param message
     */
    void publish(const std::string& message) {}
};

/**
 * @brief Dummy class to replace real PolicyManager.
 *
 */
class DummyPolicyManager : public Singleton<DummyPolicyManager>
{
public:
    /**
     * @brief This method sets the topic for the subscriber.
     *
     * @param topic The topic to subscribe to.
     */
    void setUpdaterConfiguration(const std::string& topic)
    {
        m_topic = topic;
    }

    /**
     * @brief This method sets the topic for the translations subscriber.
     *
     * @param topic The topic to subscribe to.
     */
    void setTranslationsUpdaterConfiguration(const std::string& topic)
    {
        m_translationsTopic = topic;
    }

    /**
     * @brief Retrieves the UpdaterConfiguration.
     *
     * @return nlohmann::json A simple JSON object with the configured topic.
     */
    nlohmann::json getUpdaterConfiguration()
    {
        return {{"topicName", m_topic}};
    }

    /**
     * @brief Retrieves the TranslationsUpdaterConfiguration.
     *
     * @return nlohmann::json A simple JSON object with the configured topic.
     */
    nlohmann::json getTranslationsUpdaterConfiguration()
    {
        return {{"topicName", m_translationsTopic}};
    }

private:
    std::string m_topic;
    std::string m_translationsTopic;
};

/**
 * @brief Dummy class to replace real ContentRegister.
 *
 */
class DummyContentRegister
{
public:
    /**
     * @brief Constructor of the dummy class
     *
     * @param obj1 Not used.
     * @param obj2 Not used.
     */
    DummyContentRegister(const nlohmann::json& obj1, const nlohmann::json& obj2) {}

    /**
     * @brief No operation method.
     *
     * @param interval Not used.
     */
    void changeSchedulerInterval(long unsigned int interval) {}
};

int main(const int argc, const char* argv[])
{
    try
    {
        // Reset required directories
        if (std::filesystem::exists("./queue/vd"))
        {
            std::remove("./queue/vd");
        }
        std::filesystem::create_directories("./queue/vd");

        CmdLineArgs cmdLineArgs(argc, argv);

        // Read json configuration file
        auto configuration = nlohmann::json::parse(std::ifstream(cmdLineArgs.getConfigurationFilePath()));

        RouterModule::instance().start();
        auto routerProvider = std::make_shared<RouterProvider>(configuration.at("topicName"));
        routerProvider->start();

        DummyPolicyManager::instance().setUpdaterConfiguration(configuration.at("topicName"));
        DummyPolicyManager::instance().setTranslationsUpdaterConfiguration(configuration.at("translationsTopicName"));

        auto databaseFeedManager =
            std::make_shared<TDatabaseFeedManager<DummyIndexerConnector, DummyPolicyManager, DummyContentRegister>>(
                std::make_shared<DummyIndexerConnector>(), false);

        auto baseLine = R"(
        {
            "paths":
            [
            ],
            "stageStatus":
            [
                {
                    "stage": "download",
                    "status": "ok"
                }
            ]
        }
        )"_json;

        for (const auto& path : cmdLineArgs.getInputFiles())
        {
            baseLine["paths"].push_back(path);
        }

        const auto payload = baseLine.dump();
        const auto message = std::vector<char>(payload.begin(), payload.end());

        routerProvider->send(message);
        if (cmdLineArgs.getWaitTime() > 0)
        {
            std::this_thread::sleep_for(std::chrono::seconds(cmdLineArgs.getWaitTime()));
        }
        else
        {
            std::cout << "Press enter to stop the tool..." << std::endl;
            std::cin.get();
        }
        databaseFeedManager.reset();
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << std::endl;
        CmdLineArgs::showHelp();
        return 1;
    }
    return 0;
}
