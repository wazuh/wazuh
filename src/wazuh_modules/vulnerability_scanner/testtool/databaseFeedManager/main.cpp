/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * Oct 26, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "argsParser.hpp"
#include "databaseFeedManager.hpp"
#include "eventDecoder.hpp"
#include "json.hpp"
#include "loggerHelper.h"
#include "singleton.hpp"
#include <filesystem>
#include <iostream>

auto constexpr DEFAULT_OFFSET{99999};

std::string g_message {};
auto g_shouldStop {std::make_shared<ConditionSync>(false)};

/**
 * @brief Dummy class to replace real IndexerConnector.
 *
 */
class DummyIndexerConnector
{
public:
    /**
     * @brief No operation method.
     *
     * @param message
     */
    void publish([[maybe_unused]] const std::string& message) {}
};

/**
 * @brief Dummy class to replace real PolicyManager.
 *
 */
class DummyPolicyManager : public Singleton<DummyPolicyManager>
{
public:
    /**
     * @brief This method sets the topic for the subscriber.
     *
     * @param topic The topic to subscribe to.
     */
    void setUpdaterConfiguration(const std::string& topic)
    {
        m_topic = topic;
    }

    /**
     * @brief Retrieves the UpdaterConfiguration.
     *
     * @return nlohmann::json A simple JSON object with the configured topic.
     */
    nlohmann::json getUpdaterConfiguration()
    {
        auto updaterConfiguration = nlohmann::json::object();
        updaterConfiguration["topicName"] = m_topic;
        return updaterConfiguration;
    }

    /**
     * @brief Get translation LRU size.
     *
     * @return uint32_t translation LRU size.
     */
    uint32_t getTranslationLRUSize() const
    {
        return 2048;
    }

    /**
     * @brief Get osdata LRU size.
     *
     * @return uint32_t osdata LRU size.
     */
    uint32_t getOsdataLRUSize() const
    {
        return 1000;
    }

    /**
     * @brief Get remediation LRU size.
     *
     * @return uint32_t remediation LRU size.
     */
    uint32_t getRemediationLRUSize() const
    {
        return 2048;
    }

private:
    std::string m_topic;
};

/**
 * @brief Dummy class to replace real ContentRegister.
 *
 */
class DummyContentRegister
{
public:
    /**
     * @brief Constructor of the dummy class
     *
     * @param obj1 Not used.
     * @param obj2 Not used.
     * @param fileProcessingCallback Callback function in charge of the file processing task.
     */
    DummyContentRegister([[maybe_unused]] std::string obj1,
                         [[maybe_unused]] const nlohmann::json& obj2,
                         FileProcessingCallback fileProcessingCallback)
    {

        fileProcessingCallback(g_message);
    }

    /**
     * @brief No operation method.
     *
     * @param interval Not used.
     */
    void changeSchedulerInterval([[maybe_unused]] long unsigned int interval) {}
};

void cveReplaceLogic(
    std::shared_ptr<TDatabaseFeedManager<DummyPolicyManager, DummyContentRegister>> databaseFeedManager,
    const CmdLineArgs& cmdLineArgs)
{
    auto storeModel = std::make_shared<StoreModel>();

    for (const auto& path : cmdLineArgs.getReplaceCVE())
    {
        std::ifstream fileStream(path);
        if (!fileStream.is_open())
        {
            throw std::runtime_error("Could not open file: " + path);
        }

        auto newCVE = nlohmann::json::parse(fileStream, nullptr, false);
        if (newCVE.is_discarded())
        {
            throw std::runtime_error("Invalid JSON in file: " + path);
        }

        const std::string cveId = newCVE.at("cveMetadata").at("cveId").get<std::string>();

        std::cout << "Replacing information for: " << cveId << "\n";

        // Prepare FlatBufferBuilder from parsed JSON
        flatbuffers::IDLOptions options;
        options.output_default_scalars_in_json = true;
        options.strict_json = true;

        flatbuffers::Parser parser(options);
        if (!parser.Parse(cve5_SCHEMA))
        {
            throw std::runtime_error("Failed to parse schema: " + parser.error_);
        }

        if (!parser.Parse(newCVE.dump().c_str()))
        {
            throw std::runtime_error("Failed to parse CVE JSON to FlatBuffer: " + parser.error_);
        }

        flatbuffers::FlatBufferBuilder& builder = parser.builder_;

        // Create EventContext for update
        auto feedDb = std::shared_ptr<Utils::RocksDBWrapper>(&databaseFeedManager->getCVEDatabase(),
                                                             [](Utils::RocksDBWrapper*) {});

        nlohmann::json resource;
        resource["type"] = "update";
        resource["offset"] = cmdLineArgs.getOffsetNumber() > 0 ? cmdLineArgs.getOffsetNumber() : DEFAULT_OFFSET;

        auto eventContext = std::make_shared<EventContext>(EventContext {.message = "",
                                                                         .resource = resource,
                                                                         .cve5Buffer = builder.Release(),
                                                                         .feedDatabase = feedDb,
                                                                         .resourceType = ResourceType::CVE});

        storeModel->handleRequest(eventContext);

        std::cout << "Process complete for: " << cveId << "\n";
    }
}

int main(const int argc, const char* argv[])
{
    try
    {

        // LOGLEVEL_INFO, tag, sourceFile.file, sourceFile.line, sourceFile.func, formattedStr
        Log::assignLogFunction(
            [](const int,
               const std::string& tag,
               const std::string& file,
               const int line,
               const std::string&,
               const std::string& str,
               va_list args)
            {
                char formattedStr[MAXLEN] = {0};
                vsnprintf(formattedStr, MAXLEN, str.c_str(), args);
                std::cout << tag << "->" << file << ":" << line << " " << formattedStr << std::endl;
            });
        // Reset required directories
        if (std::filesystem::exists("./queue/vd"))
        {
            if (std::remove("./queue/vd") != 0)
            {
                std::cerr << "Error deleting directory ./queue/vd" << std::endl;
            }
        }
        std::filesystem::create_directories("./queue/vd");

        CmdLineArgs cmdLineArgs(argc, argv);

        // Read json configuration file
        auto configuration = nlohmann::json::parse(std::ifstream(cmdLineArgs.getConfigurationFilePath()));

        DummyPolicyManager::instance().setUpdaterConfiguration(configuration.at("topicName"));
        std::shared_mutex mutex;

        auto baseLine = R"(
        {
            "paths":
            [
            ],
            "offset": 0,
            "stageStatus":
            [
                {
                    "stage": "download",
                    "status": "ok"
                }
            ]
        }
        )"_json;

        baseLine["type"] = cmdLineArgs.getFormatInputFiles();
        for (const auto& path : cmdLineArgs.getInputFiles())
        {
            baseLine["paths"].push_back(path);
        }

        g_message = baseLine.dump();

        std::shared_ptr<TDatabaseFeedManager<DummyPolicyManager, DummyContentRegister>> databaseFeedManager;

        if (!(cmdLineArgs.getReplaceCVE().empty() && cmdLineArgs.getFlatbufferPath().empty()))
        {
            databaseFeedManager =
                std::make_shared<TDatabaseFeedManager<DummyPolicyManager, DummyContentRegister>>(mutex, true, false);
            cveReplaceLogic(databaseFeedManager, cmdLineArgs);
        }
        else
        {
            databaseFeedManager =
                std::make_shared<TDatabaseFeedManager<DummyPolicyManager, DummyContentRegister>>(mutex, true, true);
        }

        if (cmdLineArgs.getWaitTime() > 0)
        {
            std::this_thread::sleep_for(std::chrono::seconds(cmdLineArgs.getWaitTime()));
        }
        else
        {
            std::cout << "Press enter to stop the tool..." << std::endl;
            std::cin.get();
        }
        databaseFeedManager.reset();
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << std::endl;
        CmdLineArgs::showHelp();
        return 1;
    }
    return 0;
}
