/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "vulnerabilityScannerFacade.hpp"
#include "../../inventory_sync/src/inventorySyncFacade.hpp"
#include "archiveHelper.hpp"
#include "defs.h"
#include "indexerConnector.hpp"
#include "loggerHelper.h"
#include "scanOrchestrator.hpp"
#include "scanOrchestrator/agentReScanListException.hpp"
#include "scanOrchestrator/buildAllAgentListContext.hpp"
#include "scanOrchestrator/scanAgentList.hpp"
#include "socketDBWrapper.hpp"
#include "stringHelper.h"
#include "xzHelper.hpp"
#include <atomic>
#include <mutex>
#include <string>

constexpr auto COMPRESSED_DB_PATH {"tmp/vd_1.0.0_vd_4.13.0.tar.xz"};
constexpr auto DECOMPRESSED_DB_PATH {"tmp/vd_1.0.0_vd_4.13.0.tar"};
constexpr auto VD_STATE_QUEUE_PATH = "queue/vd/state_track";
constexpr auto VD_KEYSTORE_PATH = "queue/keystore";
constexpr auto VD_DATABASE_PATH {"queue/vd"};
constexpr auto VD_DATABASE_VERSION_KEY {"installed_content"};
constexpr auto STATES_VD_INDEX_NAME_PREFIX {"wazuh-states-vulnerabilities"};

extern "C" bool vdTesttoolSkipPostUpdateScan() __attribute__((weak));

namespace
{
    bool shouldSkipPostUpdateScan()
    {
        return vdTesttoolSkipPostUpdateScan && vdTesttoolSkipPostUpdateScan();
    }
} // namespace

bool VulnerabilityScannerFacade::decompressDatabase(std::string_view databaseVersion) const
{
    bool ret = false;

    // Check database version. It will attempt to decompress the database
    // if the version does not match or the state_track does not have information
    if ((databaseVersion.compare(__ossec_version) != 0 || databaseVersion.empty()) && std::filesystem::exists(TMP_DIR))
    {
        // Check for XZ compressed file.
        if (!std::filesystem::exists(COMPRESSED_DB_PATH))
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "No database compressed file found at '%s'. Skipping decompression.",
                      COMPRESSED_DB_PATH);
            return ret;
        }

        logDebug2(WM_VULNSCAN_LOGTAG, "Starting database file decompression.");
        logDebug2(WM_VULNSCAN_LOGTAG, "Starting XZ file decompression.");

        // Clean up possible trash files.
        std::filesystem::remove_all(DECOMPRESSED_DB_PATH);

        // Decompress XF file format.
        Utils::XzHelper(std::filesystem::path(COMPRESSED_DB_PATH), std::filesystem::path(DECOMPRESSED_DB_PATH))
            .decompress();

        // Clean up feed databases.
        std::filesystem::remove_all(DATABASE_PATH);
        std::filesystem::remove_all(UPDATER_PATH);

        // Extract queue/vd and queue/vd_updater
        std::vector<std::string> extractOnly;
        extractOnly.emplace_back(VD_DATABASE_PATH);

        // Decompress also keystore if missing.
        if (!std::filesystem::exists(VD_KEYSTORE_PATH))
        {
            extractOnly.emplace_back(VD_KEYSTORE_PATH);
        }

        logDebug2(WM_VULNSCAN_LOGTAG, "Starting TAR file decompression.");

        // Decompress TAR file format.
        Utils::ArchiveHelper::decompress(DECOMPRESSED_DB_PATH, m_shouldStop, "", extractOnly);

        // Clean up.
        std::filesystem::remove_all(DECOMPRESSED_DB_PATH);

        if (!m_shouldStop.load())
        {
            ret = true;
            logDebug2(WM_VULNSCAN_LOGTAG, "Database decompression finished.");
        }
    }

    return ret;
}

void VulnerabilityScannerFacade::runScanner(Utils::RocksDBWrapper& dataStore, const Context& inventorySyncContext) const
{
    // Delegate to orchestrator
    m_scanOrchestrator->runScan(dataStore, inventorySyncContext);
}

void VulnerabilityScannerFacade::runScanAfterFeedUpdate()
{
    if (!m_scanOrchestrator || !m_indexerConnector)
    {
        logWarn(WM_VULNSCAN_LOGTAG, "Feed update scan skipped: scanner not initialized.");
        return;
    }

    logInfo(WM_VULNSCAN_LOGTAG, "Vulnerability scan started after feed update: full scan for all agents.");

    std::unique_lock<std::shared_mutex> scanLock(m_internalMutex, std::defer_lock);
    if (!scanLock.try_lock())
    {
        logDebug2(WM_VULNSCAN_LOGTAG, "Feed update scan waiting for VD lock.");
        scanLock.lock();
    }
    logDebug2(WM_VULNSCAN_LOGTAG, "VD lock acquired by FeedUpdate thread");

    auto scanContext = std::make_shared<ScanContext>();

    auto buildAllAgents = std::make_shared<BuildAllAgentListContext>();
    auto scanAgents =
        std::make_shared<ScanAgentList>(m_indexerConnector,
                                        [this](std::shared_ptr<ScanContext> agentContext)
                                        {
                                            auto context = std::move(agentContext);
                                            m_scanOrchestrator->runScanAfterFeedUpdate(std::move(context), false);
                                        });

    buildAllAgents->setLast(scanAgents);

    bool scanCompleted = true;
    try
    {
        buildAllAgents->handleRequest(scanContext);
    }
    catch (const AgentReScanListException& e)
    {
        logError(WM_VULNSCAN_LOGTAG,
                 "Feed update vulnerability scan completed with %zu failed agents.",
                 e.agentList().size());
        scanCompleted = false;
    }
    catch (const std::exception& e)
    {
        logError(WM_VULNSCAN_LOGTAG, "Feed update scan failed: %s.", e.what());
        scanCompleted = false;
    }

    logDebug2(WM_VULNSCAN_LOGTAG, "Releasing VD lock, full scan completed");
    logInfo(WM_VULNSCAN_LOGTAG,
            "Vulnerability scan finished after feed update: full scan for all agents (agents=%zu, status=%s).",
            scanContext ? scanContext->m_agents.size() : 0u,
            scanCompleted ? "ok" : "error");
}

// LCOV_EXCL_START
void VulnerabilityScannerFacade::start(
    const std::function<void(const int, const char*, const char*, const int, const char*, const char*, va_list)>&
        logFunction,
    const nlohmann::json& configuration,
    const bool noWaitToStop,
    const bool reloadGlobalMapsStartup,
    const bool initContentUpdater)
{
    try
    {
        m_noWaitToStop = noWaitToStop;

        // Initialize logging
        Log::assignLogFunction(logFunction);

        // Create a unique pointer to a RocksDBWrapper instance for managing state information.
        auto stateDB = std::make_unique<Utils::RocksDBWrapper>(VD_STATE_QUEUE_PATH);

        // Initialize socket wrapper for global Wazuh-DB queries.
        SocketDBWrapper::instance().init();

        const auto vdEnabled = [&configuration]()
        {
            if (!configuration.contains("vulnerability-detection"))
            {
                return true;
            }

            const auto& vdConfig = configuration.at("vulnerability-detection");
            if (!vdConfig.contains("enabled"))
            {
                return true;
            }

            if (vdConfig.at("enabled").is_boolean())
            {
                return vdConfig.at("enabled").get<bool>();
            }

            if (vdConfig.at("enabled").is_string())
            {
                return Utils::parseStrToBool(vdConfig.at("enabled").get<std::string>());
            }

            return true;
        }();

        if (!vdEnabled)
        {
            logInfo(WM_VULNSCAN_LOGTAG, "Vulnerability scanner module is disabled.");
            return;
        }

        if (configuration.contains("clusterName") && configuration.at("clusterName").is_string())
        {
            ScanContext::setClusterInfo(configuration.at("clusterName").get<std::string>(),
                                        configuration.value("clusterNodeName", std::string {}));
        }
        else if (configuration.contains("clusterNodeName") && configuration.at("clusterNodeName").is_string())
        {
            ScanContext::setClusterInfo(std::string {}, configuration.at("clusterNodeName").get<std::string>());
        }

        if (configuration.contains("clusterIsWorker") && configuration.at("clusterIsWorker").is_boolean())
        {
            ScanContext::setClusterRole(configuration.at("clusterIsWorker").get<bool>());
        }

        const auto buildIndexerConfig = [&configuration]()
        {
            nlohmann::json indexerConfig = nlohmann::json::object();
            if (configuration.contains("indexer") && configuration.at("indexer").is_object())
            {
                indexerConfig = configuration.at("indexer");
            }

            if (!indexerConfig.contains("hosts"))
            {
                indexerConfig["hosts"] = nlohmann::json::array();
                indexerConfig["hosts"].push_back("http://localhost:9200");
            }

            if (!indexerConfig.contains("username"))
            {
                indexerConfig["username"] = "";
            }

            if (!indexerConfig.contains("password"))
            {
                indexerConfig["password"] = "";
            }

            if (!indexerConfig.contains("ssl"))
            {
                indexerConfig["ssl"] = nlohmann::json::object();
                indexerConfig["ssl"]["certificate_authorities"] = nlohmann::json::array();
                indexerConfig["ssl"]["certificate"] = "";
                indexerConfig["ssl"]["key"] = "";
            }
            else
            {
                if (!indexerConfig.at("ssl").contains("certificate_authorities"))
                {
                    indexerConfig["ssl"]["certificate_authorities"] = nlohmann::json::array();
                }
                if (!indexerConfig.at("ssl").contains("certificate"))
                {
                    indexerConfig["ssl"]["certificate"] = "";
                }
                if (!indexerConfig.at("ssl").contains("key"))
                {
                    indexerConfig["ssl"]["key"] = "";
                }
            }

            indexerConfig["name"] = Utils::toLowerCase(STATES_VD_INDEX_NAME_PREFIX);
            return indexerConfig;
        };

        const auto buildUpdaterConfig = [&configuration]()
        {
            nlohmann::json updaterConfig = nlohmann::json::object();
            if (configuration.contains("updater") && configuration.at("updater").is_object())
            {
                updaterConfig = configuration.at("updater");
            }

            if (!updaterConfig.contains("topicName"))
            {
                updaterConfig["topicName"] = "vulnerability_feed_manager";
            }

            const auto& vdConfig = configuration.contains("vulnerability-detection") &&
                                           configuration.at("vulnerability-detection").is_object()
                                       ? configuration.at("vulnerability-detection")
                                       : nlohmann::json::object();

            auto intervalValue = vdConfig.contains("feed-update-interval")
                                     ? vdConfig.at("feed-update-interval").get<std::string>()
                                     : std::string {"60m"};
            auto intervalSeconds = Utils::parseStrToTime(intervalValue);
            if (intervalSeconds == -1)
            {
                throw std::runtime_error("Invalid feed update interval.");
            }

            if (!updaterConfig.contains("interval"))
            {
                updaterConfig["interval"] = intervalSeconds;
            }

            if (!updaterConfig.contains("ondemand"))
            {
                updaterConfig["ondemand"] = true;
            }

            if (!updaterConfig.contains("configData") || !updaterConfig.at("configData").is_object())
            {
                updaterConfig["configData"] = nlohmann::json::object();
            }

            auto& configData = updaterConfig["configData"];
            if (!configData.contains("consumerName"))
            {
                configData["consumerName"] = "Wazuh VulnerabilityDetector";
            }

            if (!configData.contains("deleteDownloadedContent"))
            {
                configData["deleteDownloadedContent"] = true;
            }

            if (!configData.contains("outputFolder"))
            {
                configData["outputFolder"] = std::string(UPDATER_PATH) + "/tmp";
            }

            if (!configData.contains("databasePath"))
            {
                configData["databasePath"] = std::string(UPDATER_PATH) + "/rocksdb";
            }

            if (!configData.contains("offset"))
            {
                configData["offset"] = 0;
            }

            if (vdConfig.contains("offline-url"))
            {
                const auto offlineUrl = vdConfig.at("offline-url").get<std::string>();
                if (!(Utils::startsWith(offlineUrl, "file") || Utils::startsWith(offlineUrl, "http") ||
                      Utils::startsWith(offlineUrl, "https")))
                {
                    throw std::runtime_error("Invalid URL provided.");
                }

                if (!configData.contains("contentSource"))
                {
                    configData["contentSource"] = "offline";
                }

                if (!configData.contains("compressionType"))
                {
                    configData["compressionType"] = "raw";
                }

                if (!configData.contains("versionedContent"))
                {
                    configData["versionedContent"] = "offline";
                }

                if (!configData.contains("url"))
                {
                    configData["url"] = offlineUrl;
                }
            }
            else
            {
                if (!vdConfig.contains("cti-url") && !configData.contains("url"))
                {
                    throw std::runtime_error("Missing cti-url configuration.");
                }

                if (!configData.contains("contentSource"))
                {
                    configData["contentSource"] = "cti-offset";
                }

                if (!configData.contains("compressionType"))
                {
                    configData["compressionType"] = "raw";
                }

                if (!configData.contains("versionedContent"))
                {
                    configData["versionedContent"] = "cti-api";
                }

                if (!configData.contains("contentFileName"))
                {
                    configData["contentFileName"] = "api_file.json";
                }

                if (!configData.contains("url"))
                {
                    configData["url"] = vdConfig.at("cti-url");
                }
            }

            return updaterConfig;
        };

        m_indexerConnector = std::make_shared<IndexerConnectorSync>(buildIndexerConfig(), logFunction);

        // Query the current database version.
        std::string databaseVersion;
        if (stateDB->get(VD_DATABASE_VERSION_KEY, databaseVersion))
        {
            logDebug1(WM_VULNSCAN_LOGTAG, "Database version: %s", databaseVersion.c_str());
        }

        // Decompress database content.
        bool decompressed = decompressDatabase(databaseVersion);

        // If a stop signal is received during or immediately after decompression, abort startup.
        if (m_shouldStop.load())
        {
            logDebug1(
                WM_VULNSCAN_LOGTAG,
                "Vulnerability scanner startup aborted as stop signal was received during database decompression.");
            return;
        }

        if (decompressed)
        {
            stateDB->put(VD_DATABASE_VERSION_KEY, __ossec_version);

            // Cleanup
            std::filesystem::remove_all(COMPRESSED_DB_PATH);

            logDebug1(WM_VULNSCAN_LOGTAG, "Updated %s key of %s.", VD_DATABASE_VERSION_KEY, VD_STATE_QUEUE_PATH);
        }

        uint32_t translationLruSize = DEFAULT_TRANSLATION_LRU_SIZE;
        if (configuration.contains("translationLRUSize") && configuration.at("translationLRUSize").is_number())
        {
            translationLruSize = configuration.at("translationLRUSize").get<uint32_t>();
        }

        const auto updaterConfig = buildUpdaterConfig();

        // Database feed manager initialization.
        m_databaseFeedManager = std::make_shared<DatabaseFeedManager>(
            m_internalMutex,
            updaterConfig,
            translationLruSize,
            reloadGlobalMapsStartup,
            initContentUpdater,
            [this]()
            {
                // Re-scan all agents after content update, only if this instance handles vulnerability scanning.
                if (shouldSkipPostUpdateScan())
                {
                    logDebug1(WM_VULNSCAN_LOGTAG, "Feed update scan skipped: testtool override enabled.");
                    return;
                }

                const bool lockAcquired =
                    InventorySyncFacade::instance().lockAgent("", "Feed update full scan in progress");

                struct AgentUnlockGuard
                {
                    bool locked {false};
                    ~AgentUnlockGuard()
                    {
                        if (locked)
                        {
                            InventorySyncFacade::instance().unlockAgent("");
                        }
                    }
                } unlockGuard {lockAcquired};

                if (!lockAcquired)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG, "Feed update scan proceeding with existing agent lock.");
                }

                runScanAfterFeedUpdate();
            });

        m_scanOrchestrator =
            std::make_shared<ScanOrchestrator>(m_indexerConnector, m_databaseFeedManager, m_internalMutex);

        logDebug2(WM_VULNSCAN_LOGTAG, "Vulnerability scanner module started.");
        m_initialized.store(true, std::memory_order_relaxed);
    }
    catch (const std::exception& e)
    {
        logError(WM_VULNSCAN_LOGTAG, "VulnerabilityScannerFacade::start: %s.", e.what());
    }
    catch (...)
    {
        logError(WM_VULNSCAN_LOGTAG, "VulnerabilityScannerFacade::start: Unknown exception.");
    }
}
// LCOV_EXCL_STOP

void VulnerabilityScannerFacade::stop()
{
    // Atomic flag section
    if (m_noWaitToStop)
    {
        m_shouldStop.store(true);
    }

    // Reset shared pointers
    m_indexerConnector.reset();
    m_databaseFeedManager->teardown();
    m_databaseFeedManager.reset();

    m_scanOrchestrator.reset();

    // Destroy socketDbWrapper
    SocketDBWrapper::instance().teardown();
}
