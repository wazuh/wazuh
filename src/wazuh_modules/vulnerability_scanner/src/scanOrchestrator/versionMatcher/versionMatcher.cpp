/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * December 7, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "versionMatcher.hpp"
#include "loggerHelper.h"
#include "versionObjectCalVer.hpp"
#include "versionObjectMajorMinor.hpp"
#include "versionObjectPEP440.hpp"
#include "versionObjectSemVer.hpp"
#include "vulnerabilityScannerDefs.hpp"
#include <memory>

namespace Log
{
    inline std::function<void(
        const int, const std::string&, const std::string&, const int, const std::string&, const std::string&)>
        GLOBAL_LOG_FUNCTION;
};

namespace VersionMatcher
{
    /**
     * @brief Creates a version object using the string and type specified.
     *
     * @param version string version item to create object from
     * @param type version object type to create from enum VersionObjectType
     * @return std::shared_ptr<IVersionObject>
     */
    std::shared_ptr<IVersionObject> createVersionObject(const std::string& version, VersionObjectType type)
    {
        CalVer calVer {};
        PEP440 pep440 {};
        MajorMinor majorMinor {};
        SemVer semVer {};
        switch (type)
        {
            default: logDebug2(WM_VULNSCAN_LOGTAG, "Error creating VersionObject. Invalid type"); return nullptr;
            case VersionObjectType::Unspecified:
                if (VersionObjectCalVer::match(version, calVer))
                {
                    return std::make_shared<VersionObjectCalVer>(calVer);
                }
                else if (VersionObjectPEP440::match(version, pep440))
                {
                    return std::make_shared<VersionObjectPEP440>(pep440);
                }
                else if (VersionObjectMajorMinor::match(version, majorMinor))
                {
                    return std::make_shared<VersionObjectMajorMinor>(majorMinor);
                }
                else if (VersionObjectSemVer::match(version, semVer))
                {
                    return std::make_shared<VersionObjectSemVer>(semVer);
                }
                else
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Error creating VersionObject (Unspecified). Unrecognized type. "
                              "Version string: %s",
                              version.c_str());
                    return nullptr;
                }
                break;

            case VersionObjectType::CalVer:
                if (VersionObjectCalVer::match(version, calVer))
                {
                    return std::make_shared<VersionObjectCalVer>(calVer);
                }
                else
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Error creating VersionObject (CalVer). Version string dont match the "
                              "type specified. Version string: %s",
                              version.c_str());
                    return nullptr;
                }
                break;

            case VersionObjectType::PEP440:
                if (VersionObjectPEP440::match(version, pep440))
                {
                    return std::make_shared<VersionObjectPEP440>(pep440);
                }
                else
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Error creating VersionObject (PEP440). Version string dont match the "
                              "type specified. Version string: %s",
                              version.c_str());
                    return nullptr;
                }
                break;
            case VersionObjectType::MajorMinor:
                if (VersionObjectMajorMinor::match(version, majorMinor))
                {
                    return std::make_shared<VersionObjectMajorMinor>(majorMinor);
                }
                else
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Error creating VersionObject (MajorMinor). Version string dont match "
                              "the type specified. Version string: %s",
                              version.c_str());
                    return nullptr;
                }
                break;

            case VersionObjectType::SemVer:
                if (VersionObjectSemVer::match(version, semVer))
                {
                    return std::make_shared<VersionObjectSemVer>(semVer);
                }
                else
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Error creating VersionObject (SemVer). Version string dont match the "
                              "type specified. Version string: %s",
                              version.c_str());
                    return nullptr;
                }
                break;
        }
    }

    int compare(const std::string& versionA, const std::string& versionB, VersionObjectType type)
    {
        auto pVersionObjectA = createVersionObject(versionA, type);
        auto pVersionObjectB = createVersionObject(versionB, type);

        if (!pVersionObjectA || !pVersionObjectB)
        {
            return INVALID_VERSION_OBJECT_TYPE;
        }

        if (pVersionObjectA->getType() == pVersionObjectB->getType())
        {

            if (*pVersionObjectA == *pVersionObjectB)
            {
                return 0;
            }
            else if (*pVersionObjectA < *pVersionObjectB)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }
        return INVALID_VERSION_OBJECT_TYPE;
    }
} // namespace VersionMatcher