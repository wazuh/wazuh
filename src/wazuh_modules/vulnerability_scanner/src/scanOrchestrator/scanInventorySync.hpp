/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 4, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_INVENTORY_SYNC_HPP
#define _SCAN_INVENTORY_SYNC_HPP

#include "chainOfResponsability.hpp"
#include "inventorySync.hpp"
#include "scanContext.hpp"

/**
 * @brief TScanInventorySync class.
 * This class is in charge of synchronizing the inventory database.
 * It receives the scan context and the inventory database and returns the scan context with the inventory updated.
 * Note: The sub-orchestration can be never be a nullptr, adding a check inside of the handleRequest method downgrad
 e the performance
 * of the orchestration.
 *
 * @tparam TScanContext scan context type.
 */
template<typename TScanContext = ScanContext,
         typename TAbstractHandler = AbstractHandler<std::shared_ptr<TScanContext>>>
class TScanInventorySync final
    : public AbstractHandler<std::shared_ptr<TScanContext>>
    , public TInventorySync<TScanContext>
{
    using TInventorySync<TScanContext>::m_inventoryDatabase;

private:
    std::shared_ptr<TAbstractHandler> m_subOrchestration;

public:
    // LCOV_EXCL_START
    /**
     * @brief ScanInventorySync constructor.
     *
     * @param inventoryDatabase Inventory database.
     * @param subOrchestration Sub orchestration to handle indexer operations.
     */
    explicit TScanInventorySync(Utils::RocksDBWrapper& inventoryDatabase,
                                std::shared_ptr<TAbstractHandler> subOrchestration)
        : TInventorySync<TScanContext>(inventoryDatabase)
        , m_subOrchestration(std::move(subOrchestration))
    {
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        const auto agentId = std::string(data->agentId());
        std::string key =
            agentId.compare("000") == 0 && data->clusterStatus() ? std::string(data->clusterNodeName()) + "_" : "";
        key.append(agentId);
        TInventorySync<TScanContext>::appendAffectedComponentKey(data, key);

        const auto& column = AFFECTED_COMPONENT_COLUMNS.at(
            data->affectedComponentType()); // Get the column name based on the affected component type.

        // For OS scan, the key is "agentID_OSNAME_OSVERSION". Using this approach, we can handle
        // the case where the OS is upgraded and the scan result is different from the previous one.
        std::string rawInventory;
        for (const auto& [databaseKey, value] : m_inventoryDatabase.seek(agentId, column))
        {
            if (databaseKey.compare(key) != 0)
            {
                logDebug2(WM_VULNSCAN_LOGTAG, "Deleting agent element key: %s", databaseKey.c_str());
                const auto inventory = Utils::splitView(value.ToStringView(), ',');
                for (const auto& cve : inventory)
                {
                    // Call sub orchestrator to delete the element from the indexer instance.
                    auto context = std::make_shared<TScanContext>();
                    context->m_noIndex = data->m_noIndex;
                    std::string keyContext;
                    keyContext.append(databaseKey);
                    keyContext.append("_");
                    keyContext.append(cve);
                    context->m_elements.emplace(cve, TInventorySync<TScanContext>::buildElement("DELETED", keyContext));
                    m_subOrchestration->handleRequest(std::move(context));
                }
                // Delete the key from the inventory database.
                m_inventoryDatabase.delete_(databaseKey, AFFECTED_COMPONENT_COLUMNS.at(data->affectedComponentType()));
            }
            else
            {
                rawInventory = value.ToString();
            }
        }
        bool isInventoryEmpty = rawInventory.empty();
        std::vector<std::string> inventory;
        std::vector<std::string> inventoryBase;

        if (!isInventoryEmpty)
        {
            inventory = Utils::split(rawInventory, ',');
            inventoryBase = inventory;
        }

        // Elements are the cves of the scan result.
        for (auto& [cve, value] : data->m_elements)
        {
            // If the cve is not in the inventory, insert it.
            if (std::find(inventory.begin(), inventory.end(), cve) == inventory.end())
            {
                std::string elementKey;
                elementKey.append(key);
                elementKey.append("_");
                elementKey.append(cve);

                data->m_elements[cve] = TInventorySync<TScanContext>::buildElement("INSERTED", elementKey);
                inventory.push_back(cve);
            }
        }

        // Remove elements from the inventory that are not in the scan result.
        inventory.erase(
            std::remove_if(inventory.begin(),
                           inventory.end(),
                           [&data, &key](const std::string& cve)
                           {
                               if (data->m_elements.find(cve) == data->m_elements.end())
                               {
                                   std::string elementKey;
                                   elementKey.append(key);
                                   elementKey.append("_");
                                   elementKey.append(cve);

                                   data->m_elements.emplace(
                                       cve, TInventorySync<TScanContext>::buildElement("DELETED", elementKey));
                                   logDebug2(
                                       WM_VULNSCAN_LOGTAG, "Removing element from inventory: %s", elementKey.c_str());
                                   return true; // Return true to remove this element from inventory
                               }
                               return false; // Otherwise, keep this element in inventory
                           }),
            inventory.end());

        // If the new scan have the element in the inventory, delete it from m_elements.
        auto it = data->m_elements.begin();
        while (it != data->m_elements.end())
        {
            // If the element is in the inventory after deleting the elements that are not in the scan result,
            // delete it from m_elements.
            if (std::find(inventoryBase.begin(), inventoryBase.end(), it->first) != inventoryBase.end())
            {
                if (std::find(inventory.begin(), inventory.end(), it->first) != inventory.end())
                {
                    it = data->m_elements.erase(it);
                }
                else
                {
                    ++it;
                }
            }
            else
            {
                ++it;
            }
        }

        // Check if the agent is doing its first scan.
        if (!m_inventoryDatabase.get(agentId, rawInventory, OS_INITIAL_SCAN))
        {
            // Save the initial UTC time for the initial scan of the agent.
            m_inventoryDatabase.put(agentId, Utils::getCurrentISO8601(), OS_INITIAL_SCAN);
        }
        else
        {
            data->m_isFirstScan = false;
        }

        if (inventory.empty())
        {
            // If the inventory previously had elements and now is empty, delete the inventory.
            if (!isInventoryEmpty)
            {
                logDebug2(WM_VULNSCAN_LOGTAG, "Deleting agent element key: %s", key.c_str());
                m_inventoryDatabase.delete_(key, column);
            }
        }
        else
        {
            std::sort(inventory.begin(), inventory.end());
            std::sort(inventoryBase.begin(), inventoryBase.end());

            // If the inventory has changed, update it.
            if (!std::equal(inventory.begin(), inventory.end(), inventoryBase.begin(), inventoryBase.end()))
            {
                std::string insertListString;
                for (const auto& cve : inventory)
                {
                    insertListString.append(cve);
                    insertListString.append(",");
                }
                insertListString.pop_back();
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Updating/Inserting agent element key: %s -> %s",
                          key.c_str(),
                          insertListString.c_str());
                m_inventoryDatabase.put(key, insertListString, column);
            }
            else
            {
                logDebug2(WM_VULNSCAN_LOGTAG, "No changes in agent element key: %s", key.c_str());
                return nullptr;
            }
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using ScanInventorySync = TScanInventorySync<>;

#endif // _SCAN_INVENTORY_SYNC_HPP
