/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_CONTEXT_HPP
#define _SCAN_CONTEXT_HPP

#include "../../inventory_sync/src/context.hpp"
#include "globalData.hpp"
#include "logging_helper.h"
#include "osDataCache.hpp"
#include "remediationDataCache.hpp"
#include <cstdint>
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include <vector>

constexpr std::string_view OS_INDEX = "wazuh-states-inventory-system";
constexpr std::string_view HOTFIX_INDEX = "wazuh-states-inventory-hotfixes";
constexpr auto PKG_CAPACITY = 1000;

/**
 * @brief Vulnerability source.
 *
 */
enum VulnerabilitySource : uint8_t
{
    ADP_BASE = 0,
    ADP_EXPANDED = 1
};

/**
 * @brief Scanner type.
 */
enum class ScannerType
{
    Unknown = 0,
    PackageDelta= 1,
    Os = 2,
    FirstFullScan = 3,
    FullScan = 4,
    FullScanAfterFeedUpdate = 5,
    CleanupAgentData = 6
};

/**
 * @brief The affected component type is used to determine what type of data is affected in the system.
 */
enum class AffectedComponentType : uint8_t
{
    Unknown = 0,
    Package = 1,
    Os = 2,
    Hotfix = 3,
    Agent = 4,
};

// ToDo: Refactor once defined the new data structures for package information
enum class ScannerType : uint8_t
{
    Unknown = 0,
    PackageInsert = 1
};

/**
 * @brief Match rule condition.
 */
enum class MatchRuleCondition : uint8_t
{
    Unknown = 0,
    Equal = 1,
    NotEqual = 2,
    GreaterThan = 3,
    GreaterThanOrEqual = 4,
    LessThan = 5,
    LessThanOrEqual = 6,
    Contains = 7,
    NotContains = 8,
    StartsWith = 9,
    EndsWith = 10,
    DefaultStatus = 11,
};

/**
 * @brief Element operation.
 */
enum class ElementOperation : uint8_t
{
    Unknown = 0,
    Delete = 1,
    Upsert = 2,
    Insert = 3,
};

/**
 * @brief MatchCondition structure.
 */
struct MatchCondition
{
    std::string version;          ///< Version.
    MatchRuleCondition condition; ///< Condition.
};

/**
 * @brief Agent data structure.
 */
struct AgentContextData
{
    std::string id;      ///< Agent ID.
    std::string name;    ///< Agent name.
    std::string version; ///< Agent version.
    std::string ip;      ///< Agent IP.
};

struct PackageContextData
{
    std::string id;           ///< Package item ID.
    std::string name;         ///< Package name.
    std::string version;      ///< Package version.
    std::string format;       ///< Package format.
    std::string source;       ///< Package source.
    std::string location;     ///< Package location.
    std::string architecture; ///< Package architecture.
    std::string multiarch;    ///< Package multiarch.
    std::string priority;     ///< Package priority.
    uint64_t size {0};        ///< Package size.
    std::string vendor;       ///< Package vendor.
    std::string install_time; ///< Package install time.
    std::string description;  ///< Package description.
    std::string groups;       ///< Package groups.
};

/**
 * @brief ScanContext structure.
 *
 * @tparam TOsDataCache os data cache type.
 * @tparam TGlobalData global data type.
 * @tparam TRemediationDataCache remediation data cache type.
 */
template<typename TOsDataCache = OsDataCache<>,
         typename TGlobalData = GlobalData,
         typename TRemediationDataCache = RemediationDataCache<>>
struct TScanContext final
{
private:
    /**
     * @brief Os data.
     */
    Os m_osDataCache {};

    /**
     * @brief Element type to process.
     */
    AffectedComponentType m_affectedComponentType {AffectedComponentType::Unknown};

    /**
     * @brief AgentContextData, populated with the StartMessage data.
     */
    AgentContextData m_agentContextData {};

    /**
     * @brief PackageContextData, populated with the package data.
     */
    std::vector<std::pair<PackageContextData, ElementOperation>> m_packageContextDataList {};

    /**
    @brief Is a full scan context
     */
    bool m_isFullScanContext {false};

    /**
     * @brief Build CPE name.
     */
    void buildCPEName()
    {
        const auto& osCpeMaps = TGlobalData::instance().osCpeMaps();

        m_osDataCache.cpeName = "cpe:/o:";

        std::string cpe;
        for (auto it = osCpeMaps.rbegin(); it != osCpeMaps.rend(); ++it)
        {
            if (m_osDataCache.name.compare(it.key()) == 0 || Utils::startsWith(m_osDataCache.name, it.key()) ||
                m_osDataCache.platform.compare(it.key()) == 0)
            {
                cpe = it.value();
                break;
            }
        }

        if (!cpe.empty())
        {
            // Replace variables in the CPE name
            Utils::replaceAll(cpe, "$(MAJOR_VERSION)", m_osDataCache.majorVersion);
            Utils::replaceAll(cpe, "$(MINOR_VERSION)", m_osDataCache.minorVersion);
            Utils::replaceAll(cpe, "$(DISPLAY_VERSION)", m_osDataCache.displayVersion);
            Utils::replaceAll(cpe, "$(VERSION)", m_osDataCache.version);
            Utils::replaceAll(cpe, "$(RELEASE)", m_osDataCache.release);

            // For SUSE, replace the hyphen in the version with a colon, because inner the version we have the version
            // update.
            auto versionWithHyphen {m_osDataCache.version};
            Utils::replaceAll(versionWithHyphen, "-", ":");
            Utils::replaceAll(cpe, "$(VERSION_UPDATE_HYPHEN)", versionWithHyphen);

            m_osDataCache.cpeName += Utils::toLowerCase(cpe);
        }
        else
        {
            // Clear the cpeName if the OS is not supported
            m_osDataCache.cpeName = "";
        }
    }

    void checkIfFullScanContext(const std::vector<std::string>& indices)
    {
        for (const auto& idx : indices)
        {
            if (idx == OS_INDEX || idx == HOTFIX_INDEX)
            {
                m_isFullScanContext = true;
            }
        }
    }

public:
    // LCOV_EXCL_START
    /**
     * @brief Class constructor.
     *
     */
    TScanContext() = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Class constructor.
     *
     * @param contextSync Scan context.
     */
    explicit TScanContext(const Context& contextSync)
    {
        m_agentContextData.id = contextSync.agentId;
        m_agentContextData.name = contextSync.agentName;
        m_agentContextData.version = contextSync.agentVersion;
        checkIfFullScanContext(contextSync.indices);

        // Set a default capacity for package context data list to avoid multiple allocations
        if (m_isFullScanContext)
        {
            m_packageContextDataList.reserve(PKG_CAPACITY);
        }
        else
        {
            m_packageContextDataList.reserve(PKG_CAPACITY / 10);
        }
    }

    // LCOV_EXCL_START
    /**
     * @brief Class destructor.
     *
     */
    ~TScanContext() = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Get package context data at index.
     *
     * @return Package context data.
     */
    std::pair<PackageContextData, ElementOperation>& getPackageContextData(size_t index)
    {
        return m_packageContextDataList.at(index);
    }

    /**
     * @brief Insert package context data.
     * @param packageData Package context data.
     * @param operation Element operation.
     */
    void addPackageToContext(const PackageContextData& packageData, ElementOperation operation)
    {
        m_packageContextDataList.emplace_back(packageData, operation);
    }

    /**
     * @brief Gets os hostName.
     * @return Os hostName.
     */
    std::string_view osHostName() const
    {
        return m_osDataCache.hostName;
    }

    /**
     * @brief Gets os architecture.
     * @return Os architecture.
     */
    std::string_view osArchitecture() const
    {
        return m_osDataCache.architecture;
    }

    /**
     * @brief Gets os name.
     * @return Os name.
     */
    std::string_view osName() const
    {
        return m_osDataCache.name;
    }

    /**
     * @brief Gets os version.
     * @return Os version.
     */
    std::string_view osVersion() const
    {
        return m_osDataCache.version;
    }

    /**
     * @brief Gets os codeName.
     * @return Os codeName.
     */
    std::string_view osCodeName() const
    {
        return m_osDataCache.codeName;
    }

    /**
     * @brief Gets os major version.
     * @return Os major version.
     */
    std::string_view osMajorVersion() const
    {
        return m_osDataCache.majorVersion;
    }

    /**
     * @brief Gets os minor version.
     * @return Os minor version.
     */
    std::string_view osMinorVersion() const
    {
        return m_osDataCache.minorVersion;
    }

    /**
     * @brief Gets os patch version.
     * @return Os patch version.
     */
    std::string_view osPatch() const
    {
        return m_osDataCache.patch;
    }

    /**
     * @brief Gets os build number.
     * @return Os build number.
     */
    std::string_view osBuild() const
    {
        return m_osDataCache.build;
    }

    /**
     * @brief Gets os platform.
     * @return Os platform.
     */
    std::string_view osPlatform() const
    {
        return m_osDataCache.platform;
    }

    /**
     * @brief Gets os kernel sysName.
     * @return Os kernel sysName.
     */
    std::string_view osKernelSysName() const
    {
        return m_osDataCache.sysName;
    }

    /**
     * @brief Gets os kernel release.
     * @return Os kernel release.
     */
    std::string_view osKernelRelease() const
    {
        return m_osDataCache.kernelRelease;
    }

    /**
     * @brief Gets os kernel version.
     * @return Os kernel version.
     */
    std::string_view osKernelVersion() const
    {
        return m_osDataCache.kernelVersion;
    }

    /**
     * @brief Gets os release
     * @return Os release.
     */
    std::string_view osRelease() const
    {
        return m_osDataCache.release;
    }

    /**
     * @brief Gets os display name.
     * @return Os display name.
     */
    std::string_view osDisplayVersion() const
    {
        return m_osDataCache.displayVersion;
    }

    /**
     * @brief Get cluster name.
     * @return Cluster name.
     */
    std::string_view clusterName() const
    {
        static std::string clusterName = PolicyManager::instance().getClusterName();
        return clusterName;
    }

    /**
     * @brief Gets cluster node name
     * @return Cluster node name.
     */
    std::string_view clusterNodeName() const
    {
        static std::string clusterNodeName = PolicyManager::instance().getClusterNodeName();
        return clusterNodeName;
    }

    /**
     * @brief Gets OS CPE.
     * @return OS CPE.
     */
    std::string_view osCPEName() const
    {
        return m_osDataCache.cpeName;
    }

    /**
     * @brief Gets manager name.
     * @return Manager name.
     */
    std::string_view managerName() const
    {
        return TGlobalData::instance().managerName();
    }

    /**
     * @brief Feed source information.
     *
     * @note Use @see VulnerabilitySource enum to access each field
     *
     * @return Pair with CNA/ADP base name and CNA/ADP expanded name.
     */
    std::pair<std::string, std::string> m_vulnerabilitySource;

    /**
     * @brief Gets the affected component type.
     *
     * @return AffectedComponentType The type of component that is affected in the event.
     */
    AffectedComponentType affectedComponentType() const
    {
        return m_affectedComponentType;
    }

    /**
     * @brief Elements to process.
     */
    std::unordered_map<std::string, nlohmann::json> m_elements;

    /**
     * @brief Elements for alerts.
     *
     */
    std::unordered_map<std::string, nlohmann::json> m_alerts;

    /**
     * @brief Elements matching the query.
     *
     */
    std::unordered_map<std::string, MatchCondition> m_matchConditions;

    /**
     * @brief Detection source for CVEs only when the default CNA is used.
     *
     */
    std::unordered_map<std::string, std::string> m_cnaDetectionSource;

    /**
     * @brief Agent data list.
     *
     * @details This list is used to store the agent data for the re-scan all agents event.
     */
    std::vector<AgentContextData> m_agents;

    /**
     * @brief Agent data list with exceptions.
     *
     * @details This list is used to store the agent data with exceptions during the re-scan all agents event.
     */
    std::vector<AgentContextData> m_agentsWithIncompletedScan;

    /**
     * @brief Variable to store if the inventory is empty before an integrity clear event for the agent.
     *
     */
    bool m_isInventoryEmpty = false;

    /**
     * @brief Variable to store if is the first scan for the agent.
     *
     */
    bool m_isFirstScan = true;

    /**
     * @brief Variable to check if the scan is a no-index scan.
     * @details This is used to avoid indexing the scan results.
     */
    bool m_noIndex = false;
    // LCOV_EXCL_STOP
};

using ScanContext = TScanContext<>;

#endif // _SCAN_CONTEXT_HPP
