/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_CONTEXT_HPP
#define _SCAN_CONTEXT_HPP

#include "../../inventory_sync/src/context.hpp"
#include "../policyManager/policyManager.hpp"
#include "globalData.hpp"
#include "logging_helper.h"
#include <cstdint>
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>
#include <json.hpp>

constexpr std::string_view OS_INDEX      = "wazuh-states-inventory-system";
constexpr std::string_view HOTFIX_INDEX  = "wazuh-states-inventory-hotfixes";
constexpr std::string_view PACKAGE_INDEX = "wazuh-states-inventory-packages";
constexpr auto PKG_CAPACITY              = 1000;

/**
 * @brief Vulnerability source.
 */
enum VulnerabilitySource : uint8_t
{
    ADP_BASE     = 0,
    ADP_EXPANDED = 1
};

/**
 * @brief Scanner type.
 */
enum class ScannerType : uint8_t
{
    Unknown                 = 0,
    PackageDelta            = 1,
    OS                      = 2,
    FirstFullScan           = 3,
    FullScan                = 4,
    FullScanAfterFeedUpdate = 5,
    CleanupAgentData        = 6
};

/**
 * @brief The affected component type is used to determine what type of data is affected in the system.
 */
enum class AffectedComponentType : uint8_t
{
    Unknown = 0,
    Package = 1,
    Os      = 2,
    Hotfix  = 3,
    Agent   = 4,
};

/**
 * @brief Match rule condition for version matching.
 */
enum class MatchRuleCondition : uint8_t
{
    Unknown            = 0,
    Equal              = 1,
    NotEqual           = 2,
    GreaterThan        = 3,
    GreaterThanOrEqual = 4,
    LessThan           = 5,
    LessThanOrEqual    = 6,
    Contains           = 7,
    NotContains        = 8,
    StartsWith         = 9,
    EndsWith           = 10,
    DefaultStatus      = 11,
};

/**
 * @brief Element operation type.
 */
enum class ElementOperation : uint8_t
{
    Unknown = 0,
    Delete  = 1, ///< Element deletion
    Upsert  = 2, ///< Insert or update
};

/**
 * @brief Match condition structure (legacy support).
 * @deprecated Use CVEDetectionResult instead.
 */
struct MatchCondition
{
    std::string        version;   ///< Version.
    MatchRuleCondition condition; ///< Condition.
};

/**
 * @brief Agent data structure.
 */
struct AgentContextData
{
    std::string id;      ///< Agent ID.
    std::string name;    ///< Agent name.
    std::string version; ///< Agent version.
    std::string ip;      ///< Agent IP.
};

/**
 * @brief Package context data from inventory sync.
 */
struct PackageContextData final
{
    std::string item_id;      ///< Package item ID.
    std::string name;         ///< Package name.
    std::string version;      ///< Package version.
    std::string format;       ///< Package format (deb, rpm, etc.).
    std::string source;       ///< Package source.
    std::string location;     ///< Package location/path.
    std::string architecture; ///< Package architecture.
    std::string multiarch;    ///< Package multiarch.
    std::string priority;     ///< Package priority.
    uint64_t    size {0};     ///< Package size in bytes.
    std::string vendor;       ///< Package vendor.
    std::string install_time; ///< Package install time.
    std::string description;  ///< Package description.
    std::string groups;       ///< Package groups / category.
};

/**
 * @brief Hotfix context data from inventory sync.
 *
 * The list of hotfixes in the ScanContext represents the set of hotfixes
 * currently installed on the system for the scan session.
 * Only used in the full scan process.
 */
struct HotfixContextData final
{
    std::string hotfixName; ///< Hotfix identifier (e.g. KB...).
};

/**
 * @brief Os context data from inventory sync.
 *
 * This structure is initially populated with the basic fields from the Start
 * message (Context) and is completed with the DataValue/DataContext from the
 * OS index when available.
 */
struct OsContextData final
{
    std::string item_id;        ///< OS item ID.
    std::string hostName;       ///< Hostname of the agent.
    std::string architecture;   ///< Architecture of the agent.
    std::string name;           ///< Name of operating system.
    std::string codeName;       ///< Code name of the operating system.
    std::string majorVersion;   ///< Major version of the operating system.
    std::string minorVersion;   ///< Minor version of the operating system.
    std::string patch;          ///< Patch of the operating system.
    std::string build;          ///< Build of the operating system.
    std::string platform;       ///< Platform of the operating system.
    std::string version;        ///< Version of the operating system.
    std::string release;        ///< Release of the operating system.
    std::string displayVersion; ///< Display version of the operating system.
    std::string sysName;        ///< System name of the operating system (e.g. linux, windows).
    std::string kernelVersion;  ///< Version of the kernel operating system.
    std::string kernelRelease;  ///< Release of the kernel operating system.
    std::string cpeName;        ///< CPE name of the operating system.
};

/**
 * @brief Vulnerability detection result for a single CVE.
 * Replaces nlohmann::json for 10× better performance.
 * Contains all data needed for ECS event generation.
 */
struct CVEDetectionResult
{
    // ========== CVE Detection Metadata ==========
    std::string           cveId;          ///< CVE identifier (e.g., "CVE-2024-1234")
    std::string           cnaSource;      ///< CNA that provided this detection
    std::string           matchCondition; ///< Version condition that matched
    MatchRuleCondition    conditionType;  ///< Type of match
    AffectedComponentType componentType;  ///< What type of component is affected
    std::string           feedOffset;     ///< Description offset for versioning
    ElementOperation      operation {ElementOperation::Upsert}; ///< Operation type

    // ========== Package Information (for ECS event building) ==========
    std::string packageName;         ///< Package where CVE was detected
    std::string packageVersion;      ///< Version of affected package
    std::string packageFormat;       ///< Package format (deb, rpm, etc.)
    std::string packageArchitecture; ///< Package architecture
    std::string packageDescription;  ///< Package description
    std::string packageLocation;     ///< Package path/location
    std::string packageInstallTime;  ///< Package install time (raw timestamp)
    uint64_t    packageSize {0};     ///< Package size in bytes
};

/**
 * @brief ScanContext structure.
 * Contains all data needed for vulnerability scanning and event generation.
 *
 * @tparam TOsDataCache OS data cache type.
 * @tparam TGlobalData Global data type.
 */
template<typename TOsDataCache = void,
         typename TGlobalData  = GlobalData>
struct TScanContext final
{
private:
    /**
     * @brief OS context cache.
     */
    OsContextData m_osContextDataCache {};

    /**
     * @brief Element type to process.
     */
    AffectedComponentType m_affectedComponentType {AffectedComponentType::Unknown};

    /**
     * @brief Agent context data, populated with the Start message data (Context).
     */
    AgentContextData m_agentContextData {};

    /**
     * @brief Package context data list, populated with package data from inventory sync.
     *
     * Each entry represents the final state of a package in the session, with
     * an operation associated (Upsert/Delete).
     */
    std::vector<std::pair<PackageContextData, ElementOperation>> m_packageContextDataList {};

    /**
     * @brief Hotfix context data list, populated with hotfix data from inventory sync.
     *
     * This list represents the hotfixes currently installed on the agent.
     */
    std::vector<HotfixContextData> m_hotfixContextDataList {};

    /**
     * @brief Detected vulnerabilities (unique detection ID → detection details).
     *
     * The key of the map is not just the cveId, but a unique identifier per
     * detection (for example, an _id derived from agentId + hash(pkg) + cveId).
     * This allows storing multiple detections of the same CVE in different
     * packages of the same agent.
     */
    std::unordered_map<std::string, CVEDetectionResult> m_detectedCVEs;

    /**
     * @brief Serialized ECS events ready for indexing.
     * Stored as JSON strings (final format for indexer).
     *
     * The keys of this map must match those of m_detectedCVEs
     * (same detectionId).
     */
    std::unordered_map<std::string, std::string> m_ecsEvents;

    /**
     * @brief Is a full scan context.
     */
    bool m_isFullScanContext {false};

    /**
     * @brief Variable to store if the inventory is empty before an integrity clear event.
     */
    bool m_isInventoryEmpty {false};

    /**
     * @brief Variable to store if is the first scan for the agent.
     */
    bool m_isFirstScan {true};

    /**
     * @brief Variable to check if the scan is a no-index scan.
     */
    bool m_noIndex {false};

    /**
     * @brief Build CPE name for OS.
     */
    void buildCPEName()
    {
        const auto& osCpeMaps = TGlobalData::instance().osCpeMaps();

        m_osContextDataCache.cpeName = "cpe:/o:";

        std::string cpe;
        for (auto it = osCpeMaps.rbegin(); it != osCpeMaps.rend(); ++it)
        {
            if (m_osContextDataCache.name == it.key() ||
                Utils::startsWith(m_osContextDataCache.name, it.key()) ||
                m_osContextDataCache.platform == it.key())
            {
                cpe = it.value();
                break;
            }
        }

        if (!cpe.empty())
        {
            // Replace variables in the CPE name
            Utils::replaceAll(cpe, "$(MAJOR_VERSION)", m_osContextDataCache.majorVersion);
            Utils::replaceAll(cpe, "$(MINOR_VERSION)", m_osContextDataCache.minorVersion);
            Utils::replaceAll(cpe, "$(DISPLAY_VERSION)", m_osContextDataCache.displayVersion);
            Utils::replaceAll(cpe, "$(VERSION)", m_osContextDataCache.version);
            Utils::replaceAll(cpe, "$(RELEASE)", m_osContextDataCache.release);

            // For SUSE, replace hyphen with colon in version
            auto versionWithHyphen = m_osContextDataCache.version;
            Utils::replaceAll(versionWithHyphen, "-", ":");
            Utils::replaceAll(cpe, "$(VERSION_UPDATE_HYPHEN)", versionWithHyphen);

            m_osContextDataCache.cpeName += Utils::toLowerCase(cpe);
        }
        else
        {
            // Clear the cpeName if the OS is not supported
            m_osContextDataCache.cpeName.clear();
        }
    }

    /**
     * @brief Check if this is a full scan context based on indices.
     */
    void checkIfFullScanContext(const std::vector<std::string>& indices)
    {
        for (const auto& idx : indices)
        {
            if (idx == OS_INDEX || idx == HOTFIX_INDEX)
            {
                m_isFullScanContext = true;
                return;
            }
        }
    }

public:
    /**
     * @brief Default constructor.
     */
    TScanContext() = default;

    /**
     * @brief Constructor from inventory sync context (Start message).
     *
     * This constructor:
     *  - Fills basic agent data.
     *  - Fills basic OS data (the ones that come in Start/Context).
     *  - Determines if the context corresponds to a full scan.
     *  - Pre-reserves capacity for internal containers.
     */
    explicit TScanContext(const Context& contextSync)
    {
        // Agent basic data from Start.
        m_agentContextData.id      = contextSync.agentId;
        m_agentContextData.name    = contextSync.agentName;
        m_agentContextData.version = contextSync.agentVersion;

        // Basic OS data from Start (may be partially completed later by OS DataValue/DataContext).
        m_osContextDataCache.hostName       = contextSync.hostname;
        m_osContextDataCache.architecture   = contextSync.architecture;
        m_osContextDataCache.name           = contextSync.osname;
        m_osContextDataCache.platform       = contextSync.osplatform;
        m_osContextDataCache.sysName        = contextSync.ostype;
        m_osContextDataCache.version        = contextSync.osversion;
        m_osContextDataCache.displayVersion = contextSync.osversion;

        checkIfFullScanContext(contextSync.indices);

        // Pre-allocate capacity for package and hotfix context data
        if (m_isFullScanContext)
        {
            m_packageContextDataList.reserve(PKG_CAPACITY);
            m_hotfixContextDataList.reserve(PKG_CAPACITY / 10);
            m_detectedCVEs.reserve(PKG_CAPACITY / 10); // Estimate ~10% vulnerable
            m_ecsEvents.reserve(PKG_CAPACITY / 10);
        }
        else
        {
            m_packageContextDataList.reserve(PKG_CAPACITY / 10);
            m_hotfixContextDataList.reserve(PKG_CAPACITY / 20);
            m_detectedCVEs.reserve(PKG_CAPACITY / 100);
            m_ecsEvents.reserve(PKG_CAPACITY / 100);
        }

        // Build initial CPE with the information we already know from Start.
        buildCPEName();
    }

    /**
     * @brief Destructor.
     */
    ~TScanContext() = default;

    // Prevent copying (use move semantics)
    TScanContext(const TScanContext&)            = delete;
    TScanContext& operator=(const TScanContext&) = delete;

    // Allow moving
    TScanContext(TScanContext&&) noexcept            = default;
    TScanContext& operator=(TScanContext&&) noexcept = default;

    // =============== Agent Context Data Accessors ================

    /**
     * @brief Get agent ID.
     * @return Agent ID.
     */
    std::string_view agentId() const noexcept
    {
        return m_agentContextData.id;
    }

    /**
     * @brief Get agent name.
     * @return Agent name.
     */
    std::string_view agentName() const noexcept
    {
        return m_agentContextData.name;
    }

    /**
     * @brief Get agent version.
     * @return Agent version.
     */
    std::string_view agentVersion() const noexcept
    {
        return m_agentContextData.version;
    }

    /**
     * @brief Get agent IP.
     * @return Agent IP.
     */
    std::string_view agentIP() const noexcept
    {
        return m_agentContextData.ip;
    }

    /**
     * @brief Set agent IP.
     * @param ip Agent IP address.
     */
    void setAgentIP(std::string_view ip)
    {
        m_agentContextData.ip = ip;
    }

    // =============== Package Context Data Accessors ================

    /**
     * @brief Get package context data at index.
     * @param index Package index.
     * @return Package context data and operation.
     */
    std::pair<PackageContextData, ElementOperation>& getPackageContextData(size_t index)
    {
        return m_packageContextDataList.at(index);
    }

    /**
     * @brief Get package context data at index (const version).
     * @param index Package index.
     * @return Package context data and operation.
     */
    const std::pair<PackageContextData, ElementOperation>& getPackageContextData(size_t index) const
    {
        return m_packageContextDataList.at(index);
    }

    /**
     * @brief Get the package count of the context data.
     * @return Package count.
     */
    size_t getPackageCount() const noexcept
    {
        return m_packageContextDataList.size();
    }

    /**
     * @brief Insert package context data.
     * @param packageData Package context data.
     * @param operation Element operation.
     */
    void addPackageToContext(const PackageContextData& packageData, ElementOperation operation)
    {
        m_packageContextDataList.emplace_back(packageData, operation);
    }

    /**
     * @brief Insert package context data (move version).
     * @param packageData Package context data.
     * @param operation Element operation.
     */
    void addPackageToContext(PackageContextData&& packageData, ElementOperation operation)
    {
        m_packageContextDataList.emplace_back(std::move(packageData), operation);
    }

    /**
     * @brief Get package count.
     * @return Package count.
     */
    size_t packageCount() const noexcept
    {
        return m_packageContextDataList.size();
    }

    /**
     * @brief Clear all packages.
     */
    void clearPackages()
    {
        m_packageContextDataList.clear();
    }

    // =============== Hotfix Context Data Accessors ================

    /**
     * @brief Get hotfix context data at index.
     * @param index Hotfix index.
     * @return Hotfix context data.
     */
    HotfixContextData& getHotfixContextData(size_t index)
    {
        return m_hotfixContextDataList.at(index);
    }

    /**
     * @brief Get hotfix context data at index (const version).
     * @param index Hotfix index.
     * @return Hotfix context data.
     */
    const HotfixContextData& getHotfixContextData(size_t index) const
    {
        return m_hotfixContextDataList.at(index);
    }

    /**
     * @brief Get the hotfix count of the context data.
     * @return Hotfix count.
     */
    size_t hotfixCount() const noexcept
    {
        return m_hotfixContextDataList.size();
    }

    /**
     * @brief Get read-only access to the full hotfix list.
     */
    const std::vector<HotfixContextData>& hotfixes() const noexcept
    {
        return m_hotfixContextDataList;
    }

    /**
     * @brief Insert hotfix context data.
     * @param hotfixData Hotfix context data.
     */
    void addHotfixToContext(const HotfixContextData& hotfixData)
    {
        m_hotfixContextDataList.emplace_back(hotfixData);
    }

    /**
     * @brief Insert hotfix context data (move version).
     * @param hotfixData Hotfix context data.
     */
    void addHotfixToContext(HotfixContextData&& hotfixData)
    {
        m_hotfixContextDataList.emplace_back(std::move(hotfixData));
    }

    /**
     * @brief Clear all hotfix entries.
     */
    void clearHotfixes()
    {
        m_hotfixContextDataList.clear();
    }

    // =============== CVE Detection Results Management ================

    /**
     * @brief Add detected CVE to results.
     * @param detectionId Unique detection identifier (e.g. VD _id).
     * @param detection CVE detection result.
     */
    void addDetectedCVE(const std::string& detectionId, CVEDetectionResult&& detection)
    {
        m_detectedCVEs.emplace(detectionId, std::move(detection));
    }

    /**
     * @brief Check if a detection already exists.
     * @param detectionId Unique detection identifier.
     * @return True if detection exists, false otherwise.
     */
    bool hasCVE(const std::string& detectionId) const noexcept
    {
        return m_detectedCVEs.contains(detectionId);
    }

    /**
     * @brief Remove CVE detection (e.g., solved by hotfix).
     * @param detectionId Unique detection identifier.
     */
    void removeCVE(const std::string& detectionId)
    {
        m_detectedCVEs.erase(detectionId);
        m_ecsEvents.erase(detectionId); // Also remove ECS event if exists
    }

    /**
     * @brief Get mutable access to detected CVEs (for updating).
     * @return Mutable reference to detected CVEs map.
     */
    std::unordered_map<std::string, CVEDetectionResult>& detectedCVEs() noexcept
    {
        return m_detectedCVEs;
    }

    /**
     * @brief Get read-only access to detected CVEs.
     * @return Const reference to detected CVEs map.
     */
    const std::unordered_map<std::string, CVEDetectionResult>& detectedCVEs() const noexcept
    {
        return m_detectedCVEs;
    }

    /**
     * @brief Get specific CVE detection result.
     * @param detectionId Unique detection identifier.
     * @return Pointer to detection result, or nullptr if not found.
     */
    const CVEDetectionResult* getCVE(const std::string& detectionId) const noexcept
    {
        auto it = m_detectedCVEs.find(detectionId);
        return (it != m_detectedCVEs.end()) ? &it->second : nullptr;
    }

    /**
     * @brief Get specific CVE detection result (mutable).
     * @param detectionId Unique detection identifier.
     * @return Pointer to detection result, or nullptr if not found.
     */
    CVEDetectionResult* getCVE(const std::string& detectionId) noexcept
    {
        auto it = m_detectedCVEs.find(detectionId);
        return (it != m_detectedCVEs.end()) ? &it->second : nullptr;
    }

    /**
     * @brief Count of detected CVEs.
     * @return Number of detected CVEs.
     */
    size_t cveCount() const noexcept
    {
        return m_detectedCVEs.size();
    }

    /**
     * @brief Clear all detected CVEs.
     */
    void clearCVEs()
    {
        m_detectedCVEs.clear();
    }

    // =============== ECS Events Management ================

    /**
     * @brief Store ECS event JSON for later dispatch.
     * @param detectionId Unique detection identifier (same key as m_detectedCVEs).
     * @param eventJSON Serialized ECS event JSON.
     */
    void addECSEvent(const std::string& detectionId, std::string&& eventJSON)
    {
        m_ecsEvents.emplace(detectionId, std::move(eventJSON));
    }

    /**
     * @brief Get all ECS events.
     * @return Const reference to ECS events map.
     */
    const std::unordered_map<std::string, std::string>& ecsEvents() const noexcept
    {
        return m_ecsEvents;
    }

    /**
     * @brief Get specific ECS event.
     * @param detectionId Unique detection identifier.
     * @return Pointer to ECS event JSON, or nullptr if not found.
     */
    const std::string* getECSEvent(const std::string& detectionId) const noexcept
    {
        auto it = m_ecsEvents.find(detectionId);
        return (it != m_ecsEvents.end()) ? &it->second : nullptr;
    }

    /**
     * @brief Count of ECS events.
     * @return Number of ECS events.
     */
    size_t ecsEventCount() const noexcept
    {
        return m_ecsEvents.size();
    }

    /**
     * @brief Clear all ECS events.
     */
    void clearECSEvents()
    {
        m_ecsEvents.clear();
    }

    // =============== OS Context Data Accessors ================

    /**
     * @brief Get OS item ID.
     * @return OS item ID.
     */
    std::string_view osItemId() const noexcept
    {
        return m_osContextDataCache.item_id;
    }

    /**
     * @brief Get OS hostname.
     * @return OS hostname.
     */
    std::string_view osHostName() const noexcept
    {
        return m_osContextDataCache.hostName;
    }

    /**
     * @brief Get OS architecture.
     * @return OS architecture.
     */
    std::string_view osArchitecture() const noexcept
    {
        return m_osContextDataCache.architecture;
    }

    /**
     * @brief Get OS name.
     * @return OS name.
     */
    std::string_view osName() const noexcept
    {
        return m_osContextDataCache.name;
    }

    /**
     * @brief Get OS version.
     * @return OS version.
     */
    std::string_view osVersion() const noexcept
    {
        return m_osContextDataCache.version;
    }

    /**
     * @brief Get OS code name.
     * @return OS code name.
     */
    std::string_view osCodeName() const noexcept
    {
        return m_osContextDataCache.codeName;
    }

    /**
     * @brief Get OS major version.
     * @return OS major version.
     */
    std::string_view osMajorVersion() const noexcept
    {
        return m_osContextDataCache.majorVersion;
    }

    /**
     * @brief Get OS minor version.
     * @return OS minor version.
     */
    std::string_view osMinorVersion() const noexcept
    {
        return m_osContextDataCache.minorVersion;
    }

    /**
     * @brief Get OS patch version.
     * @return OS patch version.
     */
    std::string_view osPatch() const noexcept
    {
        return m_osContextDataCache.patch;
    }

    /**
     * @brief Get OS build number.
     * @return OS build number.
     */
    std::string_view osBuild() const noexcept
    {
        return m_osContextDataCache.build;
    }

    /**
     * @brief Get OS platform.
     * @return OS platform.
     */
    std::string_view osPlatform() const noexcept
    {
        return m_osContextDataCache.platform;
    }

    /**
     * @brief Get OS kernel system name.
     * @return OS kernel system name.
     */
    std::string_view osKernelSysName() const noexcept
    {
        return m_osContextDataCache.sysName;
    }

    /**
     * @brief Get OS kernel release.
     * @return OS kernel release.
     */
    std::string_view osKernelRelease() const noexcept
    {
        return m_osContextDataCache.kernelRelease;
    }

    /**
     * @brief Get OS kernel version.
     * @return OS kernel version.
     */
    std::string_view osKernelVersion() const noexcept
    {
        return m_osContextDataCache.kernelVersion;
    }

    /**
     * @brief Get OS release.
     * @return OS release.
     */
    std::string_view osRelease() const noexcept
    {
        return m_osContextDataCache.release;
    }

    /**
     * @brief Get OS display version.
     * @return OS display version.
     */
    std::string_view osDisplayVersion() const noexcept
    {
        return m_osContextDataCache.displayVersion;
    }

    /**
     * @brief Get OS CPE name.
     * @return OS CPE name.
     */
    std::string_view osCPEName() const noexcept
    {
        return m_osContextDataCache.cpeName;
    }

    /**
     * @brief Set OS data cache (replaces and recomputes CPE).
     * @param osData OS data.
     */
    void setOSData(const OsContextData& osData)
    {
        m_osContextDataCache = osData;
        buildCPEName();
    }

    // =============== Cluster and Manager Data ================

    /**
     * @brief Get cluster name.
     * @return Cluster name.
     */
    std::string_view clusterName() const noexcept
    {
        static const std::string clusterName = PolicyManager::instance().getClusterName();
        return clusterName;
    }

    /**
     * @brief Get cluster node name.
     * @return Cluster node name.
     */
    std::string_view clusterNodeName() const noexcept
    {
        static const std::string clusterNodeName = PolicyManager::instance().getClusterNodeName();
        return clusterNodeName;
    }

    /**
     * @brief Get manager name.
     * @return Manager name.
     */
    std::string_view managerName() const noexcept
    {
        return TGlobalData::instance().managerName();
    }

    // =============== Scan Configuration ================

    /**
     * @brief Get the affected component type.
     * @return Affected component type.
     */
    AffectedComponentType affectedComponentType() const noexcept
    {
        return m_affectedComponentType;
    }

    /**
     * @brief Set the affected component type.
     * @param type Affected component type.
     */
    void setAffectedComponentType(AffectedComponentType type) noexcept
    {
        m_affectedComponentType = type;
    }

    /**
     * @brief Check if this is a full scan context.
     * @return True if full scan, false otherwise.
     */
    bool isFullScanContext() const noexcept
    {
        return m_isFullScanContext;
    }

    /**
     * @brief Check if inventory is empty.
     * @return True if empty, false otherwise.
     */
    bool isInventoryEmpty() const noexcept
    {
        return m_isInventoryEmpty;
    }

    /**
     * @brief Set inventory empty flag.
     * @param empty Inventory empty flag.
     */
    void setInventoryEmpty(bool empty) noexcept
    {
        m_isInventoryEmpty = empty;
    }

    /**
     * @brief Check if this is the first scan.
     * @return True if first scan, false otherwise.
     */
    bool isFirstScan() const noexcept
    {
        return m_isFirstScan;
    }

    /**
     * @brief Set first scan flag.
     * @param first First scan flag.
     */
    void setFirstScan(bool first) noexcept
    {
        m_isFirstScan = first;
    }

    /**
     * @brief Check if this is a no-index scan.
     * @return True if no-index, false otherwise.
     */
    bool isNoIndex() const noexcept
    {
        return m_noIndex;
    }

    /**
     * @brief Set no-index flag.
     * @param noIndex No-index flag.
     */
    void setNoIndex(bool noIndex) noexcept
    {
        m_noIndex = noIndex;
    }

    // =============== Public Data Members (Legacy Support) ================

    /**
     * @brief Feed source information.
     *
     * @note Use @see VulnerabilitySource enum to access each field.
     * @note Pair with CNA/ADP base name and CNA/ADP expanded name.
     */
    std::pair<std::string, std::string> m_vulnerabilitySource;

    /**
     * @brief Elements for alerts (legacy).
     * @deprecated Use m_detectedCVEs instead.
     */
    std::unordered_map<std::string, nlohmann::json> m_alerts;

    /**
     * @brief Elements matching the query (legacy).
     * @deprecated Data now stored in CVEDetectionResult.
     */
    std::unordered_map<std::string, MatchCondition> m_matchConditions;

    /**
     * @brief Detection source for CVEs (legacy).
     * @deprecated Data now stored in CVEDetectionResult.cnaSource.
     */
    std::unordered_map<std::string, std::string> m_cnaDetectionSource;

    /**
     * @brief Agent data list for re-scan all agents event.
     */
    std::vector<AgentContextData> m_agents;

    /**
     * @brief Agent data list with exceptions during re-scan all agents event.
     */
    std::vector<AgentContextData> m_agentsWithIncompletedScan;

    /**
     * @brief Build a JSON representation of the whole ScanContext for debugging purposes.
     *
     * @return std::string JSON string with the internal state.
     */
    std::string toDebugJSON() const
    {
        nlohmann::json j;

        // Agent data
        j["agent"]["id"]      = m_agentContextData.id;
        j["agent"]["name"]    = m_agentContextData.name;
        j["agent"]["version"] = m_agentContextData.version;
        j["agent"]["ip"]      = m_agentContextData.ip;

        // OS cache
        j["os"]["item_id"]        = m_osContextDataCache.item_id;
        j["os"]["hostName"]       = m_osContextDataCache.hostName;
        j["os"]["architecture"]   = m_osContextDataCache.architecture;
        j["os"]["name"]           = m_osContextDataCache.name;
        j["os"]["codeName"]       = m_osContextDataCache.codeName;
        j["os"]["majorVersion"]   = m_osContextDataCache.majorVersion;
        j["os"]["minorVersion"]   = m_osContextDataCache.minorVersion;
        j["os"]["patch"]          = m_osContextDataCache.patch;
        j["os"]["build"]          = m_osContextDataCache.build;
        j["os"]["platform"]       = m_osContextDataCache.platform;
        j["os"]["version"]        = m_osContextDataCache.version;
        j["os"]["release"]        = m_osContextDataCache.release;
        j["os"]["displayVersion"] = m_osContextDataCache.displayVersion;
        j["os"]["sysName"]        = m_osContextDataCache.sysName;
        j["os"]["kernelVersion"]  = m_osContextDataCache.kernelVersion;
        j["os"]["kernelRelease"]  = m_osContextDataCache.kernelRelease;
        j["os"]["cpeName"]        = m_osContextDataCache.cpeName;

        // Scan configuration / flags
        j["scan"]["affectedComponentType"] = static_cast<int>(m_affectedComponentType);
        j["scan"]["isFullScanContext"]     = m_isFullScanContext;
        j["scan"]["isInventoryEmpty"]      = m_isInventoryEmpty;
        j["scan"]["isFirstScan"]           = m_isFirstScan;
        j["scan"]["isNoIndex"]             = m_noIndex;

        // Vulnerability source (base / expanded)
        j["vulnerabilitySource"]["base"]     = m_vulnerabilitySource.first;
        j["vulnerabilitySource"]["expanded"] = m_vulnerabilitySource.second;

        // Package list
        j["packages"] = nlohmann::json::array();
        for (const auto& entry : m_packageContextDataList)
        {
            const auto& pkg = entry.first;
            const auto  op  = entry.second;

            nlohmann::json p;
            p["item_id"]      = pkg.item_id;
            p["name"]         = pkg.name;
            p["version"]      = pkg.version;
            p["format"]       = pkg.format;
            p["source"]       = pkg.source;
            p["location"]     = pkg.location;
            p["architecture"] = pkg.architecture;
            p["multiarch"]    = pkg.multiarch;
            p["priority"]     = pkg.priority;
            p["size"]         = pkg.size;
            p["vendor"]       = pkg.vendor;
            p["install_time"] = pkg.install_time;
            p["description"]  = pkg.description;
            p["groups"]       = pkg.groups;

            std::string opString = "unknown";
            switch (op)
            {
                case ElementOperation::Delete:
                    opString = "delete";
                    break;
                case ElementOperation::Upsert:
                    opString = "upsert";
                    break;
                default:
                    opString = "unknown";
                    break;
            }
            p["operation"] = opString;

            j["packages"].push_back(std::move(p));
        }

        // Hotfix list currently installed
        j["hotfixes"] = nlohmann::json::array();
        for (const auto& h : m_hotfixContextDataList)
        {
            nlohmann::json hf;
            hf["name"] = h.hotfixName;

            j["hotfixes"].push_back(std::move(hf));
        }

        // Detected CVEs (detections keyed by detectionId)
        j["detectedCVEs"] = nlohmann::json::object();
        for (const auto& [detectionId, det] : m_detectedCVEs)
        {
            nlohmann::json d;
            // Detection metadata
            d["cveId"]          = det.cveId;
            d["cnaSource"]      = det.cnaSource;
            d["matchCondition"] = det.matchCondition;
            d["conditionType"]  = static_cast<int>(det.conditionType);
            d["componentType"]  = static_cast<int>(det.componentType);
            d["feedOffset"]     = det.feedOffset;
            d["operation"]      = static_cast<int>(det.operation);

            // Package info
            d["package"]["name"]         = det.packageName;
            d["package"]["version"]      = det.packageVersion;
            d["package"]["format"]       = det.packageFormat;
            d["package"]["architecture"] = det.packageArchitecture;
            d["package"]["description"]  = det.packageDescription;
            d["package"]["location"]     = det.packageLocation;
            d["package"]["install_time"] = det.packageInstallTime;
            d["package"]["size"]         = det.packageSize;

            j["detectedCVEs"][detectionId] = std::move(d);
        }

        // ECS events (already serialized JSON strings)
        j["ecsEvents"] = nlohmann::json::object();
        for (const auto& [detectionId, eventJSON] : m_ecsEvents)
        {
            // For debugging purposes we keep them as raw strings.
            j["ecsEvents"][detectionId] = eventJSON;
        }

        // Legacy: alerts (nlohmann::json already)
        j["alerts"] = nlohmann::json::object();
        for (const auto& [key, value] : m_alerts)
        {
            j["alerts"][key] = value;
        }

        // Legacy: match conditions
        j["matchConditions"] = nlohmann::json::object();
        for (const auto& [cveId, cond] : m_matchConditions)
        {
            nlohmann::json c;
            c["version"]   = cond.version;
            c["condition"] = static_cast<int>(cond.condition);
            j["matchConditions"][cveId] = std::move(c);
        }

        // Legacy: CNA detection source
        j["cnaDetectionSource"] = nlohmann::json::object();
        for (const auto& [cveId, src] : m_cnaDetectionSource)
        {
            j["cnaDetectionSource"][cveId] = src;
        }

        // Agents (for re-scan all agents)
        auto agentToJson = [](const AgentContextData& a) -> nlohmann::json
        {
            nlohmann::json aj;
            aj["id"]      = a.id;
            aj["name"]    = a.name;
            aj["version"] = a.version;
            aj["ip"]      = a.ip;
            return aj;
        };

        j["agents"] = nlohmann::json::array();
        for (const auto& ag : m_agents)
        {
            j["agents"].push_back(agentToJson(ag));
        }

        j["agentsWithIncompletedScan"] = nlohmann::json::array();
        for (const auto& ag : m_agentsWithIncompletedScan)
        {
            j["agentsWithIncompletedScan"].push_back(agentToJson(ag));
        }

        return j.dump();
    }

    /**
     * @brief Log the ScanContext internal state in JSON format for debugging purposes.
     */
    void logDebugContext() const
    {
        const auto jsonStr = toDebugJSON();
        logDebug2(WM_VULNSCAN_LOGTAG, "ScanContext debug dump: %s", jsonStr.c_str());
    }
};

using ScanContext = TScanContext<>;

#endif // _SCAN_CONTEXT_HPP
