/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_CONTEXT_HPP
#define _SCAN_CONTEXT_HPP

#include "../../inventory_sync/src/context.hpp"
#include "globalData.hpp"
#include "logging_helper.h"
#include "osDataCache.hpp"
#include "remediationDataCache.hpp"
#include <cstdint>
#include <functional>
#include <iostream>
#include <memory>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

constexpr std::string_view OS_INDEX = "wazuh-states-inventory-system";
constexpr std::string_view HOTFIX_INDEX = "wazuh-states-inventory-hotfixes";
constexpr auto PKG_CAPACITY = 1000;

/**
 * @brief Vulnerability source.
 */
enum VulnerabilitySource : uint8_t
{
    ADP_BASE = 0,
    ADP_EXPANDED = 1
};

/**
 * @brief Scanner type.
 */
enum class ScannerType : uint8_t
{
    Unknown = 0,
    PackageDelta = 1,     // Handles INSERT/DELETE package operations
    FullScanWithDiff = 2, // OS or Hotfix change → full rescan + diff
    VDFirst = 3,          // Initial full scan (no diff)
    VDClean = 4,          // Cleanup (delete all agent CVEs)

    // Legacy types (deprecated)
    OS = 5,
    FirstFullScan = 6,
    FullScan = 7,
    FullScanAfterFeedUpdate = 8,
    CleanupAgentData = 9
};

/**
 * @brief The affected component type is used to determine what type of data is affected in the system.
 */
enum class AffectedComponentType : uint8_t
{
    Unknown = 0,
    Package = 1,
    Os = 2,
    Hotfix = 3,
    Agent = 4,
};

/**
 * @brief Match rule condition for version matching.
 */
enum class MatchRuleCondition : uint8_t
{
    Unknown = 0,
    Equal = 1,
    NotEqual = 2,
    GreaterThan = 3,
    GreaterThanOrEqual = 4,
    LessThan = 5,
    LessThanOrEqual = 6,
    Contains = 7,
    NotContains = 8,
    StartsWith = 9,
    EndsWith = 10,
    DefaultStatus = 11,
};

/**
 * @brief Element operation type.
 */
enum class ElementOperation : uint8_t
{
    Unknown = 0,
    Delete = 1,  // Package deletion
    Upsert = 2,  // Update or insert
    Insert = 3,  // New package insertion
    Deleted = 4, // Already deleted (for tracking)
};

/**
 * @brief Match condition structure (legacy support).
 * @deprecated Use CVEDetectionResult instead.
 */
struct MatchCondition
{
    std::string version;          ///< Version.
    MatchRuleCondition condition; ///< Condition.
};

/**
 * @brief Agent data structure.
 */
struct AgentContextData
{
    std::string id;      ///< Agent ID.
    std::string name;    ///< Agent name.
    std::string version; ///< Agent version.
    std::string ip;      ///< Agent IP.
};

/**
 * @brief Package context data from inventory sync.
 */
struct PackageContextData
{
    std::string id;           ///< Package item ID.
    std::string name;         ///< Package name.
    std::string version;      ///< Package version.
    std::string format;       ///< Package format (deb, rpm, etc.).
    std::string source;       ///< Package source.
    std::string location;     ///< Package location/path.
    std::string architecture; ///< Package architecture.
    std::string multiarch;    ///< Package multiarch.
    std::string priority;     ///< Package priority.
    uint64_t size {0};        ///< Package size in bytes.
    std::string vendor;       ///< Package vendor.
    std::string install_time; ///< Package install time.
    std::string description;  ///< Package description.
    std::string groups;       ///< Package groups.
};

/**
 * @brief Vulnerability detection result for a single CVE.
 * Replaces nlohmann::json for 10× better performance.
 * Contains all data needed for ECS event generation.
 */
struct CVEDetectionResult
{
    // ========== CVE Detection Metadata ==========
    std::string cveId;                                     ///< CVE identifier (e.g., "CVE-2024-1234")
    std::string cnaSource;                                 ///< CNA that provided this detection
    std::string matchCondition;                            ///< Version condition that matched
    MatchRuleCondition conditionType;                      ///< Type of match
    AffectedComponentType componentType;                   ///< What type of component is affected
    std::string feedOffset;                                ///< Description offset for versioning (FIXED: was string)
    ElementOperation operation {ElementOperation::Insert}; ///< Operation type

    // ========== Package Information (for ECS event building) ==========
    std::string packageName;         ///< Package where CVE was detected
    std::string packageVersion;      ///< Version of affected package
    std::string packageFormat;       ///< Package format (deb, rpm, etc.)
    std::string packageArchitecture; ///< Package architecture
    std::string packageDescription;  ///< Package description
    std::string packageLocation;     ///< Package path/location
    std::string packageInstallTime;  ///< Package install time (raw timestamp)
    uint64_t packageSize {0};        ///< Package size in bytes
};

/**
 * @brief ScanContext structure.
 * Contains all data needed for vulnerability scanning and event generation.
 *
 * @tparam TOsDataCache OS data cache type.
 * @tparam TGlobalData Global data type.
 * @tparam TRemediationDataCache Remediation data cache type.
 */
template<typename TOsDataCache = OsDataCache<>,
         typename TGlobalData = GlobalData,
         typename TRemediationDataCache = RemediationDataCache<>>
struct TScanContext final
{
private:
    /**
     * @brief OS data cache.
     */
    Os m_osDataCache {};

    /**
     * @brief Element type to process.
     */
    AffectedComponentType m_affectedComponentType {AffectedComponentType::Unknown};

    /**
     * @brief Agent context data, populated with the StartMessage data.
     */
    AgentContextData m_agentContextData {};

    /**
     * @brief Package context data list, populated with package data from inventory sync.
     */
    std::vector<std::pair<PackageContextData, ElementOperation>> m_packageContextDataList {};

    /**
     * @brief Detected vulnerabilities (CVE ID → detection details).
     * Replaces old m_elements map with typed struct for performance and clarity.
     */
    std::unordered_map<std::string, CVEDetectionResult> m_detectedCVEs;

    /**
     * @brief Serialized ECS events ready for indexing.
     * Stored as JSON strings (final format for indexer).
     */
    std::unordered_map<std::string, std::string> m_ecsEvents;

    /**
     * @brief Is a full scan context.
     */
    bool m_isFullScanContext {false};

    /**
     * @brief Variable to store if the inventory is empty before an integrity clear event.
     */
    bool m_isInventoryEmpty {false};

    /**
     * @brief Variable to store if is the first scan for the agent.
     */
    bool m_isFirstScan {true};

    /**
     * @brief Variable to check if the scan is a no-index scan.
     */
    bool m_noIndex {false};

    /**
     * @brief Build CPE name for OS.
     */
    void buildCPEName()
    {
        const auto& osCpeMaps = TGlobalData::instance().osCpeMaps();

        m_osDataCache.cpeName = "cpe:/o:";

        std::string cpe;
        for (auto it = osCpeMaps.rbegin(); it != osCpeMaps.rend(); ++it)
        {
            if (m_osDataCache.name == it.key() || Utils::startsWith(m_osDataCache.name, it.key()) ||
                m_osDataCache.platform == it.key())
            {
                cpe = it.value();
                break;
            }
        }

        if (!cpe.empty())
        {
            // Replace variables in the CPE name
            Utils::replaceAll(cpe, "$(MAJOR_VERSION)", m_osDataCache.majorVersion);
            Utils::replaceAll(cpe, "$(MINOR_VERSION)", m_osDataCache.minorVersion);
            Utils::replaceAll(cpe, "$(DISPLAY_VERSION)", m_osDataCache.displayVersion);
            Utils::replaceAll(cpe, "$(VERSION)", m_osDataCache.version);
            Utils::replaceAll(cpe, "$(RELEASE)", m_osDataCache.release);

            // For SUSE, replace hyphen with colon in version
            auto versionWithHyphen = m_osDataCache.version;
            Utils::replaceAll(versionWithHyphen, "-", ":");
            Utils::replaceAll(cpe, "$(VERSION_UPDATE_HYPHEN)", versionWithHyphen);

            m_osDataCache.cpeName += Utils::toLowerCase(cpe);
        }
        else
        {
            // Clear the cpeName if the OS is not supported
            m_osDataCache.cpeName.clear();
        }
    }

    /**
     * @brief Check if this is a full scan context based on indices.
     */
    void checkIfFullScanContext(const std::vector<std::string>& indices)
    {
        for (const auto& idx : indices)
        {
            if (idx == OS_INDEX || idx == HOTFIX_INDEX)
            {
                m_isFullScanContext = true;
                return;
            }
        }
    }

public:
    /**
     * @brief Default constructor.
     */
    TScanContext() = default;

    /**
     * @brief Constructor from inventory sync context.
     *
     * @param contextSync Inventory sync context.
     */
    explicit TScanContext(const Context& contextSync)
    {
        m_agentContextData.id = contextSync.agentId;
        m_agentContextData.name = contextSync.agentName;
        m_agentContextData.version = contextSync.agentVersion;

        checkIfFullScanContext(contextSync.indices);

        // Pre-allocate capacity for package context data
        if (m_isFullScanContext)
        {
            m_packageContextDataList.reserve(PKG_CAPACITY);
            m_detectedCVEs.reserve(PKG_CAPACITY / 10); // Estimate ~10% vulnerable
            m_ecsEvents.reserve(PKG_CAPACITY / 10);
        }
        else
        {
            m_packageContextDataList.reserve(PKG_CAPACITY / 10);
            m_detectedCVEs.reserve(PKG_CAPACITY / 100);
            m_ecsEvents.reserve(PKG_CAPACITY / 100);
        }
    }

    /**
     * @brief Destructor.
     */
    ~TScanContext() = default;

    // Prevent copying (use move semantics)
    TScanContext(const TScanContext&) = delete;
    TScanContext& operator=(const TScanContext&) = delete;

    // Allow moving
    TScanContext(TScanContext&&) noexcept = default;
    TScanContext& operator=(TScanContext&&) noexcept = default;

    // =============== Agent Context Data Accessors ================

    /**
     * @brief Get agent ID.
     * @return Agent ID.
     */
    std::string_view agentId() const noexcept
    {
        return m_agentContextData.id;
    }

    /**
     * @brief Get agent name.
     * @return Agent name.
     */
    std::string_view agentName() const noexcept
    {
        return m_agentContextData.name;
    }

    /**
     * @brief Get agent version.
     * @return Agent version.
     */
    std::string_view agentVersion() const noexcept
    {
        return m_agentContextData.version;
    }

    /**
     * @brief Get agent IP.
     * @return Agent IP.
     */
    std::string_view agentIP() const noexcept
    {
        return m_agentContextData.ip;
    }

    /**
     * @brief Set agent IP.
     * @param ip Agent IP address.
     */
    void setAgentIP(std::string_view ip)
    {
        m_agentContextData.ip = ip;
    }

    // =============== Package Context Data Accessors ================

    /**
     * @brief Get package context data at index.
     * @param index Package index.
     * @return Package context data and operation.
     */
    std::pair<PackageContextData, ElementOperation>& getPackageContextData(size_t index)
    {
        return m_packageContextDataList.at(index);
    }

    /**
     * @brief Get package context data at index (const version).
     * @param index Package index.
     * @return Package context data and operation.
     */
    const std::pair<PackageContextData, ElementOperation>& getPackageContextData(size_t index) const
    {
        return m_packageContextDataList.at(index);
    }

    /**
     * @brief Insert package context data.
     * @param packageData Package context data.
     * @param operation Element operation.
     */
    void addPackageToContext(const PackageContextData& packageData, ElementOperation operation)
    {
        m_packageContextDataList.emplace_back(packageData, operation);
    }

    /**
     * @brief Insert package context data (move version).
     * @param packageData Package context data.
     * @param operation Element operation.
     */
    void addPackageToContext(PackageContextData&& packageData, ElementOperation operation)
    {
        m_packageContextDataList.emplace_back(std::move(packageData), operation);
    }

    /**
     * @brief Get package count.
     * @return Package count.
     */
    size_t packageCount() const noexcept
    {
        return m_packageContextDataList.size();
    }

    /**
     * @brief Clear all packages.
     */
    void clearPackages()
    {
        m_packageContextDataList.clear();
    }

    // =============== CVE Detection Results Management ================

    /**
     * @brief Add detected CVE to results.
     * @param detection CVE detection result.
     */
    void addDetectedCVE(CVEDetectionResult&& detection)
    {
        m_detectedCVEs.emplace(detection.cveId, std::move(detection));
    }

    /**
     * @brief Check if CVE already detected.
     * @param cveId CVE identifier.
     * @return True if CVE exists, false otherwise.
     */
    bool hasCVE(const std::string& cveId) const noexcept
    {
        return m_detectedCVEs.contains(cveId);
    }

    /**
     * @brief Remove CVE (e.g., solved by hotfix).
     * @param cveId CVE identifier.
     */
    void removeCVE(const std::string& cveId)
    {
        m_detectedCVEs.erase(cveId);
        m_ecsEvents.erase(cveId); // Also remove ECS event if exists
    }

    /**
     * @brief Get mutable access to detected CVEs (for updating).
     * @return Mutable reference to detected CVEs map.
     */
    std::unordered_map<std::string, CVEDetectionResult>& detectedCVEs() noexcept
    {
        return m_detectedCVEs;
    }

    /**
     * @brief Get read-only access to detected CVEs.
     * @return Const reference to detected CVEs map.
     */
    const std::unordered_map<std::string, CVEDetectionResult>& detectedCVEs() const noexcept
    {
        return m_detectedCVEs;
    }

    /**
     * @brief Get specific CVE detection result.
     * @param cveId CVE identifier.
     * @return Pointer to detection result, or nullptr if not found.
     */
    const CVEDetectionResult* getCVE(const std::string& cveId) const noexcept
    {
        auto it = m_detectedCVEs.find(cveId);
        return (it != m_detectedCVEs.end()) ? &it->second : nullptr;
    }

    /**
     * @brief Get specific CVE detection result (mutable).
     * @param cveId CVE identifier.
     * @return Pointer to detection result, or nullptr if not found.
     */
    CVEDetectionResult* getCVE(const std::string& cveId) noexcept
    {
        auto it = m_detectedCVEs.find(cveId);
        return (it != m_detectedCVEs.end()) ? &it->second : nullptr;
    }

    /**
     * @brief Count of detected CVEs.
     * @return Number of detected CVEs.
     */
    size_t cveCount() const noexcept
    {
        return m_detectedCVEs.size();
    }

    /**
     * @brief Clear all detected CVEs.
     */
    void clearCVEs()
    {
        m_detectedCVEs.clear();
    }

    // =============== ECS Events Management ================

    /**
     * @brief Store ECS event JSON for later dispatch.
     * @param cveId CVE identifier.
     * @param eventJSON Serialized ECS event JSON.
     */
    void addECSEvent(const std::string& cveId, std::string&& eventJSON)
    {
        m_ecsEvents.emplace(cveId, std::move(eventJSON));
    }

    /**
     * @brief Get all ECS events.
     * @return Const reference to ECS events map.
     */
    const std::unordered_map<std::string, std::string>& ecsEvents() const noexcept
    {
        return m_ecsEvents;
    }

    /**
     * @brief Get specific ECS event.
     * @param cveId CVE identifier.
     * @return Pointer to ECS event JSON, or nullptr if not found.
     */
    const std::string* getECSEvent(const std::string& cveId) const noexcept
    {
        auto it = m_ecsEvents.find(cveId);
        return (it != m_ecsEvents.end()) ? &it->second : nullptr;
    }

    /**
     * @brief Count of ECS events.
     * @return Number of ECS events.
     */
    size_t ecsEventCount() const noexcept
    {
        return m_ecsEvents.size();
    }

    /**
     * @brief Clear all ECS events.
     */
    void clearECSEvents()
    {
        m_ecsEvents.clear();
    }

    // =============== OS Context Data Accessors ================

    /**
     * @brief Get OS hostname.
     * @return OS hostname.
     */
    std::string_view osHostName() const noexcept
    {
        return m_osDataCache.hostName;
    }

    /**
     * @brief Get OS architecture.
     * @return OS architecture.
     */
    std::string_view osArchitecture() const noexcept
    {
        return m_osDataCache.architecture;
    }

    /**
     * @brief Get OS name.
     * @return OS name.
     */
    std::string_view osName() const noexcept
    {
        return m_osDataCache.name;
    }

    /**
     * @brief Get OS version.
     * @return OS version.
     */
    std::string_view osVersion() const noexcept
    {
        return m_osDataCache.version;
    }

    /**
     * @brief Get OS code name.
     * @return OS code name.
     */
    std::string_view osCodeName() const noexcept
    {
        return m_osDataCache.codeName;
    }

    /**
     * @brief Get OS major version.
     * @return OS major version.
     */
    std::string_view osMajorVersion() const noexcept
    {
        return m_osDataCache.majorVersion;
    }

    /**
     * @brief Get OS minor version.
     * @return OS minor version.
     */
    std::string_view osMinorVersion() const noexcept
    {
        return m_osDataCache.minorVersion;
    }

    /**
     * @brief Get OS patch version.
     * @return OS patch version.
     */
    std::string_view osPatch() const noexcept
    {
        return m_osDataCache.patch;
    }

    /**
     * @brief Get OS build number.
     * @return OS build number.
     */
    std::string_view osBuild() const noexcept
    {
        return m_osDataCache.build;
    }

    /**
     * @brief Get OS platform.
     * @return OS platform.
     */
    std::string_view osPlatform() const noexcept
    {
        return m_osDataCache.platform;
    }

    /**
     * @brief Get OS kernel system name.
     * @return OS kernel system name.
     */
    std::string_view osKernelSysName() const noexcept
    {
        return m_osDataCache.sysName;
    }

    /**
     * @brief Get OS kernel release.
     * @return OS kernel release.
     */
    std::string_view osKernelRelease() const noexcept
    {
        return m_osDataCache.kernelRelease;
    }

    /**
     * @brief Get OS kernel version.
     * @return OS kernel version.
     */
    std::string_view osKernelVersion() const noexcept
    {
        return m_osDataCache.kernelVersion;
    }

    /**
     * @brief Get OS release.
     * @return OS release.
     */
    std::string_view osRelease() const noexcept
    {
        return m_osDataCache.release;
    }

    /**
     * @brief Get OS display version.
     * @return OS display version.
     */
    std::string_view osDisplayVersion() const noexcept
    {
        return m_osDataCache.displayVersion;
    }

    /**
     * @brief Get OS CPE name.
     * @return OS CPE name.
     */
    std::string_view osCPEName() const noexcept
    {
        return m_osDataCache.cpeName;
    }

    /**
     * @brief Set OS data cache.
     * @param osData OS data.
     */
    void setOSData(const Os& osData)
    {
        m_osDataCache = osData;
        buildCPEName();
    }

    // =============== Cluster and Manager Data ================

    /**
     * @brief Get cluster name.
     * @return Cluster name.
     */
    std::string_view clusterName() const noexcept
    {
        static const std::string clusterName = PolicyManager::instance().getClusterName();
        return clusterName;
    }

    /**
     * @brief Get cluster node name.
     * @return Cluster node name.
     */
    std::string_view clusterNodeName() const noexcept
    {
        static const std::string clusterNodeName = PolicyManager::instance().getClusterNodeName();
        return clusterNodeName;
    }

    /**
     * @brief Get manager name.
     * @return Manager name.
     */
    std::string_view managerName() const noexcept
    {
        return TGlobalData::instance().managerName();
    }

    // =============== Scan Configuration ================

    /**
     * @brief Get the affected component type.
     * @return Affected component type.
     */
    AffectedComponentType affectedComponentType() const noexcept
    {
        return m_affectedComponentType;
    }

    /**
     * @brief Set the affected component type.
     * @param type Affected component type.
     */
    void setAffectedComponentType(AffectedComponentType type) noexcept
    {
        m_affectedComponentType = type;
    }

    /**
     * @brief Check if this is a full scan context.
     * @return True if full scan, false otherwise.
     */
    bool isFullScanContext() const noexcept
    {
        return m_isFullScanContext;
    }

    /**
     * @brief Check if inventory is empty.
     * @return True if empty, false otherwise.
     */
    bool isInventoryEmpty() const noexcept
    {
        return m_isInventoryEmpty;
    }

    /**
     * @brief Set inventory empty flag.
     * @param empty Inventory empty flag.
     */
    void setInventoryEmpty(bool empty) noexcept
    {
        m_isInventoryEmpty = empty;
    }

    /**
     * @brief Check if this is the first scan.
     * @return True if first scan, false otherwise.
     */
    bool isFirstScan() const noexcept
    {
        return m_isFirstScan;
    }

    /**
     * @brief Set first scan flag.
     * @param first First scan flag.
     */
    void setFirstScan(bool first) noexcept
    {
        m_isFirstScan = first;
    }

    /**
     * @brief Check if this is a no-index scan.
     * @return True if no-index, false otherwise.
     */
    bool isNoIndex() const noexcept
    {
        return m_noIndex;
    }

    /**
     * @brief Set no-index flag.
     * @param noIndex No-index flag.
     */
    void setNoIndex(bool noIndex) noexcept
    {
        m_noIndex = noIndex;
    }

    // =============== Public Data Members (Legacy Support) ================

    /**
     * @brief Feed source information.
     *
     * @note Use @see VulnerabilitySource enum to access each field.
     * @note Pair with CNA/ADP base name and CNA/ADP expanded name.
     */
    std::pair<std::string, std::string> m_vulnerabilitySource;

    /**
     * @brief Elements for alerts (legacy).
     * @deprecated Use m_detectedCVEs instead.
     */
    std::unordered_map<std::string, nlohmann::json> m_alerts;

    /**
     * @brief Elements matching the query (legacy).
     * @deprecated Data now stored in CVEDetectionResult.
     */
    std::unordered_map<std::string, MatchCondition> m_matchConditions;

    /**
     * @brief Detection source for CVEs (legacy).
     * @deprecated Data now stored in CVEDetectionResult.cnaSource.
     */
    std::unordered_map<std::string, std::string> m_cnaDetectionSource;

    /**
     * @brief Agent data list for re-scan all agents event.
     */
    std::vector<AgentContextData> m_agents;

    /**
     * @brief Agent data list with exceptions during re-scan all agents event.
     */
    std::vector<AgentContextData> m_agentsWithIncompletedScan;
};

using ScanContext = TScanContext<>;

#endif // _SCAN_CONTEXT_HPP
