/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_CONTEXT_HPP
#define _SCAN_CONTEXT_HPP

#include "../../inventory_sync/src/context.hpp"
#include "globalData.hpp"
#include "logging_helper.h"
#include "stringHelper.h"
#include <cstdint>
#include <functional>
#include <iostream>
#include <json.hpp>
#include <memory>
#include <string>
#include <string_view>
#include <unordered_map>
#include <vector>

#ifndef WM_VULNSCAN_LOGTAG
#define WM_VULNSCAN_LOGTAG "wazuh-modulesd:vulnerability-scanner"
#endif

constexpr std::string_view OS_INDEX = "wazuh-states-inventory-system";
constexpr std::string_view HOTFIX_INDEX = "wazuh-states-inventory-hotfixes";
constexpr std::string_view PACKAGE_INDEX = "wazuh-states-inventory-packages";
constexpr auto PKG_CAPACITY = 1000;

/**
 * @brief Vulnerability source.
 */
enum VulnerabilitySource : uint8_t
{
    ADP_BASE = 0,
    ADP_EXPANDED = 1
};

/**
 * @brief Scanner type.
 */
enum class ScannerType : uint8_t
{
    Unknown = 0,
    PackagesDelta = 1,
    OS = 2,
    FirstFullScan = 3,
    FullScan = 4
};

/**
 * @brief The affected component type is used to determine what type of data is affected in the system.
 */
enum class AffectedComponentType : uint8_t
{
    Unknown = 0,
    Package = 1,
    Os = 2,
    Hotfix = 3,
    Agent = 4,
};

/**
 * @brief Match rule condition for version matching.
 */
enum class MatchRuleCondition : uint8_t
{
    Unknown = 0,
    Equal = 1,
    NotEqual = 2,
    GreaterThan = 3,
    GreaterThanOrEqual = 4,
    LessThan = 5,
    LessThanOrEqual = 6,
    Contains = 7,
    NotContains = 8,
    StartsWith = 9,
    EndsWith = 10,
    DefaultStatus = 11,
};

/**
 * @brief Element operation type.
 */
enum class ElementOperation : uint8_t
{
    Unknown = 0,
    Delete = 1, ///< Element deletion
    Upsert = 2, ///< Insert or update
};

/**
 * @brief Agent data structure.
 */
struct AgentContextData
{
    std::string id;                  ///< Agent ID.
    std::string name;                ///< Agent name.
    std::string version;             ///< Agent version.
    std::string ip;                  ///< Agent IP.
    std::string hostArchitecture;    ///< agent.host.architecture.
    std::string hostHostname;        ///< agent.host.hostname.
    std::string hostOsName;          ///< agent.host.os.name.
    std::string hostOsPlatform;      ///< agent.host.os.platform.
    std::string hostOsType;          ///< agent.host.os.type.
    std::string hostOsVersion;       ///< agent.host.os.version.
    std::vector<std::string> groups; ///< agent.groups.
};

/**
 * @brief Package context data from inventory sync.
 */
struct PackageContextData final
{
    ElementOperation operation {ElementOperation::Unknown}; ///< Element operation.
    std::string name;                                       ///< Package name.
    std::string version;                                    ///< Package version.
    std::string format;                                     ///< Package format (deb, rpm, etc.).
    std::string source;                                     ///< Package source.
    std::string location;                                   ///< Package location/path.
    std::string architecture;                               ///< Package architecture.
    std::string multiarch;                                  ///< Package multiarch.
    std::string priority;                                   ///< Package priority.
    uint64_t size {0};                                      ///< Package size in bytes.
    std::string vendor;                                     ///< Package vendor.
    std::string install_time;                               ///< Package install time.
    std::string description;                                ///< Package description.
    std::string groups;                                     ///< Package groups / category.
};

/**
 * @brief Hotfix context data from inventory sync.
 *
 * The list of hotfixes in the ScanContext represents the set of hotfixes
 * currently installed on the system for the scan session.
 * Only used in the full scan process.
 */
struct HotfixContextData final
{
    std::string hotfixName; ///< Hotfix identifier (e.g. KB...).
};

/**
 * @brief Os context data from inventory sync.
 *
 * This structure is initially populated with the basic fields from the Start
 * message (Context) and is completed with the DataValue/DataContext from the
 * OS index when available.
 */
struct OsContextData final
{
    std::string item_id;        ///< OS item ID.
    std::string hostName;       ///< Hostname of the agent.
    std::string architecture;   ///< Architecture of the agent.
    std::string name;           ///< Name of operating system.
    std::string codeName;       ///< Code name of the operating system.
    std::string majorVersion;   ///< Major version of the operating system.
    std::string minorVersion;   ///< Minor version of the operating system.
    std::string patch;          ///< Patch of the operating system.
    std::string build;          ///< Build of the operating system.
    std::string platform;       ///< Platform of the operating system.
    std::string version;        ///< Version of the operating system.
    std::string release;        ///< Release of the operating system.
    std::string displayVersion; ///< Display version of the operating system.
    std::string sysName;        ///< System name of the operating system (e.g. linux, windows).
    std::string kernelVersion;  ///< Version of the kernel operating system.
    std::string kernelRelease;  ///< Release of the kernel operating system.
    std::string cpeName;        ///< CPE name of the operating system.
};

/**
 * @brief OS deleted context data.
 *
 * Used to track the OS that has been removed (operation == deleted).
 * For deleted OS entries we only care about the item_id to later query
 * existing state documents in the index.
 */
struct OsDeletedData final
{
    std::string item_id;      ///< Item ID of the deleted OS state.
    std::string name;         ///< Name of the deleted operating system.
    std::string version;      ///< Version of the deleted operating system.
    std::string platform;     ///< Platform of the deleted operating system.
    std::string architecture; ///< Architecture of the deleted operating system.
    std::string codeName;     ///< Codename / description of the deleted operating system.
};

struct Vulnerability
{
    std::string id;                  // vulnerability.id
    std::string classification;      // vulnerability.classification
    std::string description;         // vulnerability.description
    std::string detected_at;         // vulnerability.detected_at
    std::string enumeration {"CVE"}; // vulnerability.enumeration
    std::string published_at;        // vulnerability.published_at
    std::string reference;           // vulnerability.reference
    std::string severity;            // vulnerability.severity
    std::string category;            // vulnerability.category
    bool under_evaluation {false};   // vulnerability.under_evaluation

    std::string report_id; // vulnerability.report_id

    struct Score
    {
        double base {0.0};          // vulnerability.score.base
        double environmental {0.0}; // vulnerability.score.environmental
        double temporal {0.0};      // vulnerability.score.temporal
        std::string version;        // vulnerability.score.version
    } score;

    struct Scanner
    {
        std::string vendor {"Wazuh"}; // vulnerability.scanner.vendor
        std::string source;           // vulnerability.scanner.source
        std::string reference;        // vulnerability.scanner.reference
        std::string condition;        // vulnerability.scanner.condition
    } scanner;
};

/**
 * @brief Vulnerability detection result for a single CVE.
 * Replaces nlohmann::json for 10× better performance.
 * Contains all data needed for ECS event generation.
 */
struct CVEDetectionResult
{
    // ========== CVE Detection Metadata ==========
    std::string cveId;                                     ///< CVE identifier
    std::string cnaSource;                                 ///< CNA that provided this detection
    std::string matchCondition;                            ///< Version condition that matched
    MatchRuleCondition conditionType;                      ///< Type of match
    AffectedComponentType componentType;                   ///< What type of component is affected
    std::string feedOffset;                                ///< Description offset for versioning
    ElementOperation operation {ElementOperation::Upsert}; ///< Operation type

    // ========== State document identifier ==========
    // Built as:
    //  - Package: <agentid>_<package_id>_<cveid>
    //  - OS:      <agentid>_<osname>_<osversion>_<cveid>
    std::string detectionIdBase;

    // ========== Vulnerability Information (for ECS event building) ==========
    Vulnerability vulnerability; ///< Vulnerability details
};

/**
 * @brief ScanContext structure.
 * Contains all data needed for vulnerability scanning and event generation.
 *
 * @tparam TOsDataCache OS data cache type.
 * @tparam TGlobalData Global data type.
 */
template<typename TOsDataCache = void, typename TGlobalData = GlobalData>
struct TScanContext final
{
private:
    inline static std::string s_clusterName {};
    inline static std::string s_clusterNodeName {};
    inline static bool s_clusterIsWorker {false};

    /**
     * @brief OS context cache.
     */
    OsContextData m_osContextDataCache {};

    /**
     * @brief OS deleted context data.
     *
     * When an OS dataValue is received with operation == deleted, we do not
     * overwrite the current OS cache. Instead, we only store the item_id of
     * the deleted OS here so we can later query the index for its state.
     */
    OsDeletedData m_osDeletedData {};

    /**
     * @brief Element type to process.
     */
    AffectedComponentType m_affectedComponentType {AffectedComponentType::Unknown};

    /**
     * @brief Agent context data, populated with the Start message data (Context).
     */
    AgentContextData m_agentContextData {};

    /**
     * @brief Package context data list (detectionIdBase -> PackageContextData).
     */
    std::unordered_map<std::string, PackageContextData> m_packageContextDataList {};

    /**
     * @brief Hotfix context data list, populated with hotfix data from inventory sync.
     *
     * This list represents the hotfixes currently installed on the agent.
     */
    std::vector<HotfixContextData> m_hotfixContextDataList {};

    /**
     * @brief Detected vulnerabilities (unique detection ID → detection details).
     *
     * The key of the map is not just the cveId, but a unique identifier per
     * detection (for example, an _id derived from agentId + hash(pkg) + cveId).
     * This allows storing multiple detections of the same CVE in different
     * packages of the same agent.
     */
    std::unordered_map<std::string, CVEDetectionResult> m_detectedCVEs;

    /**
     * @brief Serialized ECS events ready for indexing.
     * Stored as JSON strings (final format for indexer).
     *
     * The keys of this map must match those of m_detectedCVEs
     * (same detectionId).
     */
    std::unordered_map<std::string, std::string> m_ecsEvents;

    /**
     * @brief Is a full scan context.
     */
    bool m_isFullScanContext {false};

    /**
     * @brief Variable to store if the inventory is empty before an integrity clear event.
     */
    bool m_isInventoryEmpty {false};

    /**
     * @brief Variable to store if is the first scan for the agent.
     */
    bool m_isFirstScan {true};

    /**
     * @brief Variable to check if the scan is a no-index scan.
     */
    bool m_noIndex {false};

    /**
     * @brief Build CPE name for OS.
     */
    void buildCPEName()
    {
        const auto& osCpeMaps = TGlobalData::instance().osCpeMaps();

        m_osContextDataCache.cpeName = "cpe:/o:";

        std::string cpe;
        for (auto it = osCpeMaps.rbegin(); it != osCpeMaps.rend(); ++it)
        {
            if (m_osContextDataCache.name == it.key() || Utils::startsWith(m_osContextDataCache.name, it.key()) ||
                m_osContextDataCache.platform == it.key())
            {
                cpe = it.value();
                break;
            }
        }

        if (!cpe.empty())
        {
            // Replace variables in the CPE name
            Utils::replaceAll(cpe, "$(MAJOR_VERSION)", m_osContextDataCache.majorVersion);
            Utils::replaceAll(cpe, "$(MINOR_VERSION)", m_osContextDataCache.minorVersion);
            Utils::replaceAll(cpe, "$(DISPLAY_VERSION)", m_osContextDataCache.displayVersion);
            Utils::replaceAll(cpe, "$(VERSION)", m_osContextDataCache.version);
            Utils::replaceAll(cpe, "$(RELEASE)", m_osContextDataCache.release);

            // For SUSE, replace hyphen with colon in version
            auto versionWithHyphen = m_osContextDataCache.version;
            Utils::replaceAll(versionWithHyphen, "-", ":");
            Utils::replaceAll(cpe, "$(VERSION_UPDATE_HYPHEN)", versionWithHyphen);

            m_osContextDataCache.cpeName += Utils::toLowerCase(cpe);
        }
        else
        {
            // Clear the cpeName if the OS is not supported
            m_osContextDataCache.cpeName.clear();
        }
    }

    /**
     * @brief Check if this is a full scan context based on indices.
     */
    void checkIfFullScanContext(const std::vector<std::string>& indices)
    {
        for (const auto& idx : indices)
        {
            if (idx == OS_INDEX || idx == HOTFIX_INDEX)
            {
                m_isFullScanContext = true;
                return;
            }
        }
    }

public:
    /**
     * @brief Default constructor.
     */
    TScanContext() = default;

    /**
     * @brief Constructor from inventory sync context (Start message).
     *
     * This constructor:
     *  - Fills basic agent data.
     *  - Fills basic OS data (the ones that come in Start/Context).
     *  - Determines if the context corresponds to a full scan.
     *  - Pre-reserves capacity for internal containers.
     */
    explicit TScanContext(const Context& contextSync)
    {
        // Agent basic data from Start.
        m_agentContextData.id = contextSync.agentId;
        m_agentContextData.name = contextSync.agentName;
        m_agentContextData.version = contextSync.agentVersion;
        m_agentContextData.hostArchitecture = contextSync.architecture;
        m_agentContextData.hostHostname = contextSync.hostname;
        m_agentContextData.hostOsName = contextSync.osname;
        m_agentContextData.hostOsPlatform = contextSync.osplatform;
        m_agentContextData.hostOsType = contextSync.ostype;
        m_agentContextData.hostOsVersion = contextSync.osversion;
        m_agentContextData.groups = contextSync.groups;

        // Basic OS data from Start (may be partially completed later by OS DataValue/DataContext).
        m_osContextDataCache.hostName = contextSync.hostname;
        m_osContextDataCache.architecture = contextSync.architecture;
        m_osContextDataCache.name = contextSync.osname;
        m_osContextDataCache.platform = contextSync.osplatform;
        m_osContextDataCache.sysName = contextSync.ostype;
        m_osContextDataCache.version = contextSync.osversion;
        m_osContextDataCache.displayVersion = contextSync.osversion;

        checkIfFullScanContext(contextSync.indices);

        // Pre-allocate capacity for package and hotfix context data
        if (m_isFullScanContext)
        {
            m_packageContextDataList.reserve(PKG_CAPACITY);
            m_hotfixContextDataList.reserve(PKG_CAPACITY / 10);
            m_detectedCVEs.reserve(PKG_CAPACITY / 10); // Estimate ~10% vulnerable
            m_ecsEvents.reserve(PKG_CAPACITY / 10);
        }
        else
        {
            m_packageContextDataList.reserve(PKG_CAPACITY / 10);
            m_hotfixContextDataList.reserve(PKG_CAPACITY / 20);
            m_detectedCVEs.reserve(PKG_CAPACITY / 100);
            m_ecsEvents.reserve(PKG_CAPACITY / 100);
        }

        // Build initial CPE with the information we already know from Start.
        buildCPEName();
    }

    /**
     * @brief Destructor.
     */
    ~TScanContext() = default;

    // Prevent copying (use move semantics)
    TScanContext(const TScanContext&) = delete;
    TScanContext& operator=(const TScanContext&) = delete;

    // Allow moving
    TScanContext(TScanContext&&) noexcept = default;
    TScanContext& operator=(TScanContext&&) noexcept = default;

    // =============== Agent Context Data Accessors ================

    /**
     * @brief Get agent ID.
     * @return Agent ID.
     */
    std::string_view agentId() const noexcept
    {
        return m_agentContextData.id;
    }

    /**
     * @brief Get agent name.
     * @return Agent name.
     */
    std::string_view agentName() const noexcept
    {
        return m_agentContextData.name;
    }

    /**
     * @brief Get agent version.
     * @return Agent version.
     */
    std::string_view agentVersion() const noexcept
    {
        return m_agentContextData.version;
    }

    /**
     * @brief Get agent IP.
     * @return Agent IP.
     */
    std::string_view agentIP() const noexcept
    {
        return m_agentContextData.ip;
    }

    /**
     * @brief Get agent host architecture.
     */
    std::string_view agentHostArchitecture() const noexcept
    {
        return m_agentContextData.hostArchitecture;
    }

    /**
     * @brief Get agent host hostname.
     */
    std::string_view agentHostName() const noexcept
    {
        return m_agentContextData.hostHostname;
    }

    /**
     * @brief Get agent host OS name.
     */
    std::string_view agentHostOsName() const noexcept
    {
        return m_agentContextData.hostOsName;
    }

    /**
     * @brief Get agent host OS platform.
     */
    std::string_view agentHostOsPlatform() const noexcept
    {
        return m_agentContextData.hostOsPlatform;
    }

    /**
     * @brief Get agent host OS type.
     */
    std::string_view agentHostOsType() const noexcept
    {
        return m_agentContextData.hostOsType;
    }

    /**
     * @brief Get agent host OS version.
     */
    std::string_view agentHostOsVersion() const noexcept
    {
        return m_agentContextData.hostOsVersion;
    }

    /**
     * @brief Get agent groups.
     */
    const std::vector<std::string>& agentGroups() const noexcept
    {
        return m_agentContextData.groups;
    }

    /**
     * @brief Set agent IP.
     * @param ip Agent IP address.
     */
    void setAgentIP(std::string_view ip)
    {
        m_agentContextData.ip = ip;
    }

    // =============== Package Context Data Accessors ================

    /**
     * @brief Build base detection id for a package (agentId + package inventory id).
     */
    std::string buildPackageDetectionIdBase(std::string_view packageId) const
    {
        std::string id;
        id.reserve(m_agentContextData.id.size() + 1 + packageId.size());
        id.append(m_agentContextData.id);
        id.push_back('_');
        id.append(packageId);
        return id;
    }

    /**
     * @brief Extract detectionIdBase from a CVE detectionId (strip trailing _<cveId>).
     */
    static std::string detectionIdBaseFromDetection(const std::string& detectionId)
    {
        const auto pos = detectionId.rfind('_');
        if (pos == std::string::npos)
        {
            return detectionId;
        }
        return detectionId.substr(0, pos);
    }

    /**
     * @brief Get package context entry at index.
     */
    const std::unordered_map<std::string, PackageContextData>& packages() const noexcept
    {
        return m_packageContextDataList;
    }

    /**
     * @brief Insert package context data.
     * @param packageData Package context data.
     * @param operation Element operation.
     */
    void
    addPackageToContext(std::string_view detectionIdBase, PackageContextData packageData, ElementOperation operation)
    {
        packageData.operation = operation;
        m_packageContextDataList.emplace(std::string {detectionIdBase}, std::move(packageData));
    }

    /**
     * @brief Get package count.
     * @return Package count.
     */
    size_t packageCount() const noexcept
    {
        return m_packageContextDataList.size();
    }

    /**
     * @brief Find package context by detectionId (agent + package id + cve).
     * @return Pointer to entry or nullptr if not found.
     */
    const PackageContextData* findPackageByDetectionId(const std::string& detectionId) const noexcept
    {
        const auto base = detectionIdBaseFromDetection(detectionId);
        return findPackageByDetectionBase(base);
    }

    /**
     * @brief Find package context by detectionIdBase (agent + package id).
     * @return Pointer to entry or nullptr if not found.
     */
    const PackageContextData* findPackageByDetectionBase(const std::string& detectionIdBase) const noexcept
    {
        if (auto it = m_packageContextDataList.find(detectionIdBase); it != m_packageContextDataList.end())
        {
            return &it->second;
        }
        return nullptr;
    }

    /**
     * @brief Clear all packages.
     */
    void clearPackages()
    {
        m_packageContextDataList.clear();
    }

    // =============== Hotfix Context Data Accessors ================

    /**
     * @brief Get hotfix context data at index.
     * @param index Hotfix index.
     * @return Hotfix context data.
     */
    HotfixContextData& getHotfixContextData(size_t index)
    {
        return m_hotfixContextDataList.at(index);
    }

    /**
     * @brief Get hotfix context data at index (const version).
     * @param index Hotfix index.
     * @return Hotfix context data.
     */
    const HotfixContextData& getHotfixContextData(size_t index) const
    {
        return m_hotfixContextDataList.at(index);
    }

    /**
     * @brief Get the hotfix count of the context data.
     * @return Hotfix count.
     */
    size_t hotfixCount() const noexcept
    {
        return m_hotfixContextDataList.size();
    }

    /**
     * @brief Get read-only access to the full hotfix list.
     */
    const std::vector<HotfixContextData>& hotfixes() const noexcept
    {
        return m_hotfixContextDataList;
    }

    /**
     * @brief Insert hotfix context data.
     * @param hotfixData Hotfix context data.
     */
    void addHotfixToContext(const HotfixContextData& hotfixData)
    {
        m_hotfixContextDataList.emplace_back(hotfixData);
    }

    /**
     * @brief Insert hotfix context data (move version).
     * @param hotfixData Hotfix context data.
     */
    void addHotfixToContext(HotfixContextData&& hotfixData)
    {
        m_hotfixContextDataList.emplace_back(std::move(hotfixData));
    }

    /**
     * @brief Clear all hotfix entries.
     */
    void clearHotfixes()
    {
        m_hotfixContextDataList.clear();
    }

    // =============== CVE Detection Results Management ================

    /**
     * @brief Add detected CVE to results.
     * @param detectionId Unique detection identifier (e.g. VD _id).
     * @param detection CVE detection result.
     */
    void addDetectedCVE(const std::string& detectionId, CVEDetectionResult&& detection)
    {
        m_detectedCVEs.emplace(detectionId, std::move(detection));
    }

    /**
     * @brief Check if a detection already exists.
     * @param detectionId Unique detection identifier.
     * @return True if detection exists, false otherwise.
     */
    bool hasCVE(const std::string& detectionId) const noexcept
    {
        return m_detectedCVEs.contains(detectionId);
    }

    /**
     * @brief Remove CVE detection (e.g., solved by hotfix).
     * @param detectionId Unique detection identifier.
     */
    void removeCVE(const std::string& detectionId)
    {
        m_detectedCVEs.erase(detectionId);
        m_ecsEvents.erase(detectionId); // Also remove ECS event if exists
    }

    /**
     * @brief Get mutable access to detected CVEs (for updating).
     * @return Mutable reference to detected CVEs map.
     */
    std::unordered_map<std::string, CVEDetectionResult>& detectedCVEs() noexcept
    {
        return m_detectedCVEs;
    }

    /**
     * @brief Get read-only access to detected CVEs.
     * @return Const reference to detected CVEs map.
     */
    const std::unordered_map<std::string, CVEDetectionResult>& detectedCVEs() const noexcept
    {
        return m_detectedCVEs;
    }

    /**
     * @brief Get specific CVE detection result.
     * @param detectionId Unique detection identifier.
     * @return Pointer to detection result, or nullptr if not found.
     */
    const CVEDetectionResult* getCVE(const std::string& detectionId) const noexcept
    {
        auto it = m_detectedCVEs.find(detectionId);
        return (it != m_detectedCVEs.end()) ? &it->second : nullptr;
    }

    /**
     * @brief Get specific CVE detection result (mutable).
     * @param detectionId Unique detection identifier.
     * @return Pointer to detection result, or nullptr if not found.
     */
    CVEDetectionResult* getCVE(const std::string& detectionId) noexcept
    {
        auto it = m_detectedCVEs.find(detectionId);
        return (it != m_detectedCVEs.end()) ? &it->second : nullptr;
    }

    /**
     * @brief Count of detected CVEs.
     * @return Number of detected CVEs.
     */
    size_t cveCount() const noexcept
    {
        return m_detectedCVEs.size();
    }

    /**
     * @brief Clear all detected CVEs.
     */
    void clearCVEs()
    {
        m_detectedCVEs.clear();
    }

    // =============== ECS Events Management ================

    /**
     * @brief Store ECS event JSON for later dispatch.
     * @param detectionId Unique detection identifier (same key as m_detectedCVEs).
     * @param eventJSON Serialized ECS event JSON.
     */
    void addECSEvent(const std::string& detectionId, std::string&& eventJSON)
    {
        m_ecsEvents.emplace(detectionId, std::move(eventJSON));
    }

    /**
     * @brief Get all ECS events.
     * @return Const reference to ECS events map.
     */
    const std::unordered_map<std::string, std::string>& ecsEvents() const noexcept
    {
        return m_ecsEvents;
    }

    /**
     * @brief Get specific ECS event.
     * @param detectionId Unique detection identifier.
     * @return Pointer to ECS event JSON, or nullptr if not found.
     */
    const std::string* getECSEvent(const std::string& detectionId) const noexcept
    {
        auto it = m_ecsEvents.find(detectionId);
        return (it != m_ecsEvents.end()) ? &it->second : nullptr;
    }

    /**
     * @brief Count of ECS events.
     * @return Number of ECS events.
     */
    size_t ecsEventCount() const noexcept
    {
        return m_ecsEvents.size();
    }

    /**
     * @brief Clear all ECS events.
     */
    void clearECSEvents()
    {
        m_ecsEvents.clear();
    }

    // =============== OS Context Data Accessors ================

    /**
     * @brief Get OS item ID.
     * @return OS item ID.
     */
    std::string_view osItemId() const noexcept
    {
        return m_osContextDataCache.item_id;
    }

    /**
     * @brief Get OS hostname.
     * @return OS hostname.
     */
    std::string_view osHostName() const noexcept
    {
        return m_osContextDataCache.hostName;
    }

    /**
     * @brief Get OS architecture.
     * @return OS architecture.
     */
    std::string_view osArchitecture() const noexcept
    {
        return m_osContextDataCache.architecture;
    }

    /**
     * @brief Get OS name.
     * @return OS name.
     */
    std::string_view osName() const noexcept
    {
        return m_osContextDataCache.name;
    }

    /**
     * @brief Get OS version.
     * @return OS version.
     */
    std::string_view osVersion() const noexcept
    {
        return m_osContextDataCache.version;
    }

    /**
     * @brief Get OS code name.
     * @return OS code name.
     */
    std::string_view osCodeName() const noexcept
    {
        return m_osContextDataCache.codeName;
    }

    /**
     * @brief Get OS major version.
     * @return OS major version.
     */
    std::string_view osMajorVersion() const noexcept
    {
        return m_osContextDataCache.majorVersion;
    }

    /**
     * @brief Get OS minor version.
     * @return OS minor version.
     */
    std::string_view osMinorVersion() const noexcept
    {
        return m_osContextDataCache.minorVersion;
    }

    /**
     * @brief Get OS patch version.
     * @return OS patch version.
     */
    std::string_view osPatch() const noexcept
    {
        return m_osContextDataCache.patch;
    }

    /**
     * @brief Get OS build number.
     * @return OS build number.
     */
    std::string_view osBuild() const noexcept
    {
        return m_osContextDataCache.build;
    }

    /**
     * @brief Build a human friendly OS full name (name + version or codename).
     */
    std::string buildOSFullName() const
    {
        std::string fullName;
        fullName.reserve(64);
        fullName.append(osName());
        fullName.append(" ");
        fullName.append(osPlatform() == "darwin" ? osCodeName() : osVersion());
        return fullName;
    }

    /**
     * @brief Build an OS version string "major.minor.patch.build".
     */
    std::string buildOSVersion() const
    {
        std::string version;
        version.reserve(32);
        version.append(osMajorVersion());

        if (!osMinorVersion().empty())
        {
            version.append(".");
            version.append(osMinorVersion());
        }
        if (!osPatch().empty())
        {
            version.append(".");
            version.append(osPatch());
        }
        if (!osBuild().empty())
        {
            version.append(".");
            version.append(osBuild());
        }

        return version;
    }

    /**
     * @brief Get OS platform.
     * @return OS platform.
     */
    std::string_view osPlatform() const noexcept
    {
        return m_osContextDataCache.platform;
    }

    /**
     * @brief Get OS kernel system name.
     * @return OS kernel system name.
     */
    std::string_view osKernelSysName() const noexcept
    {
        return m_osContextDataCache.sysName;
    }

    /**
     * @brief Get OS kernel release.
     * @return OS kernel release.
     */
    std::string_view osKernelRelease() const noexcept
    {
        return m_osContextDataCache.kernelRelease;
    }

    /**
     * @brief Get OS kernel version.
     * @return OS kernel version.
     */
    std::string_view osKernelVersion() const noexcept
    {
        return m_osContextDataCache.kernelVersion;
    }

    /**
     * @brief Get OS release.
     * @return OS release.
     */
    std::string_view osRelease() const noexcept
    {
        return m_osContextDataCache.release;
    }

    /**
     * @brief Get OS display version.
     * @return OS display version.
     */
    std::string_view osDisplayVersion() const noexcept
    {
        return m_osContextDataCache.displayVersion;
    }

    /**
     * @brief Get OS CPE name.
     * @return OS CPE name.
     */
    std::string_view osCPEName() const noexcept
    {
        return m_osContextDataCache.cpeName;
    }

    /**
     * @brief Set OS data cache (replaces and recomputes CPE).
     * @param osData OS data.
     */
    void setOSData(const OsContextData& osData)
    {
        m_osContextDataCache = osData;
        buildCPEName();
    }

    // =============== OS Deleted Data Accessors ================

    /**
     * @brief Set deleted OS data (basic fields used in package section for OS delta delete).
     * @param osData OS data associated to the delete operation.
     */
    void setDeletedOSData(const OsContextData& osData)
    {
        m_osDeletedData.item_id = osData.item_id;
        m_osDeletedData.name = osData.name;
        m_osDeletedData.version = osData.version;
        m_osDeletedData.platform = osData.platform;
        m_osDeletedData.architecture = osData.architecture;
        m_osDeletedData.codeName = osData.codeName;
    }

    /**
     * @brief Get deleted OS item_id.
     * @return Item ID of the deleted OS state.
     */
    std::string_view deletedOSItemId() const noexcept
    {
        return m_osDeletedData.item_id;
    }

    /**
     * @brief Check if a deleted OS item_id has been set.
     * @return True if there is a deleted OS item ID, false otherwise.
     */
    bool hasDeletedOSItemId() const noexcept
    {
        return !m_osDeletedData.item_id.empty();
    }

    /**
     * @brief Get deleted OS name.
     */
    std::string_view deletedOSName() const noexcept
    {
        return m_osDeletedData.name;
    }

    /**
     * @brief Get deleted OS version.
     */
    std::string_view deletedOSVersion() const noexcept
    {
        return m_osDeletedData.version;
    }

    /**
     * @brief Get deleted OS platform.
     */
    std::string_view deletedOSPlatform() const noexcept
    {
        return m_osDeletedData.platform;
    }

    /**
     * @brief Get deleted OS architecture.
     */
    std::string_view deletedOSArchitecture() const noexcept
    {
        return m_osDeletedData.architecture;
    }

    /**
     * @brief Get deleted OS codename.
     */
    std::string_view deletedOSCodeName() const noexcept
    {
        return m_osDeletedData.codeName;
    }

    // =============== Cluster and Manager Data ================

    /**
     * @brief Get cluster name.
     * @return Cluster name.
     */
    std::string_view clusterName() const noexcept
    {
        return s_clusterName;
    }

    /**
     * @brief Get cluster node name.
     * @return Cluster node name.
     */
    std::string_view clusterNodeName() const noexcept
    {
        return s_clusterNodeName;
    }

    /**
     * @brief Get cluster node role.
     * @return True if this node is a worker, false if master/single-node.
     */
    bool clusterIsWorker() const noexcept
    {
        return s_clusterIsWorker;
    }

    /**
     * @brief Get manager name.
     * @return Manager name.
     */
    std::string_view managerName() const noexcept
    {
        return TGlobalData::instance().managerName();
    }

    /**
     * @brief Set cluster information for event enrichment.
     */
    static void setClusterInfo(std::string clusterName, std::string clusterNodeName)
    {
        s_clusterName = std::move(clusterName);
        s_clusterNodeName = std::move(clusterNodeName);
    }

    /**
     * @brief Set cluster node role.
     */
    static void setClusterRole(bool isWorker)
    {
        s_clusterIsWorker = isWorker;
    }

    // =============== Scan Configuration ================

    /**
     * @brief Get the affected component type.
     * @return Affected component type.
     */
    AffectedComponentType affectedComponentType() const noexcept
    {
        return m_affectedComponentType;
    }

    /**
     * @brief Set the affected component type.
     * @param type Affected component type.
     */
    void setAffectedComponentType(AffectedComponentType type) noexcept
    {
        m_affectedComponentType = type;
    }

    /**
     * @brief Check if this is a full scan context.
     * @return True if full scan, false otherwise.
     */
    bool isFullScanContext() const noexcept
    {
        return m_isFullScanContext;
    }

    /**
     * @brief Check if inventory is empty.
     * @return True if empty, false otherwise.
     */
    bool isInventoryEmpty() const noexcept
    {
        return m_isInventoryEmpty;
    }

    /**
     * @brief Set inventory empty flag.
     * @param empty Inventory empty flag.
     */
    void setInventoryEmpty(bool empty) noexcept
    {
        m_isInventoryEmpty = empty;
    }

    /**
     * @brief Check if this is the first scan.
     * @return True if first scan, false otherwise.
     */
    bool isFirstScan() const noexcept
    {
        return m_isFirstScan;
    }

    /**
     * @brief Set first scan flag.
     * @param first First scan flag.
     */
    void setFirstScan(bool first) noexcept
    {
        m_isFirstScan = first;
    }

    /**
     * @brief Check if this is a no-index scan.
     * @return True if no-index, false otherwise.
     */
    bool isNoIndex() const noexcept
    {
        return m_noIndex;
    }

    /**
     * @brief Set no-index flag.
     * @param noIndex No-index flag.
     */
    void setNoIndex(bool noIndex) noexcept
    {
        m_noIndex = noIndex;
    }

    /**
     * @brief Feed source information.
     *
     * @note Use @see VulnerabilitySource enum to access each field.
     * @note Pair with CNA/ADP base name and CNA/ADP expanded name.
     */
    std::pair<std::string, std::string> m_vulnerabilitySource;

    /**
     * @brief Agent data list for re-scan all agents event.
     */
    std::vector<AgentContextData> m_agents;

    /**
     * @brief Agent data list with exceptions during re-scan all agents event.
     */
    std::vector<AgentContextData> m_agentsWithIncompletedScan;
};

using ScanContext = TScanContext<>;

#endif // _SCAN_CONTEXT_HPP
