/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 11, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _CLEAN_AGENT_INVENTORY_HPP
#define _CLEAN_AGENT_INVENTORY_HPP

#include "chainOfResponsability.hpp"
#include "inventorySync.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"

/**
 * @brief A class for handling data cleanup operations in the inventory database and publishing the changes to the
 * indexer.
 * This class is responsible for deleting all the inventory entries for a given agent and affected component type.
 * It is also responsible to call a sub-orchestration to publish the changes to the indexer.
 * It receives the scan context and the inventory database and returns the scan context with the inventory cleaned.
 * The affected component type can be Agent, Os or Package.
 * Agent: Delete all inventories for the agent.
 * Os: Delete inventory of the OS for the agent.
 * Package: Delete inventory of the package for the agent.
 *
 * @tparam TIndexerConnector Indexer connector.
 * @tparam TScanContext Scan context.
 */
template<typename TScanContext = ScanContext,
         typename TAbstractHandler = AbstractHandler<std::shared_ptr<TScanContext>>>
class TCleanAgentInventory final
    : public AbstractHandler<std::shared_ptr<TScanContext>>
    , public TInventorySync<TScanContext>
{
private:
    std::shared_ptr<TAbstractHandler> m_subOrchestration;

public:
    /**
     * @brief Class constructor.
     * @param inventoryDatabase Inventory database.
     * @param subOrchestration Sub-orchestration to publish changes to the indexer.
     */
    explicit TCleanAgentInventory(Utils::RocksDBWrapper& inventoryDatabase,
                                  std::shared_ptr<TAbstractHandler> subOrchestration)
        : TInventorySync<TScanContext>(inventoryDatabase)
        , m_subOrchestration(std::move(subOrchestration))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param context Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> context) override
    {
        std::string agentKey = context->agentId().compare("000") == 0 && context->clusterStatus()
                                   ? std::string(context->clusterNodeName()) + "_"
                                   : "";
        agentKey.append(context->agentId());
        agentKey.append("_");

        context->m_isInventoryEmpty = true;

        auto deleteAll = [this](std::shared_ptr<TScanContext> data,
                                const std::string& key,
                                const std::vector<AffectedComponentType>& types)
        {
            for (const auto& type : types)
            {
                for (const auto& dbQuery :
                     TInventorySync<TScanContext>::m_inventoryDatabase.seek(key, AFFECTED_COMPONENT_COLUMNS.at(type)))
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Deleting %s agent vulnerabilities key: %s",
                              AFFECTED_COMPONENT_COLUMNS.at(type).c_str(),
                              dbQuery.first.c_str());
                    TInventorySync<TScanContext>::m_inventoryDatabase.delete_(dbQuery.first,
                                                                              AFFECTED_COMPONENT_COLUMNS.at(type));
                }
            }

            // Create a new context by copying from the data
            auto subOrchestrationContext = std::make_shared<TScanContext>();
            subOrchestrationContext->m_noIndex = data->m_noIndex;

            // Build the delete by query element
            subOrchestrationContext->m_elements.emplace(
                "DeleteByQuery request",
                TInventorySync<TScanContext>::buildElement("DELETED_BY_QUERY", data->agentId().data()));

            // Pass the context to subOrchestration
            m_subOrchestration->handleRequest(std::move(subOrchestrationContext));
        };

        // If the affected type is Agent, delete all inventories for the agent.
        if (context->affectedComponentType() == AffectedComponentType::Agent)
        {
            deleteAll(context, agentKey, {AffectedComponentType::Os, AffectedComponentType::Package});
        }
        // Delete all entries for the affected type, used for the integrity clear.
        else
        {
            deleteAll(context, agentKey, {context->affectedComponentType()});
        }

        // If the affected type is Os, delete the initial scan data.
        if (context->affectedComponentType() == AffectedComponentType::Os ||
            context->affectedComponentType() == AffectedComponentType::Agent)
        {
            TInventorySync<TScanContext>::m_inventoryDatabase.delete_(context->agentId().data(), OS_INITIAL_SCAN);
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(context));
    }
};

using CleanAgentInventory = TCleanAgentInventory<>;

#endif // _CLEAN_AGENT_INVENTORY_HPP
