/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_ORCHESTRATOR_HPP
#define _SCAN_ORCHESTRATOR_HPP

#include "../../inventory_sync/src/context.hpp"
#include "databaseFeedManager/databaseFeedManager.hpp"
#include "factoryOrchestrator.hpp"
#include "flatbuffers/include/inventorySync_generated.h"
#include "indexerConnector.hpp"
#include "rocksDBWrapper.hpp"
#include "scanContext.hpp"
#include <memory>
#include <simdjson.h>
#include <string>
#include <variant>

/**
 * @brief ScanOrchestrator class.
 * Orchestrates vulnerability scanning based on inventory sync session data.
 */
template<typename TScanContext = ScanContext,
         typename TFactoryOrchestrator = FactoryOrchestrator,
         typename TOrchestrationNode = AbstractHandler<std::shared_ptr<TScanContext>>,
         typename TIndexerConnector = IndexerConnectorSync,
         typename TDatabaseFeedManager = DatabaseFeedManager>
class TScanOrchestrator final
{
public:
    /**
     * @brief Class constructor.
     *
     * @param indexerConnector Indexer connector.
     * @param databaseFeedManager Database feed manager.
     * @param reportDispatcher Report dispatcher queue to send vulnerability reports.
     * @param mutex Mutex to protect the access to the internal databases.
     */
    explicit TScanOrchestrator(std::shared_ptr<TIndexerConnector> indexerConnector,
                               std::shared_ptr<TDatabaseFeedManager> databaseFeedManager,
                               std::shared_ptr<ReportDispatcher> reportDispatcher,
                               std::shared_mutex& mutex)
        : m_indexerConnector(std::move(indexerConnector))
        , m_databaseFeedManager(std::move(databaseFeedManager))
        , m_reportDispatcher(std::move(reportDispatcher))
        , m_mutex(mutex)
    {
        // Build orchestration chains once (reusable across scans)
        m_packageDeltaOrchestration = TFactoryOrchestrator::create(
            ScannerType::PackageDelta, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_osOrchestration = TFactoryOrchestrator::create(
            ScannerType::OS, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_firstFullScanOrchestration = TFactoryOrchestrator::create(
            ScannerType::FirstFullScan, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_fullScan = TFactoryOrchestrator::create(
            ScannerType::FullScan, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_fullScanAfterFeedUpdate = TFactoryOrchestrator::create(
            ScannerType::FullScanAfterFeedUpdate, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_cleanupAgentData = TFactoryOrchestrator::create(
            ScannerType::CleanupAgentData, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);
    }

    ~TScanOrchestrator() = default;

    /**
     * @brief Run vulnerability scan based on inventory sync session data.
     *
     * @param dataStore RocksDB data store containing session messages.
     * @param inventorySyncContext Context from inventory sync (agent metadata, option, etc.).
     */
    void runScan(Utils::RocksDBWrapper& dataStore, const Context& inventorySyncContext) const
    {
        // Acquire lock for scan operations
        std::scoped_lock lock(m_mutex);

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Starting vulnerability scan for agent %s, option: %d",
                  inventorySyncContext.agentId.c_str(),
                  static_cast<int>(inventorySyncContext.option));

        // Build VD scan context from inventory sync session data
        auto scanContext = buildScanContext(dataStore, inventorySyncContext);

        // Determine scan type and execute appropriate orchestration
        switch (inventorySyncContext.option)
        {
            case Wazuh::SyncSchema::Option_VDFirst:
                logDebug2(WM_VULNSCAN_LOGTAG, "Processing VDFirst for agent %s", inventorySyncContext.agentId.c_str());

                m_firstFullScanOrchestration->handleRequest(scanContext);
                break;

            case Wazuh::SyncSchema::Option_VDSync: processVDSync(dataStore, inventorySyncContext, scanContext); break;

            case Wazuh::SyncSchema::Option_VDClean:
                logDebug2(WM_VULNSCAN_LOGTAG, "Processing VDClean for agent %s", inventorySyncContext.agentId.c_str());
                m_cleanupAgentDataOrchestration->handleRequest(scanContext);
                break;

            default:
                logWarn(WM_VULNSCAN_LOGTAG,
                        "Unknown VD option %d for agent %s",
                        static_cast<int>(inventorySyncContext.option),
                        inventorySyncContext.agentId.c_str());
                break;
        }

        logDebug2(
            WM_VULNSCAN_LOGTAG, "Vulnerability scan completed for agent %s", inventorySyncContext.agentId.c_str());
    }

private:
    /**
     * @brief Build VD scan context from inventory sync session data.
     *
     * @param dataStore RocksDB data store.
     * @param inventorySyncContext Inventory sync context.
     * @return Shared pointer to scan context.
     */
    std::shared_ptr<TScanContext> buildScanContext(Utils::RocksDBWrapper& dataStore,
                                                   const Context& inventorySyncContext) const
    {
        auto context = std::make_shared<TScanContext>(inventorySyncContext);

        // Create simdjson parser (thread-local for performance)
        thread_local simdjson::ondemand::parser parser;

        // Read messages from RocksDB and populate context
        const auto prefix = std::format("{}_", inventorySyncContext.sessionId);

        for (const auto& [key, value] : dataStore.seek(prefix))
        {
            parseAndAddMessage(value, context, parser);
        }

        return context;
    }

    /**
     * @brief Parse FlatBuffer message and add to scan context.
     *
     * @param value RocksDB value (serialized FlatBuffer).
     * @param context Scan context to populate.
     * @param parser simdjson parser instance.
     */
    void parseAndAddMessage(const rocksdb::Slice& value,
                            std::shared_ptr<TScanContext>& context,
                            simdjson::ondemand::parser& parser) const
    {
        // Verify FlatBuffer
        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(value.data()), value.size());

        if (!Wazuh::SyncSchema::VerifyMessageBuffer(verifier))
        {
            logWarn(WM_VULNSCAN_LOGTAG, "Invalid FlatBuffer message, skipping");
            return;
        }

        auto message = Wazuh::SyncSchema::GetMessage(value.data());

        // Handle DataValue messages (package changes)
        if (message->content_type() == Wazuh::SyncSchema::MessageType_DataValue)
        {
            auto data = message->content_as_DataValue();
            if (!data)
            {
                return;
            }

            // Parse JSON payload with simdjson (zero-copy)
            if (auto bytes = data->data(); bytes && bytes->size() > 0)
            {
                try
                {
                    // Create padded string view for simdjson
                    auto padded =
                        simdjson::padded_string_view(reinterpret_cast<const char*>(bytes->data()), bytes->size());

                    // Get document from result (move semantics)
                    auto docResult = parser.iterate(padded);
                    if (docResult.error() != simdjson::SUCCESS)
                    {
                        logWarn(WM_VULNSCAN_LOGTAG,
                                "Failed to iterate JSON: %s",
                                simdjson::error_message(docResult.error()));
                        return;
                    }

                    // Move document out of result
                    simdjson::ondemand::document doc = std::move(docResult).value();

                    // Extract package information
                    auto packageInfo = extractPackageInfo(doc);

                    // Add to context based on operation type
                    if (data->operation() == Wazuh::SyncSchema::Operation_Delete)
                    {
                        context->addPackageToContext(packageInfo, ElementOperation::Delete);
                    }
                    else if (data->operation() == Wazuh::SyncSchema::Operation_Upsert)
                    {
                        context->addPackageToContext(packageInfo, ElementOperation::Upsert);
                    }
                }
                catch (const simdjson::simdjson_error& e)
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "Failed to parse JSON payload with simdjson: %s",
                            simdjson::error_message(e.error()));
                }
            }
        }
        // Handle DataContext messages (bulk package data for full scan)
        else if (message->content_type() == Wazuh::SyncSchema::MessageType_DataContext)
        {
            auto data = message->content_as_DataContext();
            if (!data)
            {
                return;
            }

            // Parse JSON payload with simdjson (zero-copy)
            if (auto bytes = data->data(); bytes && bytes->size() > 0)
            {
                try
                {
                    // Create padded string view for simdjson
                    auto padded =
                        simdjson::padded_string_view(reinterpret_cast<const char*>(bytes->data()), bytes->size());

                    // Get document from result (move semantics)
                    auto docResult = parser.iterate(padded);
                    if (docResult.error() != simdjson::SUCCESS)
                    {
                        logWarn(WM_VULNSCAN_LOGTAG,
                                "Failed to iterate DataContext JSON: %s",
                                simdjson::error_message(docResult.error()));
                        return;
                    }

                    // Move document out of result
                    simdjson::ondemand::document doc = std::move(docResult).value();

                    // Extract package information
                    auto packageInfo = extractPackageInfo(doc);

                    // Add to full scan package list (DataContext is always existing packages)
                    context->addPackageToContext(packageInfo, ElementOperation::Upsert);
                }
                catch (const simdjson::simdjson_error& e)
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "Failed to parse DataContext JSON with simdjson: %s",
                            simdjson::error_message(e.error()));
                }
            }
        }
    }

    /**
     * @brief Extract package information from simdjson document.
     *
     * @param doc simdjson document.
     * @return PackageInfo struct with extracted data.
     */
    PackageContextData extractPackageInfo(simdjson::ondemand::document& doc) const
    {
        PackageContextData info;

        try
        {
            // Extract package fields (zero-copy)
            auto pkg = doc["package"];

            if (pkg.error() == simdjson::SUCCESS)
            {
                // Required fields
                if (auto name = pkg["name"]; name.error() == simdjson::SUCCESS)
                {
                    info.name = std::string(name.get_string().value());
                }

                if (auto version = pkg["version"]; version.error() == simdjson::SUCCESS)
                {
                    info.version = std::string(version.get_string().value());
                }

                // Optional fields
                if (auto arch = pkg["architecture"]; arch.error() == simdjson::SUCCESS)
                {
                    info.architecture = std::string(arch.get_string().value());
                }

                if (auto format = pkg["format"]; format.error() == simdjson::SUCCESS)
                {
                    info.format = std::string(format.get_string().value());
                }

                if (auto source = pkg["source"]; source.error() == simdjson::SUCCESS)
                {
                    info.source = std::string(source.get_string().value());
                }

                if (auto location = pkg["location"]; location.error() == simdjson::SUCCESS)
                {
                    info.location = std::string(location.get_string().value());
                }

                if (auto multiarch = pkg["multiarch"]; multiarch.error() == simdjson::SUCCESS)
                {
                    info.multiarch = std::string(multiarch.get_string().value());
                }

                if (auto priority = pkg["priority"]; priority.error() == simdjson::SUCCESS)
                {
                    info.priority = std::string(priority.get_string().value());
                }

                if (auto size = pkg["size"]; size.error() == simdjson::SUCCESS)
                {
                    auto size_result = size.get_uint64();
                    info.size = size_result.error() == simdjson::SUCCESS ? size_result.value() : 0;
                }

                if (auto install_time = pkg["install_time"]; install_time.error() == simdjson::SUCCESS)
                {
                    info.install_time = std::string(install_time.get_string().value());
                }

                if (auto description = pkg["description"]; description.error() == simdjson::SUCCESS)
                {
                    info.description = std::string(description.get_string().value());
                }

                if (auto groups = pkg["groups"]; groups.error() == simdjson::SUCCESS)
                {
                    info.groups = std::string(groups.get_string().value());
                }
            }

            // Extract id if present at top level
            if (auto id = doc["id"]; id.error() == simdjson::SUCCESS)
            {
                info.id = std::string(id.get_string().value());
            }

            // Extract vendor if present
            if (auto vendor = doc["vendor"]; vendor.error() == simdjson::SUCCESS)
            {
                info.vendor = std::string(vendor.get_string().value());
            }
        }
        catch (const simdjson::simdjson_error& e)
        {
            logWarn(WM_VULNSCAN_LOGTAG, "Error extracting package info: %s", simdjson::error_message(e.error()));
        }

        return info;
    }

    /**
     * @brief Process VDSync option (determine if full scan or delta scan).
     *
     * @param dataStore RocksDB data store.
     * @param inventorySyncContext Inventory sync context.
     * @param scanContext VD scan context.
     */
    void processVDSync(Utils::RocksDBWrapper& dataStore,
                       const Context& inventorySyncContext,
                       std::shared_ptr<TScanContext> scanContext) const
    {
        // Check if OS or hotfix changed (triggers full scan with diff)
        // check index: [string];
        if (std::find(inventorySyncContext.indices.begin(),
                      inventorySyncContext.indices.end(),
                      "wazuh-states-inventory-system") != inventorySyncContext.indices.end() ||
            std::find(inventorySyncContext.indices.begin(),
                      inventorySyncContext.indices.end(),
                      "wazuh-states-inventory-hotfixes") != inventorySyncContext.indices.end())
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "OS or Hotfix change detected for agent %s, triggering FullScanWithDiff",
                      inventorySyncContext.agentId.c_str());

            m_fullScanOrchestration->handleRequest(scanContext);
        }
        else
        {
            // Process package deltas (INSERT/DELETE)
            logDebug2(
                WM_VULNSCAN_LOGTAG, "Processing package deltas for agent %s", inventorySyncContext.agentId.c_str());

            processPackageDelta(scanContext);
        }
    }

    /**
     * @brief Process package delta operations (DELETE then INSERT).
     *
     * @param scanContext VD scan context.
     */
    void processPackageDelta(std::shared_ptr<TScanContext> scanContext) const {}

    // Dependencies
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;
    std::shared_ptr<ReportDispatcher> m_reportDispatcher;
    std::shared_mutex& m_mutex;

    // Orchestration chains (built once, reused)
    std::shared_ptr<TOrchestrationNode> m_packageDeltaOrchestration;
    std::shared_ptr<TOrchestrationNode> m_osOrchestration;
    std::shared_ptr<TOrchestrationNode> m_firstFullScanOrchestration;
    std::shared_ptr<TOrchestrationNode> m_fullScanOrchestration;
    std::shared_ptr<TOrchestrationNode> m_fullScanAfterFeedUpdateOrchestration;
    std::shared_ptr<TOrchestrationNode> m_cleanupAgentDataOrchestration;
};

using ScanOrchestrator = TScanOrchestrator<>;

#endif // _SCAN_ORCHESTRATOR_HPP
