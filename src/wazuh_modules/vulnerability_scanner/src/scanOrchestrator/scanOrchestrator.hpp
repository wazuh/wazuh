/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_ORCHESTRATOR_HPP
#define _SCAN_ORCHESTRATOR_HPP

#include "../../inventory_sync/src/context.hpp"
#include "databaseFeedManager/databaseFeedManager.hpp"
#include "factoryOrchestrator.hpp"
#include "flatbuffers/include/inventorySync_generated.h"
#include "indexerConnector.hpp"
#include "loggerHelper.h"
#include "rocksDBWrapper.hpp"
#include "scanContext.hpp"
#include <memory>
#include <simdjson.h>
#include <string>
#include <variant>

/**
 * @brief Helper function to convert option enum to string for logging.
 */
inline const char* getOptionName(Wazuh::SyncSchema::Option option)
{
    switch (option)
    {
        case Wazuh::SyncSchema::Option_VDFirst: return "VDFirst";
        case Wazuh::SyncSchema::Option_VDSync: return "VDSync";
        case Wazuh::SyncSchema::Option_VDClean: return "VDClean";
        default: return "Unknown";
    }
}

/**
 * @brief ScanOrchestrator class.
 * Orchestrates vulnerability scanning based on inventory sync session data.
 */
template<typename TScanContext = ScanContext,
         typename TFactoryOrchestrator = FactoryOrchestrator,
         typename TOrchestrationNode = AbstractHandler<std::shared_ptr<TScanContext>>,
         typename TIndexerConnector = IndexerConnectorSync,
         typename TDatabaseFeedManager = DatabaseFeedManager>
class TScanOrchestrator final
{
public:
    /**
     * @brief Class constructor.
     *
     * @param indexerConnector Indexer connector.
     * @param databaseFeedManager Database feed manager.
     * @param reportDispatcher Report dispatcher queue to send vulnerability reports.
     * @param mutex Mutex to protect the access to the internal databases.
     */
    explicit TScanOrchestrator(std::shared_ptr<TIndexerConnector> indexerConnector,
                               std::shared_ptr<TDatabaseFeedManager> databaseFeedManager,
                               std::shared_ptr<ReportDispatcher> reportDispatcher,
                               std::shared_mutex& mutex)
        : m_indexerConnector(std::move(indexerConnector))
        , m_databaseFeedManager(std::move(databaseFeedManager))
        , m_reportDispatcher(std::move(reportDispatcher))
        , m_mutex(mutex)
    {
        // Build orchestration chains once (reusable across scans)
        m_packageDeltaOrchestration = TFactoryOrchestrator::create(
            ScannerType::PackageDelta, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_osOrchestration = TFactoryOrchestrator::create(
            ScannerType::OS, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_firstFullScanOrchestration = TFactoryOrchestrator::create(
            ScannerType::FirstFullScan, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_fullScanOrchestration = TFactoryOrchestrator::create(
            ScannerType::FullScan, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_fullScanAfterFeedUpdateOrchestration = TFactoryOrchestrator::create(
            ScannerType::FullScanAfterFeedUpdate, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);

        m_cleanupAgentDataOrchestration = TFactoryOrchestrator::create(
            ScannerType::CleanupAgentData, m_databaseFeedManager, m_indexerConnector, m_reportDispatcher);
    }

    ~TScanOrchestrator() = default;

    /**
     * @brief Run vulnerability scan based on inventory sync session data.
     *
     * @param dataStore RocksDB data store containing session messages.
     * @param inventorySyncContext Context from inventory sync (agent metadata, option, etc.).
     */
    void runScan(Utils::RocksDBWrapper& dataStore, const Context& inventorySyncContext) const
    {
        // Acquire lock for scan operations
        std::scoped_lock lock(m_mutex);

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Starting vulnerability scan for agent '%s' (v.%s) - Sync option: %s",
                  inventorySyncContext.agentId.c_str(),
                  inventorySyncContext.agentVersion.c_str(),
                  getOptionName(inventorySyncContext.option));

        // Build VD scan context from inventory sync session data
        auto scanContext = buildScanContext(dataStore, inventorySyncContext);

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Agent '%s' - Packages to scan: %zu",
                  inventorySyncContext.agentId.c_str(),
                  scanContext->getPackageCount());

        // Determine scan type and execute appropriate orchestration
        switch (inventorySyncContext.option)
        {
            case Wazuh::SyncSchema::Option_VDFirst:
                logDebug2(WM_VULNSCAN_LOGTAG, "Processing VDFirst for agent %s", inventorySyncContext.agentId.c_str());

                m_firstFullScanOrchestration->handleRequest(scanContext);
                break;

            case Wazuh::SyncSchema::Option_VDSync: processVDSync(dataStore, inventorySyncContext, scanContext); break;

            case Wazuh::SyncSchema::Option_VDClean:
                logDebug2(WM_VULNSCAN_LOGTAG, "Processing VDClean for agent %s", inventorySyncContext.agentId.c_str());
                m_cleanupAgentDataOrchestration->handleRequest(scanContext);
                break;

            default:
                logWarn(WM_VULNSCAN_LOGTAG,
                        "Unknown VD option %d for agent %s",
                        static_cast<int>(inventorySyncContext.option),
                        inventorySyncContext.agentId.c_str());
                break;
        }

        logDebug2(
            WM_VULNSCAN_LOGTAG, "Vulnerability scan completed for agent %s", inventorySyncContext.agentId.c_str());
    }

private:
    /**
     * @brief Build VD scan context from inventory sync session data.
     *
     * @param dataStore RocksDB data store.
     * @param inventorySyncContext Inventory sync context.
     * @return Shared pointer to scan context.
     */
    std::shared_ptr<TScanContext> buildScanContext(Utils::RocksDBWrapper& dataStore,
                                                   const Context& inventorySyncContext) const
    {
        auto context = std::make_shared<TScanContext>(inventorySyncContext);

        // Create simdjson parser (thread-local for performance)
        thread_local simdjson::ondemand::parser parser;

        // Read messages from RocksDB and populate context
        const auto prefix = std::format("{}_", inventorySyncContext.sessionId);

        for (const auto& [key, value] : dataStore.seek(prefix))
        {
            parseAndAddMessage(value, context, parser);
        }

        return context;
    }

    /**
     * @brief Parse FlatBuffer message and add to scan context.
     *
     * @param value RocksDB value (serialized FlatBuffer).
     * @param context Scan context to populate.
     * @param parser simdjson parser instance.
     */
    void parseAndAddMessage(const rocksdb::Slice& value,
                            std::shared_ptr<TScanContext>& context,
                            simdjson::ondemand::parser& parser) const
    {
        // Verify FlatBuffer
        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(value.data()), value.size());

        if (!Wazuh::SyncSchema::VerifyMessageBuffer(verifier))
        {
            logWarn(WM_VULNSCAN_LOGTAG, "Invalid FlatBuffer message, skipping");
            return;
        }

        auto message = Wazuh::SyncSchema::GetMessage(value.data());

        // Handle DataValue messages
        if (message->content_type() == Wazuh::SyncSchema::MessageType_DataValue)
        {
            auto data = message->content_as_DataValue();
            if (!data || !data->data() || data->data()->size() == 0)
            {
                return;
            }

            try
            {
                // Parse JSON from data field (contains _source)
                simdjson::padded_string paddedJson(reinterpret_cast<const char*>(data->data()->data()),
                                                   data->data()->size());

                auto docResult = parser.iterate(paddedJson);
                if (docResult.error() != simdjson::SUCCESS)
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "Failed to iterate DataValue JSON: %s",
                            simdjson::error_message(docResult.error()));
                    return;
                }

                simdjson::ondemand::document doc = std::move(docResult).value();

                // Determine index type
                std::string index = data->index() ? data->index()->str() : "";

                if (index == PACKAGE_INDEX)
                {
                    // CRITICAL: Extract OS data from agent.host FIRST (before package extraction)
                    // This ensures OS context is available for vulnerability scanning
                    auto osData = extractOSFromAgentHost(doc);
                    if (!osData.name.empty())
                    {
                        context->setOSData(osData);

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "DataValue (Package): Extracted OS data - %s %s (platform: %s, arch: %s)",
                                  osData.name.c_str(),
                                  osData.version.c_str(),
                                  osData.platform.c_str(),
                                  osData.architecture.c_str());
                    }

                    // Now extract package info
                    // NOTE: We need to re-parse the document because simdjson is forward-only
                    auto docResult2 = parser.iterate(paddedJson);
                    simdjson::ondemand::document doc2 = std::move(docResult2).value();

                    auto packageInfo = extractPackageInfo(doc2);

                    auto operation = (data->operation() == Wazuh::SyncSchema::Operation_Delete)
                                         ? ElementOperation::Delete
                                         : ElementOperation::Upsert;

                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "DataValue: %s package '%s' (v.%s)",
                              (operation == ElementOperation::Delete ? "DELETE" : "UPSERT"),
                              packageInfo.name.c_str(),
                              packageInfo.version.c_str());

                    context->addPackageToContext(std::move(packageInfo), operation);
                }
                else if (index == OS_INDEX)
                {
                    // For OS index, extract from agent.host
                    auto osData = extractOSFromAgentHost(doc);
                    context->setOSData(osData);

                    logDebug1(WM_VULNSCAN_LOGTAG,
                              "DataValue (OS): OS data loaded - %s %s",
                              osData.name.c_str(),
                              osData.version.c_str());
                }
                else if (index == HOTFIX_INDEX)
                {
                    // Extract OS data from hotfix document too
                    auto osData = extractOSFromAgentHost(doc);
                    if (!osData.name.empty())
                    {
                        context->setOSData(osData);
                    }

                    // Re-parse for hotfix extraction
                    auto docResult2 = parser.iterate(paddedJson);
                    simdjson::ondemand::document doc2 = std::move(docResult2).value();

                    auto hotfixData = extractHotfixInfo(doc2);

                    if (!hotfixData.hotfixId.empty())
                    {
                        // Store in RemediationDataCache
                        // TRemediationDataCache::instance().addHotfix(std::string(context->agentId()),
                        //                                              hotfixData.hotfixId);

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "DataValue: Hotfix '%s' registered for agent '%s'",
                                  hotfixData.hotfixId.c_str(),
                                  context->agentId().data());
                    }
                    else
                    {
                        logWarn(WM_VULNSCAN_LOGTAG, "DataValue: Empty hotfix ID, skipping");
                    }
                }
            }
            catch (const simdjson::simdjson_error& e)
            {
                logWarn(WM_VULNSCAN_LOGTAG, "Failed to parse DataValue JSON: %s", simdjson::error_message(e.error()));
            }
        }
        // Handle DataContext messages
        else if (message->content_type() == Wazuh::SyncSchema::MessageType_DataContext)
        {
            auto data = message->content_as_DataContext();
            if (!data || !data->data() || data->data()->size() == 0)
            {
                return;
            }

            try
            {
                simdjson::padded_string paddedJson(reinterpret_cast<const char*>(data->data()->data()),
                                                   data->data()->size());

                auto docResult = parser.iterate(paddedJson);
                if (docResult.error() != simdjson::SUCCESS)
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "Failed to iterate DataContext JSON: %s",
                            simdjson::error_message(docResult.error()));
                    return;
                }

                simdjson::ondemand::document doc = std::move(docResult).value();

                std::string index = data->index() ? data->index()->str() : "";

                if (index == PACKAGE_INDEX)
                {
                    auto packageInfo = extractPackageInfo(doc);

                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "DataContext: package '%s' (v.%s)",
                              packageInfo.name.c_str(),
                              packageInfo.version.c_str());

                    context->addPackageToContext(std::move(packageInfo), ElementOperation::Upsert);
                }
            }
            catch (const simdjson::simdjson_error& e)
            {
                logWarn(WM_VULNSCAN_LOGTAG, "Failed to parse DataContext JSON: %s", simdjson::error_message(e.error()));
            }
        }
    }

    /**
     * @brief Extract OS information from agent.host structure in Indexer documents.
     *
     * This function extracts OS data from the standard Indexer document format where
     * OS information is nested under agent.host.os. This structure appears in all
     * inventory documents (packages, hotfixes, etc.).
     *
     * Expected structure:
     * {
     *   "agent": {
     *     "id": "001",
     *     "name": "ubuntu22",
     *     "host": {
     *       "hostname": "ubuntu22",
     *       "architecture": "aarch64",
     *       "os": {
     *         "name": "Ubuntu",
     *         "platform": "ubuntu",
     *         "type": "linux",
     *         "version": "22.04.5 LTS (Jammy Jellyfish)"
     *       }
     *     }
     *   }
     * }
     *
     * @param doc simdjson document (forward-only, will be consumed)
     * @return OsContextData with extracted OS information
     */
    OsContextData extractOSFromAgentHost(simdjson::ondemand::document& doc) const
    {
        OsContextData osData;

        try
        {
            // Single-pass extraction using object iteration
            for (auto topField : doc.get_object())
            {
                std::string_view topKey = topField.unescaped_key().value();

                if (topKey == "agent")
                {
                    auto agentValue = topField.value();
                    if (agentValue.is_null())
                        continue;

                    for (auto agentField : agentValue.get_object().value())
                    {
                        std::string_view agentKey = agentField.unescaped_key().value();

                        if (agentKey == "host")
                        {
                            auto hostValue = agentField.value();
                            if (hostValue.is_null())
                                continue;

                            for (auto hostField : hostValue.get_object().value())
                            {
                                std::string_view hostKey = hostField.unescaped_key().value();
                                auto hostFieldValue = hostField.value();

                                if (hostFieldValue.is_null())
                                    continue;

                                if (hostKey == "hostname")
                                {
                                    auto strResult = hostFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.hostName = std::string(strResult.value());
                                    }
                                }
                                else if (hostKey == "architecture")
                                {
                                    auto strResult = hostFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.architecture = std::string(strResult.value());
                                    }
                                }
                                else if (hostKey == "os")
                                {
                                    for (auto osField : hostFieldValue.get_object().value())
                                    {
                                        std::string_view osKey = osField.unescaped_key().value();
                                        auto osFieldValue = osField.value();

                                        if (osFieldValue.is_null())
                                            continue;

                                        if (osKey == "name")
                                        {
                                            auto strResult = osFieldValue.get_string();
                                            if (strResult.error() == simdjson::SUCCESS)
                                            {
                                                osData.name = std::string(strResult.value());
                                            }
                                        }
                                        else if (osKey == "platform")
                                        {
                                            auto strResult = osFieldValue.get_string();
                                            if (strResult.error() == simdjson::SUCCESS)
                                            {
                                                osData.platform = std::string(strResult.value());
                                            }
                                        }
                                        else if (osKey == "version")
                                        {
                                            auto strResult = osFieldValue.get_string();
                                            if (strResult.error() == simdjson::SUCCESS)
                                            {
                                                osData.version = std::string(strResult.value());
                                            }
                                        }
                                        else if (osKey == "type")
                                        {
                                            auto strResult = osFieldValue.get_string();
                                            if (strResult.error() == simdjson::SUCCESS)
                                            {
                                                osData.sysName = std::string(strResult.value());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (!osData.name.empty())
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Extracted OS from agent.host: name='%s', platform='%s', version='%s', arch='%s'",
                          osData.name.c_str(),
                          osData.platform.c_str(),
                          osData.version.c_str(),
                          osData.architecture.c_str());
            }
        }
        catch (const simdjson::simdjson_error& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Error extracting OS from agent.host: %s", simdjson::error_message(e.error()));
        }

        return osData;
    }

    /**
     * @brief Extract package information from simdjson document.
     *
     * @param doc simdjson document.
     * @return PackageInfo struct with extracted data.
     */
    PackageContextData extractPackageInfo(simdjson::ondemand::document& doc) const
    {
        PackageContextData info;

        try
        {
            for (auto field : doc.get_object())
            {
                std::string_view key = field.unescaped_key().value();

                if (key == "package")
                {
                    auto pkgValue = field.value();

                    // Check if package field is null
                    if (pkgValue.is_null())
                    {
                        logWarn(WM_VULNSCAN_LOGTAG, "Package field is null");
                        continue;
                    }

                    auto pkg = pkgValue.get_object().value();

                    for (auto pkgField : pkg)
                    {
                        std::string_view pkgKey = pkgField.unescaped_key().value();
                        auto pkgFieldValue = pkgField.value();

                        // CRITICAL: Check for null before accessing typed values
                        if (pkgFieldValue.is_null())
                        {
                            continue;
                        }

                        if (pkgKey == "name")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.name = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "version")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.version = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "type")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.format = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "architecture")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.architecture = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "vendor")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.vendor = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "description")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.description = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "size")
                        {
                            auto sizeResult = pkgFieldValue.get_uint64();
                            if (sizeResult.error() == simdjson::SUCCESS)
                            {
                                info.size = sizeResult.value();
                            }
                        }
                        else if (pkgKey == "source")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.source = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "path")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.location = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "priority")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.priority = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "multiarch")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.multiarch = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "category")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.groups = std::string(strResult.value());
                            }
                        }
                    }
                }
            }

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Extracted package: name='%s', version='%s', type='%s', vendor='%s'",
                      info.name.c_str(),
                      info.version.c_str(),
                      info.format.c_str(),
                      info.vendor.c_str());
        }
        catch (const simdjson::simdjson_error& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Error extracting package info: %s", simdjson::error_message(e.error()));
        }

        return info;
    }

    /**
     * @brief Extract OS information from JSON document.
     * BUG FIX: Extract all fields without resetting document.
     */
    OsContextData extractOSInfo(simdjson::ondemand::document& doc) const
    {
        OsContextData osData;

        try
        {
            auto agent = doc.find_field("agent");
            if (agent.error() == simdjson::SUCCESS)
            {
                auto host = agent.find_field("host");
                if (host.error() == simdjson::SUCCESS)
                {
                    // Extract hostname and architecture
                    auto hostname = host.find_field("hostname");
                    if (hostname.error() == simdjson::SUCCESS)
                    {
                        osData.hostName = std::string(hostname.get_string().value());
                    }

                    auto arch = host.find_field("architecture");
                    if (arch.error() == simdjson::SUCCESS)
                    {
                        osData.architecture = std::string(arch.get_string().value());
                    }

                    // Extract OS fields
                    auto os = host.find_field("os");
                    if (os.error() == simdjson::SUCCESS)
                    {
                        for (auto osField : os.get_object().value())
                        {
                            std::string_view key = osField.unescaped_key().value();

                            if (key == "name")
                            {
                                osData.name = std::string(osField.value().get_string().value());
                            }
                            else if (key == "platform")
                            {
                                osData.platform = std::string(osField.value().get_string().value());
                            }
                            else if (key == "version")
                            {
                                osData.version = std::string(osField.value().get_string().value());
                            }
                        }
                    }
                }
            }

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Extracted OS: name='%s', version='%s', platform='%s', arch='%s'",
                      osData.name.c_str(),
                      osData.version.c_str(),
                      osData.platform.c_str(),
                      osData.architecture.c_str());
        }
        catch (const simdjson::simdjson_error& e)
        {
            logError(
                WM_VULNSCAN_LOGTAG, "Error extracting OS from Indexer doc: %s", simdjson::error_message(e.error()));
        }

        return osData;
    }

    HotfixContextData extractHotfixInfo(simdjson::ondemand::document& doc) const
    {
        HotfixContextData hotfix;

        try
        {
            for (auto field : doc.get_object())
            {
                std::string_view key = field.unescaped_key().value();

                if (key == "package")
                {
                    auto pkgValue = field.value();

                    if (pkgValue.is_null())
                    {
                        continue;
                    }

                    auto pkg = pkgValue.get_object().value();

                    for (auto pkgField : pkg)
                    {
                        std::string_view pkgKey = pkgField.unescaped_key().value();

                        if (pkgKey == "hotfix")
                        {
                            auto hotfixValue = pkgField.value();

                            if (hotfixValue.is_null())
                            {
                                continue;
                            }

                            auto hotfixObj = hotfixValue.get_object().value();

                            for (auto hotfixField : hotfixObj)
                            {
                                std::string_view hotfixFieldKey = hotfixField.unescaped_key().value();

                                if (hotfixFieldKey == "name")
                                {
                                    auto nameValue = hotfixField.value();
                                    if (!nameValue.is_null())
                                    {
                                        auto nameResult = nameValue.get_string();
                                        if (nameResult.error() == simdjson::SUCCESS)
                                        {
                                            hotfix.hotfixId = std::string(nameResult.value());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            logDebug2(WM_VULNSCAN_LOGTAG, "Extracted hotfix: id='%s'", hotfix.hotfixId.c_str());
        }
        catch (const simdjson::simdjson_error& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Error extracting hotfix info: %s", simdjson::error_message(e.error()));
        }

        return hotfix;
    }

    /**
     * @brief Process VDSync option (determine if full scan or delta scan).
     *
     * @param dataStore RocksDB data store.
     * @param inventorySyncContext Inventory sync context.
     * @param scanContext VD scan context.
     */
    void processVDSync(Utils::RocksDBWrapper& /*dataStore*/,
                       const Context& inventorySyncContext,
                       std::shared_ptr<TScanContext> scanContext) const
    {
        // Check if OS or hotfix changed (triggers full scan with diff)
        // check index: [string];
        if (std::find(inventorySyncContext.indices.begin(), inventorySyncContext.indices.end(), OS_INDEX) !=
                inventorySyncContext.indices.end() ||
            std::find(inventorySyncContext.indices.begin(), inventorySyncContext.indices.end(), HOTFIX_INDEX) !=
                inventorySyncContext.indices.end())
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "OS or Hotfix change detected for agent %s, triggering FullScanWithDiff",
                      inventorySyncContext.agentId.c_str());

            m_firstFullScanOrchestration->handleRequest(scanContext);
        }
        else
        {
            // Process package deltas (INSERT/DELETE)
            logDebug2(
                WM_VULNSCAN_LOGTAG, "Processing package deltas for agent %s", inventorySyncContext.agentId.c_str());

            m_packageDeltaOrchestration->handleRequest(scanContext);
        }
    }

    // Dependencies
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;
    std::shared_ptr<ReportDispatcher> m_reportDispatcher;
    std::shared_mutex& m_mutex;

    // Orchestration chains (built once, reused)
    std::shared_ptr<TOrchestrationNode> m_packageDeltaOrchestration;
    std::shared_ptr<TOrchestrationNode> m_osOrchestration;
    std::shared_ptr<TOrchestrationNode> m_firstFullScanOrchestration;
    std::shared_ptr<TOrchestrationNode> m_fullScanOrchestration;
    std::shared_ptr<TOrchestrationNode> m_fullScanAfterFeedUpdateOrchestration;
    std::shared_ptr<TOrchestrationNode> m_cleanupAgentDataOrchestration;
};

using ScanOrchestrator = TScanOrchestrator<>;

#endif // _SCAN_ORCHESTRATOR_HPP
