/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_ORCHESTRATOR_HPP
#define _SCAN_ORCHESTRATOR_HPP

#include <algorithm>
#include <chrono>
#include <memory>
#include <mutex>
#include <shared_mutex>
#include <simdjson.h>
#include <string>
#include <thread>
#include <variant>

#include "context.hpp"
#include "databaseFeedManager/databaseFeedManager.hpp"
#include "factoryOrchestrator.hpp"
#include "flatbuffers/include/inventorySync_generated.h"
#include "indexerConnector.hpp"
#include "loggerHelper.h"
#include "rocksDBWrapper.hpp"
#include "scanContext.hpp"
#include "scanOrchestrator_defs.hpp"

#ifdef WAZUH_UNIT_TESTING
#include "gtest/gtest.h"
#endif

/**
 * @brief Helper function to convert option enum to string for logging.
 */
inline const char* getOptionName(Wazuh::SyncSchema::Option option)
{
    switch (option)
    {
        case Wazuh::SyncSchema::Option_VDFirst: return "VDFirst";
        case Wazuh::SyncSchema::Option_VDSync: return "VDSync";
        default: return "Unknown";
    }
}

/**
 * @brief ScanOrchestrator class.
 * Orchestrates vulnerability scanning based on inventory sync session data.
 */
template<typename TScanContext = ScanContext,
         typename TFactoryOrchestrator = FactoryOrchestrator,
         typename TOrchestrationNode = AbstractHandler<std::shared_ptr<TScanContext>>,
         typename TIndexerConnector = IndexerConnectorSync,
         typename TDatabaseFeedManager = DatabaseFeedManager>
class TScanOrchestrator final
{
public:
    /**
     * @brief Class constructor.
     *
     * @param indexerConnector Indexer connector.
     * @param databaseFeedManager Database feed manager.
     * @param mutex Mutex to protect the access to the internal databases.
     */
    explicit TScanOrchestrator(std::shared_ptr<TIndexerConnector> indexerConnector,
                               std::shared_ptr<TDatabaseFeedManager> databaseFeedManager,
                               std::shared_mutex& mutex)
        : m_indexerConnector(std::move(indexerConnector))
        , m_databaseFeedManager(std::move(databaseFeedManager))
        , m_mutex(mutex)
    {
        // Build orchestration chains once (reusable across scans)
        m_packageDeltaOrchestration =
            TFactoryOrchestrator::create(ScannerType::PackagesDelta, m_databaseFeedManager, m_indexerConnector);

        m_firstFullScanOrchestration =
            TFactoryOrchestrator::create(ScannerType::FirstFullScan, m_databaseFeedManager, m_indexerConnector);

        m_fullScanOrchestration =
            TFactoryOrchestrator::create(ScannerType::FullScan, m_databaseFeedManager, m_indexerConnector);
    }

    ~TScanOrchestrator() = default;

    /**
     * @brief Run vulnerability scan based on inventory sync session data.
     *
     * @param dataStore RocksDB data store containing session messages.
     * @param inventorySyncContext Context from inventory sync (agent metadata, option, etc.).
     */
    void runScan(Utils::RocksDBWrapper& dataStore, const Context& inventorySyncContext) const
    {
        const auto optionName = getOptionName(inventorySyncContext.option);
        std::unique_lock<std::shared_mutex> lock(m_mutex, std::defer_lock);
        if (!lock.try_lock())
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Vulnerability scan waiting for VD lock: agent='%s' option=%s",
                      inventorySyncContext.agentId.c_str(),
                      optionName);
            lock.lock();
        }

        // Build VD scan context from inventory sync session data
        auto scanContext = buildScanContext(dataStore, inventorySyncContext);

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Agent '%s' - Packages to scan: %zu",
                  inventorySyncContext.agentId.c_str(),
                  scanContext->packageCount());

        const char* scanType = nullptr;
        const char* scanReason = nullptr;
        bool scanExecuted = false;

        // Determine scan type and execute appropriate orchestration
        switch (inventorySyncContext.option)
        {
            case Wazuh::SyncSchema::Option_VDFirst:
                scanType = "full";
                scanReason = "first_scan";
                logInfo(WM_VULNSCAN_LOGTAG,
                        "Vulnerability scan start: agent='%s' (%s) type=%s reason=%s option=%s",
                        inventorySyncContext.agentId.c_str(),
                        inventorySyncContext.agentVersion.c_str(),
                        scanType,
                        scanReason,
                        optionName);
                m_indexerConnector->deleteByQuery("wazuh-states-vulnerabilities", inventorySyncContext.agentId);
                m_firstFullScanOrchestration->handleRequest(scanContext);
                scanExecuted = true;
                break;

            case Wazuh::SyncSchema::Option_VDSync:
            {
                const bool hasOsOrHotfixChange =
                    std::find(inventorySyncContext.indices.begin(), inventorySyncContext.indices.end(), OS_INDEX) !=
                        inventorySyncContext.indices.end() ||
                    std::find(inventorySyncContext.indices.begin(), inventorySyncContext.indices.end(), HOTFIX_INDEX) !=
                        inventorySyncContext.indices.end();

                scanType = hasOsOrHotfixChange ? "full" : "delta";
                scanReason = hasOsOrHotfixChange ? "os_or_hotfix_changed" : "package_delta";

                logInfo(WM_VULNSCAN_LOGTAG,
                        "Vulnerability scan start: agent='%s' (%s) type=%s reason=%s option=%s",
                        inventorySyncContext.agentId.c_str(),
                        inventorySyncContext.agentVersion.c_str(),
                        scanType,
                        scanReason,
                        optionName);

                if (hasOsOrHotfixChange)
                {
                    m_fullScanOrchestration->handleRequest(scanContext);
                }
                else
                {
                    m_packageDeltaOrchestration->handleRequest(scanContext);
                }

                scanExecuted = true;
                break;
            }

            default:
                logWarn(WM_VULNSCAN_LOGTAG,
                        "Unknown VD option %d for agent %s",
                        static_cast<int>(inventorySyncContext.option),
                        inventorySyncContext.agentId.c_str());
                break;
        }

        if (scanExecuted)
        {
            logInfo(WM_VULNSCAN_LOGTAG,
                    "Vulnerability scan completed: agent='%s' type=%s reason=%s option=%s",
                    inventorySyncContext.agentId.c_str(),
                    scanType ? scanType : "unknown",
                    scanReason ? scanReason : "unknown",
                    optionName);
        }
    }

    /**
     * @brief Run a full scan after feed update using a pre-built scan context.
     *
     * @param scanContext Scan context populated from indexer inventory data.
     */
    void runScanAfterFeedUpdate(std::shared_ptr<TScanContext> scanContext, bool lockScan = true) const
    {
        if (!scanContext)
        {
            logWarn(WM_VULNSCAN_LOGTAG, "runScanAfterFeedUpdate called with null ScanContext.");
            return;
        }

        std::unique_lock<std::shared_mutex> lock(m_mutex, std::defer_lock);
        if (lockScan)
        {
            lock.lock();
        }

        logInfo(WM_VULNSCAN_LOGTAG,
                "Vulnerability scan start: agent='%s' (%s) type=full reason=feed_update",
                scanContext->agentId().data(),
                scanContext->agentVersion().data());

        m_fullScanOrchestration->handleRequest(scanContext);

        logInfo(WM_VULNSCAN_LOGTAG,
                "Vulnerability scan completed: agent='%s' type=full reason=feed_update",
                scanContext->agentId().data());
    }

private:
    SCAN_ORCHESTRATOR_FRIEND_TEST_DECLARATIONS;

    /**
     * @brief Build VD scan context from inventory sync session data.
     *
     * @param dataStore RocksDB data store.
     * @param inventorySyncContext Inventory sync context.
     * @return Shared pointer to scan context.
     */
    std::shared_ptr<TScanContext> buildScanContext(Utils::RocksDBWrapper& dataStore,
                                                   const Context& inventorySyncContext) const
    {
        // ScanContext constructor initializes basic agent and OS data
        // from the Start (Context) message.
        auto context = std::make_shared<TScanContext>(inventorySyncContext);

        // Create simdjson parser (thread-local for performance)
        thread_local simdjson::ondemand::parser parser;

        // Read messages from RocksDB and populate context
        const auto prefix = std::format("{}_", inventorySyncContext.sessionId);

        for (const auto& [key, value] : dataStore.seek(prefix))
        {
            parseAndAddMessage(value, context, parser);
        }

        return context;
    }

    /**
     * @brief Common processing for DataValue and DataContext inventory documents.
     *
     * @param index Index name (OS, package, hotfix).
     * @param doc Parsed simdjson document.
     * @param context Scan context to populate.
     * @param operation Element operation (Delete/Upsert). For DataContext always Upsert.
     * @param sourceTag Text tag for logging ("DataValue" / "DataContext").
     * @param documentId Document identifier (from DataValue/DataContext).
     */
    void processInventoryDocument(const std::string& index,
                                  simdjson::ondemand::document& doc,
                                  std::shared_ptr<TScanContext>& context,
                                  ElementOperation operation,
                                  const char* sourceTag,
                                  const std::string& documentId) const
    {
        if (index == PACKAGE_INDEX)
        {
            auto packageInfo = extractPackageInfo(doc);

            // Bind package id to the inventory document id (DataValue/DataContext id)
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "%s: %s package '%s' (%s, item_id='%s')",
                      sourceTag,
                      (operation == ElementOperation::Delete ? "DELETE" : "UPSERT"),
                      packageInfo.name.c_str(),
                      packageInfo.version.c_str(),
                      documentId.c_str());

            const auto detectionIdBase = context->buildPackageDetectionIdBase(documentId);
            context->addPackageToContext(detectionIdBase, std::move(packageInfo), operation);
        }
        else if (index == OS_INDEX)
        {
            auto osData = extractOSFromHostDocument(doc);

            // Use the inventory document id as OS item_id.
            if (!documentId.empty())
            {
                osData.item_id = documentId;
            }

            if (operation == ElementOperation::Delete)
            {
                // For OS delete operations we only track the deleted OS item_id
                // and basic OS info in the ScanContext, without overriding the current OS cache.
                if (!osData.item_id.empty())
                {
                    context->setDeletedOSData(osData);

                    logDebug1(WM_VULNSCAN_LOGTAG,
                              "%s (OS): DELETE operation - deleted OS registered: '%s' (%s)",
                              sourceTag,
                              osData.item_id.c_str(),
                              osData.version.c_str());
                }
                else
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "%s (OS): DELETE operation received but no 'item_id' found in document",
                            sourceTag);
                }
            }
            else
            {
                // Upsert/DataContext â†’ represents the OS installed on the system
                // for this inventory entry. We keep using the OS cache for this.
                context->setOSData(osData);

                logDebug1(WM_VULNSCAN_LOGTAG,
                          "%s (OS): OS data loaded - %s %s (platform: %s, arch: %s)",
                          sourceTag,
                          osData.name.c_str(),
                          osData.version.c_str(),
                          osData.platform.c_str(),
                          osData.architecture.c_str());
            }
        }
        else if (index == HOTFIX_INDEX)
        {
            auto hotfixData = extractHotfixInfo(doc);

            if (!hotfixData.hotfixName.empty())
            {
                // For hotfixes the ScanContext only stores currently installed
                // hotfixes. Delete operations are ignored, Upserts are stored.
                if (operation == ElementOperation::Delete)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "%s: DELETE for hotfix '%s' ignored (not added to context)",
                              sourceTag,
                              hotfixData.hotfixName.c_str());
                }
                else
                {
                    context->addHotfixToContext(std::move(hotfixData));

                    const auto& lastHotfix = context->getHotfixContextData(context->hotfixCount() - 1);

                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "%s: Hotfix '%s' registered for agent '%s'",
                              sourceTag,
                              lastHotfix.hotfixName.c_str(),
                              context->agentId().data());
                }
            }
            else
            {
                logWarn(WM_VULNSCAN_LOGTAG, "%s: Empty hotfix name, skipping", sourceTag);
            }
        }
    }

    /**
     * @brief Parse FlatBuffer message and add to scan context.
     *
     * @param value RocksDB value (serialized FlatBuffer).
     * @param context Scan context to populate.
     * @param parser simdjson parser instance.
     */
    void parseAndAddMessage(const rocksdb::Slice& value,
                            std::shared_ptr<TScanContext>& context,
                            simdjson::ondemand::parser& parser) const
    {
        // Verify FlatBuffer
        flatbuffers::Verifier verifier(reinterpret_cast<const uint8_t*>(value.data()), value.size());

        if (!Wazuh::SyncSchema::VerifyMessageBuffer(verifier))
        {
            logWarn(WM_VULNSCAN_LOGTAG, "Invalid FlatBuffer message, skipping");
            return;
        }

        auto message = Wazuh::SyncSchema::GetMessage(value.data());

        // Handle DataValue messages
        if (message->content_type() == Wazuh::SyncSchema::MessageType_DataValue)
        {
            auto data = message->content_as_DataValue();
            if (!data || !data->data() || data->data()->size() == 0)
            {
                return;
            }

            // Inventory document id (used as package item_id)
            std::string documentId;
            if (data->id())
            {
                documentId = data->id()->str();
            }

            try
            {
                // Parse JSON from data field (contains inventory document)
                simdjson::padded_string paddedJson(reinterpret_cast<const char*>(data->data()->data()),
                                                   data->data()->size());

                auto docResult = parser.iterate(paddedJson);
                if (docResult.error() != simdjson::SUCCESS)
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "Failed to iterate DataValue JSON: %s",
                            simdjson::error_message(docResult.error()));
                    return;
                }

                simdjson::ondemand::document doc = std::move(docResult).value();

                // Determine index type
                std::string index = data->index() ? data->index()->str() : "";

                // DataValue carries an operation (Insert / Delete)
                ElementOperation operation = (data->operation() == Wazuh::SyncSchema::Operation_Delete)
                                                 ? ElementOperation::Delete
                                                 : ElementOperation::Upsert;

                processInventoryDocument(index, doc, context, operation, "DataValue", documentId);
            }
            catch (const simdjson::simdjson_error& e)
            {
                logWarn(WM_VULNSCAN_LOGTAG, "Failed to parse DataValue JSON: %s", simdjson::error_message(e.error()));
            }
        }
        // Handle DataContext messages
        else if (message->content_type() == Wazuh::SyncSchema::MessageType_DataContext)
        {
            auto data = message->content_as_DataContext();
            if (!data || !data->data() || data->data()->size() == 0)
            {
                return;
            }

            // Inventory document id (used as package item_id)
            std::string documentId;
            if (data->id())
            {
                documentId = data->id()->str();
            }

            try
            {
                simdjson::padded_string paddedJson(reinterpret_cast<const char*>(data->data()->data()),
                                                   data->data()->size());

                auto docResult = parser.iterate(paddedJson);
                if (docResult.error() != simdjson::SUCCESS)
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "Failed to iterate DataContext JSON: %s",
                            simdjson::error_message(docResult.error()));
                    return;
                }

                simdjson::ondemand::document doc = std::move(docResult).value();

                std::string index = data->index() ? data->index()->str() : "";

                // DataContext is always treated as an Upsert of details.
                ElementOperation operation = ElementOperation::Upsert;

                processInventoryDocument(index, doc, context, operation, "DataContext", documentId);
            }
            catch (const simdjson::simdjson_error& e)
            {
                logWarn(WM_VULNSCAN_LOGTAG, "Failed to parse DataContext JSON: %s", simdjson::error_message(e.error()));
            }
        }
    }

    /**
     * @brief Extract OS information from the new inventory-sync payload (top-level "host" object).
     *
     * Expected structure (example):
     * {
     *   "checksum": {...},
     *   "host": {
     *     "architecture": "aarch64",
     *     "hostname": "ubuntu24",
     *     "os": {
     *       "build": "...",
     *       "codename": "noble",
     *       "distribution": { "release": "..." },
     *       "full": "...",
     *       "kernel": {
     *         "name": "Linux",
     *         "release": "6.8.0-71-generic",
     *         "version": "#71-Ubuntu SMP ..."
     *       },
     *       "major": "24",
     *       "minor": "04",
     *       "name": "Ubuntu",
     *       "patch": "2",
     *       "platform": "ubuntu",
     *       "type": "linux",
     *       "version": "24.04.2 LTS (Noble Numbat)"
     *     }
     *   },
     *   "state": {...}
     * }
     */
    OsContextData extractOSFromHostDocument(simdjson::ondemand::document& doc) const
    {
        OsContextData osData;

        try
        {
            for (auto topField : doc.get_object())
            {
                std::string_view topKey = topField.unescaped_key().value();

                if (topKey == "host")
                {
                    auto hostValue = topField.value();
                    if (hostValue.is_null())
                    {
                        continue;
                    }

                    auto hostObj = hostValue.get_object().value();

                    for (auto hostField : hostObj)
                    {
                        std::string_view hostKey = hostField.unescaped_key().value();
                        auto hostFieldValue = hostField.value();

                        if (hostFieldValue.is_null())
                        {
                            continue;
                        }

                        if (hostKey == "hostname")
                        {
                            auto strResult = hostFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                osData.hostName = std::string(strResult.value());
                            }
                        }
                        else if (hostKey == "architecture")
                        {
                            auto strResult = hostFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                osData.architecture = std::string(strResult.value());
                            }
                        }
                        else if (hostKey == "os")
                        {
                            auto osObj = hostFieldValue.get_object().value();

                            for (auto osField : osObj)
                            {
                                std::string_view osKey = osField.unescaped_key().value();
                                auto osFieldValue = osField.value();

                                if (osFieldValue.is_null())
                                {
                                    continue;
                                }

                                if (osKey == "item_id")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.item_id = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "name")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.name = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "platform")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.platform = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "type")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.sysName = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "version")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.version = std::string(strResult.value());

                                        if (osData.displayVersion.empty())
                                        {
                                            osData.displayVersion = osData.version;
                                        }
                                    }
                                }
                                else if (osKey == "full")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.displayVersion = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "codename")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.codeName = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "major")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.majorVersion = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "minor")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.minorVersion = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "patch")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.patch = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "build")
                                {
                                    auto strResult = osFieldValue.get_string();
                                    if (strResult.error() == simdjson::SUCCESS)
                                    {
                                        osData.build = std::string(strResult.value());
                                    }
                                }
                                else if (osKey == "distribution")
                                {
                                    auto distObj = osFieldValue.get_object().value();
                                    for (auto distField : distObj)
                                    {
                                        std::string_view distKey = distField.unescaped_key().value();
                                        auto distValue = distField.value();

                                        if (distValue.is_null())
                                        {
                                            continue;
                                        }

                                        if (distKey == "release")
                                        {
                                            auto strResult = distValue.get_string();
                                            if (strResult.error() == simdjson::SUCCESS)
                                            {
                                                osData.release = std::string(strResult.value());
                                            }
                                        }
                                    }
                                }
                                else if (osKey == "kernel")
                                {
                                    auto kernelObj = osFieldValue.get_object().value();
                                    for (auto kField : kernelObj)
                                    {
                                        std::string_view kKey = kField.unescaped_key().value();
                                        auto kValue = kField.value();

                                        if (kValue.is_null())
                                        {
                                            continue;
                                        }

                                        if (kKey == "version")
                                        {
                                            auto strResult = kValue.get_string();
                                            if (strResult.error() == simdjson::SUCCESS)
                                            {
                                                osData.kernelVersion = std::string(strResult.value());
                                            }
                                        }
                                        else if (kKey == "release")
                                        {
                                            auto strResult = kValue.get_string();
                                            if (strResult.error() == simdjson::SUCCESS)
                                            {
                                                osData.kernelRelease = std::string(strResult.value());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (!osData.name.empty() || !osData.platform.empty() || !osData.version.empty())
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Extracted OS from host document: name='%s', version='%s', platform='%s', arch='%s'",
                          osData.name.c_str(),
                          osData.version.c_str(),
                          osData.platform.c_str(),
                          osData.architecture.c_str());
            }
        }
        catch (const simdjson::simdjson_error& e)
        {
            logError(
                WM_VULNSCAN_LOGTAG, "Error extracting OS from host document: %s", simdjson::error_message(e.error()));
        }

        return osData;
    }

    /**
     * @brief Extract package information from simdjson document.
     *
     * @param doc simdjson document.
     * @return PackageContextData with extracted data.
     */
    PackageContextData extractPackageInfo(simdjson::ondemand::document& doc) const
    {
        PackageContextData info;

        try
        {
            for (auto field : doc.get_object())
            {
                std::string_view key = field.unescaped_key().value();

                if (key == "package")
                {
                    auto pkgValue = field.value();

                    // Check if package field is null
                    if (pkgValue.is_null())
                    {
                        logWarn(WM_VULNSCAN_LOGTAG, "Package field is null");
                        continue;
                    }

                    auto pkg = pkgValue.get_object().value();

                    for (auto pkgField : pkg)
                    {
                        std::string_view pkgKey = pkgField.unescaped_key().value();
                        auto pkgFieldValue = pkgField.value();

                        // Check for null before accessing typed values
                        if (pkgFieldValue.is_null())
                        {
                            continue;
                        }

                        if (pkgKey == "name")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.name = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "version")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.version = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "type")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.format = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "architecture")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.architecture = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "vendor")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.vendor = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "description")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.description = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "installed")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.install_time = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "size")
                        {
                            auto sizeResult = pkgFieldValue.get_uint64();
                            if (sizeResult.error() == simdjson::SUCCESS)
                            {
                                info.size = sizeResult.value();
                            }
                        }
                        else if (pkgKey == "source")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.source = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "path")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.location = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "priority")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.priority = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "multiarch")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.multiarch = std::string(strResult.value());
                            }
                        }
                        else if (pkgKey == "category")
                        {
                            auto strResult = pkgFieldValue.get_string();
                            if (strResult.error() == simdjson::SUCCESS)
                            {
                                info.groups = std::string(strResult.value());
                            }
                        }
                    }
                }
            }

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Extracted package: name='%s', version='%s', type='%s', vendor='%s'",
                      info.name.c_str(),
                      info.version.c_str(),
                      info.format.c_str(),
                      info.vendor.c_str());
        }
        catch (const simdjson::simdjson_error& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Error extracting package info: %s", simdjson::error_message(e.error()));
        }

        return info;
    }

    /**
     * @brief Extract hotfix information from simdjson document.
     *
     * Expected structure fragment:
     * {
     *   "package": {
     *     ...
     *     "hotfix": {
     *       "name": "KB123456",
     *       ...
     *     }
     *   }
     * }
     */
    HotfixContextData extractHotfixInfo(simdjson::ondemand::document& doc) const
    {
        HotfixContextData hotfix;

        try
        {
            for (auto field : doc.get_object())
            {
                std::string_view key = field.unescaped_key().value();

                if (key == "package")
                {
                    auto pkgValue = field.value();

                    if (pkgValue.is_null())
                    {
                        continue;
                    }

                    auto pkg = pkgValue.get_object().value();

                    for (auto pkgField : pkg)
                    {
                        std::string_view pkgKey = pkgField.unescaped_key().value();

                        if (pkgKey == "hotfix")
                        {
                            auto hotfixValue = pkgField.value();

                            if (hotfixValue.is_null())
                            {
                                continue;
                            }

                            auto hotfixObj = hotfixValue.get_object().value();

                            for (auto hotfixField : hotfixObj)
                            {
                                std::string_view hotfixFieldKey = hotfixField.unescaped_key().value();

                                if (hotfixFieldKey == "name")
                                {
                                    auto nameValue = hotfixField.value();
                                    if (!nameValue.is_null())
                                    {
                                        auto nameResult = nameValue.get_string();
                                        if (nameResult.error() == simdjson::SUCCESS)
                                        {
                                            hotfix.hotfixName = std::string(nameResult.value());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            logDebug2(WM_VULNSCAN_LOGTAG, "Extracted hotfix: name='%s'", hotfix.hotfixName.c_str());
        }
        catch (const simdjson::simdjson_error& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Error extracting hotfix info: %s", simdjson::error_message(e.error()));
        }

        return hotfix;
    }

    // Dependencies
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;
    std::shared_mutex& m_mutex;

    // Orchestration chains (built once, reused)
    std::shared_ptr<TOrchestrationNode> m_packageDeltaOrchestration;
    std::shared_ptr<TOrchestrationNode> m_firstFullScanOrchestration;
    std::shared_ptr<TOrchestrationNode> m_fullScanOrchestration;
};

using ScanOrchestrator = TScanOrchestrator<>;

#endif // _SCAN_ORCHESTRATOR_HPP
