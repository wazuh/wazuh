/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _FACTORY_ORCHESTRATOR_HPP
#define _FACTORY_ORCHESTRATOR_HPP

#include "chainOfResponsability.hpp"
#include "detailsAugmentation.hpp"
#include "inventorySync.hpp"
#include "osScanner.hpp"
#include "packageScanner.hpp"
#include "resultIndexer.hpp"
#include "sendReport.hpp"
#include "socketClient.hpp"
#include <iostream>
#include <memory>

/**
 * @brief FactoryOrchestrator class.
 *
 */
class FactoryOrchestrator final
{
    // LCOV_EXCL_START
private:
    FactoryOrchestrator() = default;

public:
    /**
     * @brief Creates an orchestrator and returns it.
     *
     * @param type Scanner type.
     * @param databaseFeedManager DatabaseFeedManager object.
     * @param indexerConnector Indexer connector object.
     * @param inventoryDatabase Inventory database.
     * @param reportSocketClient Socket client to send vulnerability reports.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    static std::shared_ptr<AbstractHandler<std::shared_ptr<ScanContext>>>
    create(ScannerType type,
           std::shared_ptr<DatabaseFeedManager> databaseFeedManager,
           std::shared_ptr<IndexerConnector> indexerConnector,
           Utils::RocksDBWrapper& inventoryDatabase,
           std::shared_ptr<SocketClient<Socket<OSPrimitives, NoHeaderProtocol>, EpollWrapper>> reportSocketClient)
    {
        std::shared_ptr<AbstractHandler<std::shared_ptr<ScanContext>>> orchestration;
        if (type == ScannerType::PackageInsert)
        {
            orchestration = std::make_shared<PackageScanner>(databaseFeedManager);
            orchestration->setLast(std::make_shared<DetailsAugmentation>(databaseFeedManager));
        }
        else if (type == ScannerType::PackageDelete)
        {
        }
        else if (type == ScannerType::HotfixInsert)
        {
            std::cout << "Hotfix insert scanner Init" << std::endl;
            // orchestration = std::make_shared<HotfixScanner>();
        }
        else if (type == ScannerType::HotfixDelete)
        {
            std::cout << "Hotfix delete scanner Init" << std::endl;
            // orchestration = std::make_shared<DeleteHotfixVulnerabilities>();
        }
        else if (type == ScannerType::Os)
        {
            orchestration = std::make_shared<OsScanner>();
            // orchestration->setLast(std::make_shared<CheckRemediations>());
        }
        else
        {
            throw std::runtime_error("Invalid scanner type");
        }

        if (orchestration == nullptr)
        {
            orchestration = std::make_shared<InventorySync>(inventoryDatabase);
        }
        else
        {
            orchestration->setLast(std::make_shared<InventorySync>(inventoryDatabase));
        }

        orchestration->setLast(std::make_shared<SendReport>(reportSocketClient));
        orchestration->setLast(std::make_shared<ResultIndexer>(indexerConnector));
        return orchestration;
    }
    // LCOV_EXCL_STOP
};

#endif // _FACTORY_ORCHESTRATOR_HPP
