/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 11, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _BUILD_ALL_AGENT_INFO_CONTEXT_HPP
#define _BUILD_ALL_AGENT_INFO_CONTEXT_HPP

#include "chainOfResponsability.hpp"
#include "json.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "socketDBWrapper.hpp"
#include "stringHelper.h"
#include "wazuhDBQueryBuilder.hpp"

/**
 * @brief Orchestrates queries over the global Wazuh system.
 *
 * This class is responsible for retrieving the agent list from global.db and
 * populating the ScanContext with the agents that should be scanned.
 *
 * @tparam TScanContext scan context type.
 */
template<typename TScanContext = ScanContext, typename TSocketDBWrapper = SocketDBWrapper>
class TBuildAllAgentListContext final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    static std::string normalizeAgentId(const nlohmann::json& agent)
    {
        if (!agent.contains("id"))
        {
            return {};
        }

        if (agent.at("id").is_number_integer())
        {
            const auto idValue = agent.at("id").get<int>();
            return Utils::padString(std::to_string(idValue), '0', 3);
        }

        if (agent.at("id").is_string())
        {
            auto idValue = agent.at("id").get<std::string>();
            if (Utils::isNumber(idValue) && idValue.size() < 3)
            {
                return Utils::padString(idValue, '0', 3);
            }
            return idValue;
        }

        return {};
    }

    static void fillAgentGroups(const nlohmann::json& agent, AgentContextData& agentData)
    {
        if (agent.contains("group") && agent.at("group").is_string())
        {
            agentData.groups.emplace_back(agent.at("group").get<std::string>());
        }

        if (agent.contains("groups") && agent.at("groups").is_array())
        {
            for (const auto& group : agent.at("groups"))
            {
                if (group.is_string())
                {
                    agentData.groups.emplace_back(group.get<std::string>());
                }
            }
        }
    }

    static AgentContextData buildAgentContextData(const nlohmann::json& agent, std::string agentId)
    {
        AgentContextData agentData {};
        agentData.id = std::move(agentId);
        agentData.name = agent.value("name", std::string {});
        agentData.version = Utils::leftTrim(agent.value("version", std::string {}), "Wazuh ");
        agentData.ip = agent.value("ip", std::string {});
        const auto architectureFallback = agent.value("os_arch", std::string {});
        const auto hostnameFallback = agent.value("name", std::string {});
        const auto osTypeFallback = agent.value("os_uname", std::string {});
        agentData.hostArchitecture = agent.value("architecture", architectureFallback);
        agentData.hostHostname = agent.value("hostname", hostnameFallback);
        agentData.hostOsName = agent.value("os_name", std::string {});
        agentData.hostOsPlatform = agent.value("os_platform", std::string {});
        agentData.hostOsType = agent.value("os_type", osTypeFallback);
        agentData.hostOsVersion = agent.value("os_version", std::string {});
        fillAgentGroups(agent, agentData);
        return agentData;
    }

public:
    /**
     * @brief Construct a new global fetch object.
     */
    explicit TBuildAllAgentListContext() = default;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data A shared pointer to the input data containing details of the query request.
     *
     * @return A shared pointer to a `TScanContext` object representing the query response.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        if (!data)
        {
            logWarn(WM_VULNSCAN_LOGTAG, "BuildAllAgentListContext received null ScanContext.");
            return nullptr;
        }

        nlohmann::json response;

        try
        {
            TSocketDBWrapper::instance().query(
                WazuhDBQueryBuilder::builder().globalGetCommand("all-agents context").build(), response);
        }
        catch (const SocketDbWrapperException& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Unable to retrieve global agents data. Reason: %s.", e.what());
            return nullptr;
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Unable to retrieve global agents data. Reason: %s.", e.what());
            return nullptr;
        }

        const bool isWorker = data->clusterIsWorker();
        const std::string nodeName {data->clusterNodeName()};

        for (const auto& agent : response)
        {
            const auto agentId = normalizeAgentId(agent);

            if (agentId.empty())
            {
                continue;
            }

            const auto connectionStatus = agent.value("connection_status", std::string {});
            const auto agentNodeName = agent.value("node_name", std::string {});

            bool includeAgent = false;
            if (isWorker)
            {
                includeAgent = (connectionStatus == "active" && !nodeName.empty() && agentNodeName == nodeName);
            }
            else
            {
                if (connectionStatus == "active")
                {
                    includeAgent = (nodeName.empty() || agentNodeName == nodeName);
                }
                else if (connectionStatus == "disconnected")
                {
                    includeAgent = true;
                }
            }

            if (!includeAgent)
            {
                logDebug2(
                    WM_VULNSCAN_LOGTAG,
                    "Agent %s not added to scan list (worker=%s, node_name=%s, connection_status=%s, agent_node=%s)",
                    agentId.c_str(),
                    isWorker ? "true" : "false",
                    nodeName.c_str(),
                    connectionStatus.c_str(),
                    agentNodeName.c_str());
                continue;
            }

            data->m_agents.emplace_back(buildAgentContextData(agent, agentId));
        }

        logDebug2(WM_VULNSCAN_LOGTAG, "Fetched %zu agents from global.db.", data->m_agents.size());
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using BuildAllAgentListContext = TBuildAllAgentListContext<>;

#endif // _BUILD_ALL_AGENT_INFO_CONTEXT_HPP
