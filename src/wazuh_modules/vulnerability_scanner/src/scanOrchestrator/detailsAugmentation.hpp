/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * Nov 23, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _DETAILS_AUGMENTATION_HPP
#define _DETAILS_AUGMENTATION_HPP

#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "numericHelper.h"
#include "scanContext.hpp"
#include "timeHelper.h"

/**
 * @brief TDetailsAugmentation class.
 *
 * @tparam TDatabaseFeedManager database feed manager type.
 * @tparam TScanContext scan context type.
 */
template<typename TDatabaseFeedManager = DatabaseFeedManager, typename TScanContext = ScanContext>
class TDetailsAugmentation final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;
    std::string ECS_VERSION = "8.11.0";

    /**
     * @brief Populate a JSON field with a value if the value is non-empty (for strings) or always (for other types).
     *
     * This function takes a JSON object, a JSON pointer specifying the field to populate, and a value to populate the
     * field with. If the value is a string or a string view and is not empty, it will populate the field in the JSON
     * object. For other types, the field will be populated regardless of the value.
     *
     * @tparam T       The type of the value to populate the field with.
     * @param json     The JSON object to populate.
     * @param key      The JSON pointer specifying the field to populate.
     * @param value    The value to populate the field with.
     */
    template<typename T>
    void populateField(nlohmann::json& json, const nlohmann::json::json_pointer& key, T&& value)
    {
        if constexpr (std::is_same_v<std::remove_cv_t<std::remove_reference_t<T>>, std::string_view> ||
                      std::is_same_v<T, std::string>)
        {
            if (!value.empty() && !value.find_first_not_of(' '))
            {
                json[key] = value;
            }
        }
        else
        {
            json[key] = value;
        }
    }

    void indexedDataAugmentation(std::shared_ptr<TScanContext> data)
    {
        if (data->getType() != ScannerType::PackageInsert)
        {
            return;
        }

        nlohmann::json package;
        populateField(package, "/architecture"_json_pointer, data->packageArchitecture());
        populateField(package, "/description"_json_pointer, data->packageDescription());

        if (!data->packageInstallTime().empty())
        {
            const auto installTime {Utils::rawTimestampToISO8601(data->packageInstallTime().data())};
            if (!installTime.empty())
            {
                package["installed"] = installTime;
            }
        }
        populateField(package, "/name"_json_pointer, data->packageName());
        populateField(package, "/path"_json_pointer, data->packageLocation());
        populateField(package, "/size"_json_pointer, data->packageSize());
        populateField(package, "/type"_json_pointer, data->packageFormat());
        populateField(package, "/version"_json_pointer, data->packageVersion());

        nlohmann::json ecs;
        populateField(ecs, "/version"_json_pointer, ECS_VERSION);

        nlohmann::json agent;
        populateField(agent, "/build/original"_json_pointer, " "); // The revision isn't reported by the agents.
        populateField(agent, "/ephemeral_id"_json_pointer, data->agentNodeName());
        populateField(agent, "/id"_json_pointer, data->agentId());
        populateField(agent, "/name"_json_pointer, data->agentName());
        populateField(agent, "/type"_json_pointer, "wazuh");
        populateField(agent, "/version"_json_pointer, data->agentVersion());

        nlohmann::json os;
        std::string fullName;
        fullName.append(data->osName().data());
        fullName.append(" ");
        fullName.append(data->osPlatform().compare("darwin") == 0 ? data->osCodeName().data()
                                                                  : data->osVersion().data());

        std::string version = data->osMajorVersion().data();
        if (!data->osMinorVersion().empty())
        {
            version += ".";
            version += data->osMinorVersion();
        }
        if (!data->osPatch().empty())
        {
            version += ".";
            version += data->osPatch();
        }
        if (!data->osBuild().empty())
        {
            version += ".";
            version += data->osBuild();
        }

        populateField(os, "/full"_json_pointer, fullName);
        populateField(os, "/kernel"_json_pointer, data->osKernelRelease());
        populateField(os, "/name"_json_pointer, data->osName());
        populateField(os, "/platform"_json_pointer, Utils::toLowerCase(data->osPlatform().data()));
        populateField(
            os,
            "/type"_json_pointer,
            Utils::toLowerCase(data->osPlatform().compare("darwin") == 0 ? "macos" : data->osPlatform().data()));
        populateField(os, "/version"_json_pointer, version);

        for (auto& [cve, json] : data->m_elements)
        {
            FlatbufferDataPair<VulnerabilityDescription> returnData;
            m_databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, returnData);
            if (returnData.data)
            {
                auto ecsData = nlohmann::json::object();
                // ECS agent fields.
                ecsData["agent"] = agent;
                // ECS fields.
                ecsData["ecs"] = ecs;
                // ECS package fields.
                ecsData["package"] = package;
                // ECS os fields.
                ecsData["host"]["os"] = os;
                // ECS vulnerability fields.
                ecsData["vulnerability"]["category"] = "Packages";
                ecsData["vulnerability"]["classification"] = returnData.data->classification()->str();
                ecsData["vulnerability"]["description"] = returnData.data->description()->str();
                ecsData["vulnerability"]["enumeration"] = "CVE";
                ecsData["vulnerability"]["id"] = cve;
                ecsData["vulnerability"]["reference"] = returnData.data->reference()->str();
                ecsData["vulnerability"]["scanner"]["vendor"] = "Wazuh";
                ecsData["vulnerability"]["score"]["base"] = Utils::floatToDoubleRound(returnData.data->scoreBase(), 2);
                ecsData["vulnerability"]["score"]["version"] = returnData.data->scoreVersion()->str();
                ecsData["vulnerability"]["severity"] = Utils::toSentenceCase(returnData.data->severity()->str());
                // ECS wazuh fields.
                auto vulnerabilityDetection = PolicyManager::instance().getVulnerabilityDetection();
                ecsData["wazuh"]["cluster"]["name"] =
                    vulnerabilityDetection.contains("clusterName") ? vulnerabilityDetection.at("clusterName") : "";
                // ECS base fields.
                ecsData["@timestamp"] = Utils::getCurrentISO8601();

                json["operation"] = "INSERTED";
                json["id"] = std::string(data->agentNodeName()) + "_" + std::string(data->agentId()) + "_" +
                             std::string(data->packageItemId()) + "_" + cve;
                json["data"] = std::move(ecsData);
            }
        }
    }

    void alertedDataAugmentation(std::shared_ptr<TScanContext> data)
    {
        if (data->getType() != ScannerType::IntegrityClear)
        {
            const std::string pkgArchitecture {data->packageArchitecture()};
            const std::string pkgName {data->packageName()};
            const std::string pkgVersion {data->packageVersion()};
            const std::string pkgSource {data->packageSource()};

            for (auto& [cve, json] : data->m_alerts)
            {
                FlatbufferDataPair<VulnerabilityDescription> returnData;
                m_databaseFeedManager->getVulnerabiltyDescriptiveInformation(cve, returnData);
                if (returnData.data)
                {
                    const std::string cvssVersion {returnData.data->scoreVersion()->str()};
                    const std::string scoreVersion {"cvss" + cvssVersion.substr(0, 1)};

                    if (data->getType() == ScannerType::PackageInsert)
                    {
                        if (!cvssVersion.empty())
                        {
                            nlohmann::json vectorObj;
                            if (scoreVersion.compare("cvss2") == 0)
                            {
                                vectorObj["access_complexity"] = returnData.data->accessComplexity()->str();
                                vectorObj["authentication"] = returnData.data->authentication()->str();
                            }
                            else if (scoreVersion.compare("cvss3") == 0)
                            {
                                vectorObj["attack_vector"] = returnData.data->attackVector()->str();
                                vectorObj["privileges_required"] = returnData.data->privilegesRequired()->str();
                                vectorObj["scope"] = returnData.data->scope()->str();
                                vectorObj["user_interaction"] = returnData.data->userInteraction()->str();
                            }

                            vectorObj["availability"] = returnData.data->availabilityImpact()->str();
                            vectorObj["confidentiality_impact"] = returnData.data->confidentialityImpact()->str();
                            vectorObj["integrity_impact"] = returnData.data->integrityImpact()->str();

                            json["vulnerability"]["cvss"][scoreVersion]["vector"] = std::move(vectorObj);
                        }

                        json["vulnerability"]["assigner"] = returnData.data->assignerShortName()->str();
                        json["vulnerability"]["cwe_reference"] = returnData.data->cweId()->str();
                        json["vulnerability"]["package"]["source"] = pkgSource;
                        json["vulnerability"]["rationale"] = returnData.data->description()->str();
                    }

                    json["vulnerability"]["cve"] = cve;
                    if (!cvssVersion.empty())
                    {
                        json["vulnerability"]["cvss"][scoreVersion]["base_score"] =
                            Utils::floatToDoubleRound(returnData.data->scoreBase(), 2);
                    }
                    json["vulnerability"]["enumeration"] = "CVE";
                    json["vulnerability"]["package"]["architecture"] = pkgArchitecture;
                    json["vulnerability"]["package"]["name"] = pkgName;
                    json["vulnerability"]["package"]["version"] = pkgVersion;
                    json["vulnerability"]["published"] = returnData.data->datePublished()->str();
                    json["vulnerability"]["reference"] = returnData.data->reference()->str();
                    json["vulnerability"]["severity"] = Utils::toSentenceCase(returnData.data->severity()->str());
                    json["vulnerability"]["status"] =
                        data->getType() == ScannerType::PackageInsert ? "Active" : "Solved";

                    // The title is different depending on the type of the alert.
                    // title = CVE-XXXX-XXXX affecting <package name> was solved
                    // title = CVE-XXXX-XXXX affects <package name>
                    std::string title {cve};

                    if (data->getType() == ScannerType::PackageInsert)
                    {
                        title.append(" affects ");
                        title.append(pkgName);
                    }
                    else
                    {
                        title.append(" affecting ");
                        title.append(pkgName);
                        title.append(" was solved");
                    }

                    json["vulnerability"]["title"] = title;
                    json["vulnerability"]["type"] = "Packages";
                    json["vulnerability"]["updated"] = returnData.data->dateUpdated()->str();
                }
            }
        }
        else
        {
            // If the database is empty, we don't need to send the alert.
            // If the database is empty, this means that the vulnerability scanner not have detected any package in
            // the system. So, we don't need to send the alert.
            if (!data->m_isInventoryEmpty)
            {
                nlohmann::json report;

                report["vulnerability"]["status"] = "Clear";
                report["vulnerability"]["title"] =
                    "There is no information of installed packages. Vulnerabilities cleared.";
                report["vulnerability"]["type"] = "Packages";

                data->m_alerts["clear"] = std::move(report);
            }
        }
    }

public:
    // LCOV_EXCL_START
    /**
     * @brief DetailsAugmentation constructor.
     *
     * @param databaseFeedManager Database feed manager.
     */
    explicit TDetailsAugmentation(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager)
        : m_databaseFeedManager(databaseFeedManager)
    {
    }

    /**
     * @brief Class destructor.
     *
     */
    ~TDetailsAugmentation() = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        indexedDataAugmentation(data);
        alertedDataAugmentation(data);

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using DetailsAugmentation = TDetailsAugmentation<>;

#endif // _DETAILS_AUGMENTATION_HPP
