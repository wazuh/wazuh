/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 13, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_AGENT_LIST_HPP
#define _SCAN_AGENT_LIST_HPP

#include "agentReScanListException.hpp"
#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "json.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "stringHelper.h"
#include <functional>
#include <memory>
#include <string>
#include <utility>
#include <vector>

/**
 * @brief Builds full scan contexts from indexer inventory data and triggers a scan per agent.
 *
 * @tparam TScanContext scan context type.
 * @tparam TIndexerConnector indexer connector type.
 */
template<typename TScanContext = ScanContext, typename TIndexerConnector = IndexerConnectorSync>
class TScanAgentList final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
public:
    using ScanRunner = std::function<void(std::shared_ptr<TScanContext>)>;

private:
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    ScanRunner m_scanRunner;
    static constexpr size_t DEFAULT_PAGE_SIZE = 1000;

    static nlohmann::json buildInventoryQuery(const std::string& agentId,
                                              std::size_t size,
                                              const std::string& searchAfter,
                                              const std::vector<std::string>& sourceFields)
    {
        nlohmann::json query = {{"_source", sourceFields},
                                {"query", {{"term", {{"wazuh.agent.id", agentId}}}}},
                                {"size", size},
                                {"sort", {{{"_id", {{"order", "asc"}}}}}}};

        if (!searchAfter.empty())
        {
            query["search_after"] = {searchAfter};
        }

        return query;
    }

    template<typename Callback>
    void fetchInventoryDocuments(const std::string& index,
                                 const std::string& agentId,
                                 const std::vector<std::string>& sourceFields,
                                 Callback&& onHit) const
    {
        std::string searchAfter;

        while (true)
        {
            const auto query = buildInventoryQuery(agentId, DEFAULT_PAGE_SIZE, searchAfter, sourceFields);
            const auto response = m_indexerConnector->executeSearchQuery(index, query);

            if (!response.contains("hits") || !response["hits"].is_object())
            {
                return;
            }

            const auto& hitsObj = response["hits"];
            if (!hitsObj.contains("hits") || !hitsObj["hits"].is_array())
            {
                return;
            }

            const auto& hits = hitsObj["hits"];
            if (hits.empty())
            {
                return;
            }

            for (const auto& hit : hits)
            {
                onHit(hit);
                if (hit.contains("_id") && hit["_id"].is_string())
                {
                    searchAfter = hit["_id"].template get<std::string>();
                }
            }

            if (hits.size() < DEFAULT_PAGE_SIZE)
            {
                return;
            }
        }
    }

    static std::string getStringOrEmpty(const nlohmann::json& obj, const char* key)
    {
        const auto it = obj.find(key);
        if (it == obj.end() || it->is_null())
        {
            return {};
        }

        if (!it->is_string())
        {
            return {};
        }

        return it->get<std::string>();
    }

    static OsContextData parseOsFromSource(const nlohmann::json& source)
    {
        OsContextData osData;

        if (!source.contains("host") || !source["host"].is_object())
        {
            return osData;
        }

        const auto& host = source["host"];
        osData.hostName = getStringOrEmpty(host, "hostname");
        osData.architecture = getStringOrEmpty(host, "architecture");

        if (!host.contains("os") || !host["os"].is_object())
        {
            return osData;
        }

        const auto& os = host["os"];
        osData.item_id = getStringOrEmpty(os, "item_id");
        osData.name = getStringOrEmpty(os, "name");
        osData.platform = getStringOrEmpty(os, "platform");
        osData.sysName = getStringOrEmpty(os, "type");
        osData.version = getStringOrEmpty(os, "version");
        osData.displayVersion = getStringOrEmpty(os, "full");
        if (osData.displayVersion.empty())
        {
            osData.displayVersion = osData.version;
        }

        osData.codeName = getStringOrEmpty(os, "codename");
        osData.majorVersion = getStringOrEmpty(os, "major");
        osData.minorVersion = getStringOrEmpty(os, "minor");
        osData.patch = getStringOrEmpty(os, "patch");
        osData.build = getStringOrEmpty(os, "build");

        if (os.contains("distribution") && os["distribution"].is_object())
        {
            osData.release = getStringOrEmpty(os["distribution"], "release");
        }

        if (os.contains("kernel") && os["kernel"].is_object())
        {
            const auto& kernel = os["kernel"];
            osData.kernelVersion = getStringOrEmpty(kernel, "version");
            osData.kernelRelease = getStringOrEmpty(kernel, "release");
        }

        return osData;
    }

    static PackageContextData parsePackageFromSource(const nlohmann::json& source)
    {
        PackageContextData pkg;

        if (!source.contains("package") || !source["package"].is_object())
        {
            return pkg;
        }

        const auto& pkgObj = source["package"];
        pkg.name = getStringOrEmpty(pkgObj, "name");
        pkg.version = getStringOrEmpty(pkgObj, "version");
        pkg.format = getStringOrEmpty(pkgObj, "type");
        pkg.architecture = getStringOrEmpty(pkgObj, "architecture");
        pkg.vendor = getStringOrEmpty(pkgObj, "vendor");
        pkg.description = getStringOrEmpty(pkgObj, "description");
        pkg.install_time = getStringOrEmpty(pkgObj, "installed");
        pkg.source = getStringOrEmpty(pkgObj, "source");
        pkg.location = getStringOrEmpty(pkgObj, "path");
        pkg.priority = getStringOrEmpty(pkgObj, "priority");
        pkg.multiarch = getStringOrEmpty(pkgObj, "multiarch");
        pkg.groups = getStringOrEmpty(pkgObj, "category");

        if (pkgObj.contains("size") && pkgObj["size"].is_number_integer())
        {
            pkg.size = pkgObj["size"].get<uint64_t>();
        }

        return pkg;
    }

    static std::string extractInventoryIdFromDocId(const std::string& docId)
    {
        if (docId.empty())
        {
            return {};
        }

        const auto pos = docId.rfind('_');
        if (pos == std::string::npos)
        {
            return docId;
        }
        if (pos + 1 >= docId.size())
        {
            return {};
        }

        return docId.substr(pos + 1);
    }

    static HotfixContextData parseHotfixFromSource(const nlohmann::json& source)
    {
        HotfixContextData hotfix;

        if (!source.contains("package") || !source["package"].is_object())
        {
            return hotfix;
        }

        const auto& pkgObj = source["package"];
        if (!pkgObj.contains("hotfix") || !pkgObj["hotfix"].is_object())
        {
            return hotfix;
        }

        const auto& hotfixObj = pkgObj["hotfix"];
        hotfix.hotfixName = getStringOrEmpty(hotfixObj, "name");
        return hotfix;
    }

    static Context buildContextFromAgent(const AgentContextData& agent, const OsContextData& osData)
    {
        Context context {};
        context.mode = Wazuh::SyncSchema::Mode_ModuleFull;
        context.option = Wazuh::SyncSchema::Option_VDSync;
        context.sessionId = 0;
        context.moduleName = "vulnerability-scanner";
        context.indices = {std::string(OS_INDEX), std::string(PACKAGE_INDEX), std::string(HOTFIX_INDEX)};
        context.agentId = agent.id;
        context.agentName = agent.name;
        context.agentVersion = agent.version;
        context.architecture = !osData.architecture.empty() ? osData.architecture : agent.hostArchitecture;
        context.hostname = !osData.hostName.empty() ? osData.hostName : agent.hostHostname;
        context.osname = !osData.name.empty() ? osData.name : agent.hostOsName;
        context.osplatform = !osData.platform.empty() ? osData.platform : agent.hostOsPlatform;
        context.ostype = !osData.sysName.empty() ? osData.sysName : agent.hostOsType;
        context.osversion = !osData.version.empty() ? osData.version : agent.hostOsVersion;
        context.groups = agent.groups;
        context.globalVersion = 0;
        context.transactionDispatched = false;
        context.ownsAgentLock = false;
        context.checksum = {};
        context.checksumIndex = {};
        return context;
    }

    void scanAgent(const AgentContextData& agent, const bool noIndex) const
    {
        OsContextData osData;
        bool hasOsData = false;

        try
        {
            fetchInventoryDocuments(std::string(OS_INDEX),
                                    agent.id,
                                    {"host"},
                                    [&](const nlohmann::json& hit)
                                    {
                                        if (!hit.contains("_source") || !hit["_source"].is_object())
                                        {
                                            return;
                                        }
                                        if (!hasOsData)
                                        {
                                            osData = parseOsFromSource(hit["_source"]);
                                            hasOsData = true;
                                        }
                                    });
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Failed to retrieve OS data for agent %s: %s.", agent.id.c_str(), e.what());
        }

        auto context = std::make_shared<TScanContext>(buildContextFromAgent(agent, osData));
        context->setNoIndex(noIndex);

        if (hasOsData)
        {
            context->setOSData(osData);
        }

        try
        {
            fetchInventoryDocuments(std::string(PACKAGE_INDEX),
                                    agent.id,
                                    {"package"},
                                    [&](const nlohmann::json& hit)
                                    {
                                        if (!hit.contains("_source") || !hit["_source"].is_object())
                                        {
                                            return;
                                        }

                                        const auto& source = hit["_source"];
                                        auto pkg = parsePackageFromSource(source);
                                        if (pkg.name.empty())
                                        {
                                            return;
                                        }

                                        std::string docId;
                                        if (hit.contains("_id") && hit["_id"].is_string())
                                        {
                                            docId = hit["_id"].get<std::string>();
                                        }

                                        if (docId.empty())
                                        {
                                            return;
                                        }

                                        const std::string packageId = extractInventoryIdFromDocId(docId);
                                        if (packageId.empty())
                                        {
                                            return;
                                        }

                                        const auto detectionIdBase = context->buildPackageDetectionIdBase(packageId);
                                        context->addPackageToContext(
                                            detectionIdBase, std::move(pkg), ElementOperation::Upsert);
                                    });
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Failed to retrieve packages for agent %s: %s.", agent.id.c_str(), e.what());
        }

        try
        {
            fetchInventoryDocuments(std::string(HOTFIX_INDEX),
                                    agent.id,
                                    {"package"},
                                    [&](const nlohmann::json& hit)
                                    {
                                        if (!hit.contains("_source") || !hit["_source"].is_object())
                                        {
                                            return;
                                        }

                                        auto hotfix = parseHotfixFromSource(hit["_source"]);
                                        if (!hotfix.hotfixName.empty())
                                        {
                                            context->addHotfixToContext(std::move(hotfix));
                                        }
                                    });
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Failed to retrieve hotfixes for agent %s: %s.", agent.id.c_str(), e.what());
        }

        if (m_scanRunner)
        {
            m_scanRunner(std::move(context));
        }
        else
        {
            logError(WM_VULNSCAN_LOGTAG, "Scan runner not configured for agent %s.", agent.id.c_str());
        }
    }

public:
    /**
     * @brief Construct a new `TScanAgentList` object.
     *
     * @param indexerConnector Indexer connector instance.
     * @param scanRunner Function that executes the scan for a prepared ScanContext.
     */
    explicit TScanAgentList(std::shared_ptr<TIndexerConnector> indexerConnector, ScanRunner scanRunner)
        : m_indexerConnector(std::move(indexerConnector))
        , m_scanRunner(std::move(scanRunner))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data A shared pointer to the input data.
     * @return A shared pointer to the result of the request processing.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        if (!m_indexerConnector)
        {
            logError(WM_VULNSCAN_LOGTAG, "Indexer connector not available for scan agent list.");
            return nullptr;
        }

        if (!data)
        {
            logWarn(WM_VULNSCAN_LOGTAG, "ScanAgentList received null ScanContext.");
            return nullptr;
        }

        for (const auto& agent : data->m_agents)
        {
            try
            {
                logDebug2(WM_VULNSCAN_LOGTAG, "Processing agent %s", agent.id.c_str());
                scanAgent(agent, data->isNoIndex());
            }
            catch (const std::exception& e)
            {
                logError(WM_VULNSCAN_LOGTAG, "Error executing scan for agent %s: %s.", agent.id.c_str(), e.what());
                data->m_agentsWithIncompletedScan.push_back(agent);
            }
        }

        if (!data->m_agentsWithIncompletedScan.empty())
        {
            throw AgentReScanListException(
                "Error executing rescan for multiple agents.", data->m_agentsWithIncompletedScan, data->isNoIndex());
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using ScanAgentList = TScanAgentList<>;

#endif // _SCAN_AGENT_LIST_HPP
