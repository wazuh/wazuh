/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * Jun 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _RESULT_INDEXER_HPP
#define _RESULT_INDEXER_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "schemaValidator.hpp"
#include <string_view>

/**
 * @brief ResultIndexer class.
 *
 * @tparam TIndexerConnector indexer connector type.
 * @tparam TScanContext scan context type.
 */
template<typename TIndexerConnector = IndexerConnectorSync, typename TScanContext = ScanContext>
class TResultIndexer final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TIndexerConnector> m_indexerConnector;

public:
    /**
     * @brief ResultIndexer constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    explicit TResultIndexer(std::shared_ptr<TIndexerConnector> indexerConnector)
        : m_indexerConnector(std::move(indexerConnector))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {

        const auto& detected = data->detectedCVEs();
        constexpr std::string_view indexName = "wazuh-states-vulnerabilities";
        auto& validatorFactory = SchemaValidator::SchemaValidatorFactory::getInstance();
        std::shared_ptr<SchemaValidator::ISchemaValidatorEngine> validator;

        if (validatorFactory.isInitialized())
        {
            validator = validatorFactory.getValidator(std::string {indexName});
            if (!validator)
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "resultIndexer - Schema validator not found for index '%s'. Validation skipped.",
                          indexName.data());
            }
        }
        else
        {
            logDebug2(WM_VULNSCAN_LOGTAG, "resultIndexer - Schema validator not initialized. Validation skipped.");
        }

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "resultIndexer - Indexing %zu detections (ecsEvents=%zu)",
                  detected.size(),
                  data->ecsEventCount());

        for (const auto& [detectionId, detection] : detected)
        {
            // Get ECS JSON previously built by EventDetailsBuilder
            const std::string* ecsJson = data->getECSEvent(detectionId);
            if (!ecsJson)
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "resultIndexer - No ECS event found for detection '%s', skipping",
                          detectionId.c_str());
                continue;
            }

            if (detection.operation == ElementOperation::Upsert)
            {
                if (validator)
                {
                    auto validationResult = validator->validate(*ecsJson);
                    if (!validationResult.isValid)
                    {
                        std::string errorMsg =
                            "Schema validation failed for vulnerability event (index: " + std::string(indexName) +
                            ", detection_id: " + detectionId + "). Errors:";

                        for (const auto& error : validationResult.errors)
                        {
                            errorMsg += "  - " + error;
                        }

                        logError(WM_VULNSCAN_LOGTAG, "%s", errorMsg.c_str());
                        logError(WM_VULNSCAN_LOGTAG, "Raw event that failed validation: %s", ecsJson->c_str());
                        continue;
                    }
                }

                logDebug2(WM_VULNSCAN_LOGTAG,
                          "resultIndexer - Indexing detection '%s' into index '%s'",
                          detectionId.c_str(),
                          indexName.data());

                m_indexerConnector->bulkIndex(detectionId, indexName, *ecsJson);
            }
            else if (detection.operation == ElementOperation::Delete)
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "resultIndexer - Deleting detection '%s' from index '%s'",
                          detectionId.c_str(),
                          indexName.data());

                m_indexerConnector->bulkDelete(detectionId, indexName);
            }
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using ResultIndexer = TResultIndexer<>;

#endif // _RESULT_INDEXER_HPP
