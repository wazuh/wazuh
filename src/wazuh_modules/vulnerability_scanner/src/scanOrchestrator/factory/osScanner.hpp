/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _OS_SCANNER_HPP
#define _OS_SCANNER_HPP

#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "scanContext.hpp"
#include "scannerHelper.hpp"
#include "versionMatcher/versionMatcher.hpp"

auto constexpr OS_SCANNER_CNA {"nvd"};

/**
 * @brief OsScanner class.
 * This class is in charge of scanning the OS for vulnerabilities.
 * It receives the scan context and the database feed manager and returns the scan context with the
 * vulnerabilities found.
 */
template<typename TDatabaseFeedManager = DatabaseFeedManager,
         typename TScanContext = ScanContext,
         typename TGlobalData = GlobalData>
class TOsScanner final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;

    /**
     * @brief Build a unique detection identifier for "agent + OS + CVE".
     *
     * This ID is used as the key in the detected CVE map and will be later
     * reused as the _id / item_id of the vulnerability document in the indexer.
     *
     * For OS:
     *   detectionId = <agentId>_<osName>_<osVersion>_<cveId>
     */
    static std::string buildDetectionId(const std::shared_ptr<TScanContext>& ctx, const std::string& cveId)
    {
        const auto agentId = ctx->agentId();
        const auto osName = ctx->osName();
        const auto osVersion = ctx->osVersion();

        std::string id;
        id.reserve(agentId.size() + 1 + osName.size() + 1 + osVersion.size() + 1 + cveId.size());

        id.append(agentId.data(), agentId.size());
        id.push_back('_');
        id.append(osName.data(), osName.size());
        id.push_back('_');
        id.append(osVersion.data(), osVersion.size());
        id.push_back('_');
        id.append(cveId);

        return id;
    }

    /**
     * @brief Helper to create CVEDetectionResult for OS vulnerabilities.
     *
     * Package information remains empty (this detection is for the OS),
     * and vulnerability fields are initialized with minimal but consistent data.
     */
    static CVEDetectionResult createOsDetectionResult(const std::string& cveId,
                                                      const std::string& cnaName,
                                                      std::string matchCondition,
                                                      MatchRuleCondition conditionType)
    {
        CVEDetectionResult result;

        // --- Detection metadata ---
        result.cveId = cveId;
        result.cnaSource = cnaName;
        result.matchCondition = std::move(matchCondition);
        result.conditionType = conditionType;
        result.componentType = AffectedComponentType::Os;
        result.feedOffset.clear();
        result.operation = ElementOperation::Upsert;

        // --- Package information ---
        // OS detections do not point to a specific package, so we leave
        // PackageContextData with default values.

        // --- Vulnerability information ---
        result.vulnerability.id = cveId;          // vulnerability.id
        result.vulnerability.classification = ""; // to be filled from feed if needed
        result.vulnerability.description = "";
        result.vulnerability.detected_at = "";    // filled later
        result.vulnerability.enumeration = "CVE"; // vulnerability.enumeration
        result.vulnerability.published_at = "";
        result.vulnerability.reference = "";
        result.vulnerability.severity = "";
        result.vulnerability.category = "";
        result.vulnerability.under_evaluation = false;
        result.vulnerability.report_id = "";

        // Score (se puede completar posteriormente desde feed/ADP)
        result.vulnerability.score.base = 0.0;
        result.vulnerability.score.environmental = 0.0;
        result.vulnerability.score.temporal = 0.0;
        result.vulnerability.score.version = "";

        // Scanner metadata
        result.vulnerability.scanner.vendor = "Wazuh"; // vulnerability.scanner.vendor
        result.vulnerability.scanner.source = cnaName; // vulnerability.scanner.source
        result.vulnerability.scanner.reference = "";
        result.vulnerability.scanner.condition = result.matchCondition; // matching rule/version

        return result;
    }

public:
    /**
     * @brief OsScanner constructor.
     *
     * @param databaseFeedManager Database feed manager.
     */
    explicit TOsScanner(std::shared_ptr<TDatabaseFeedManager> databaseFeedManager)
        : m_databaseFeedManager(std::move(databaseFeedManager))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    // LCOV_EXCL_START
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        const auto osCPE = ScannerHelper::parseCPE(data->osCPEName().data());

        auto vulnerabilityScan = [&](const std::string& cnaName,
                                     [[maybe_unused]] const PackageData& package,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData)
        {
            try
            {
                const auto cveId = callbackData.cveId()->str();
                const auto detectionId = buildDetectionId(data, cveId);

                // Do not override the vulnerability if it was already detected for this OS (cluster + agent + OS +
                // CVE).
                if (data->hasCVE(detectionId))
                {
                    auto* existing = data->getCVE(detectionId);
                    if (existing && existing->operation == ElementOperation::Delete)
                    {
                        data->removeCVE(detectionId);
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "OS CVE detection '%s' existed as DELETE, marking as still present (no reinsert).",
                                  detectionId.c_str());
                        return true; // Already known; avoid reinsert/re-alert.
                    }

                    logDebug1(WM_VULNSCAN_LOGTAG,
                              "OS CVE detection '%s' (CVE '%s') already present. Skipping duplicate.",
                              detectionId.c_str(),
                              cveId.c_str());
                    return true;
                }

                const std::string osVersion {data->osVersion()};
                std::variant<VersionObjectType, VersionMatcherStrategy> objectType = VersionObjectType::DPKG;
                auto osVersionObject = VersionMatcher::createVersionObject(osVersion, objectType);

                bool matched {false};
                MatchRuleCondition matchedCondition {MatchRuleCondition::Unknown};
                std::string matchedConditionValue;

                // No explicit version rules: rely on default status.
                if (!callbackData.versions() || callbackData.versions()->size() == 0)
                {
                    if (callbackData.defaultStatus() == NSVulnerabilityScanner::Status::Status_affected)
                    {
                        logDebug1(WM_VULNSCAN_LOGTAG,
                                  "Match found for OS: %s for vulnerability: %s due to default status.",
                                  osCPE.product.c_str(),
                                  cveId.c_str());

                        matched = true;
                        matchedCondition = MatchRuleCondition::DefaultStatus;
                        matchedConditionValue = "";
                    }

                    logDebug2(
                        WM_VULNSCAN_LOGTAG,
                        "No match due to default status for OS: %s, Version: %s while scanning for Vulnerability: %s",
                        osCPE.product.c_str(),
                        data->osVersion().data(),
                        cveId.c_str());

                    if (!matched)
                    {
                        return false;
                    }
                }

                for (const auto& version : *callbackData.versions())
                {
                    std::string versionString {version->version() ? version->version()->str() : ""};
                    std::string versionStringLessThan {version->lessThan() ? version->lessThan()->str() : ""};
                    std::string versionStringLessThanOrEqual {
                        version->lessThanOrEqual() ? version->lessThanOrEqual()->str() : ""};

                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Scanning OS - '%s' (Installed Version: %s, Security Vulnerability: %s). Identified "
                              "vulnerability: "
                              "Version: %s. Required Version Threshold: %s. Required Version Threshold (or Equal): %s.",
                              osCPE.product.c_str(),
                              osVersion.c_str(),
                              cveId.c_str(),
                              versionString.c_str(),
                              versionStringLessThan.c_str(),
                              versionStringLessThanOrEqual.c_str());

                    // No version range specified, check if the installed version is equal to the required version.
                    if (versionStringLessThan.empty() && versionStringLessThanOrEqual.empty())
                    {
                        if (VersionMatcher::compare(osVersionObject, osVersion, versionString, objectType) ==
                            VersionComparisonResult::A_EQUAL_B)
                        {
                            // Version match found, the OS status is defined by the vulnerability status.
                            if (version->status() == NSVulnerabilityScanner::Status::Status_affected)
                            {
                                logDebug1(WM_VULNSCAN_LOGTAG,
                                          "Match found, the OS '%s', is vulnerable to '%s'. Current version: '%s' is "
                                          "equal to '%s'. - Agent '%s' (ID: '%s', Version: '%s').",
                                          osCPE.product.c_str(),
                                          cveId.c_str(),
                                          osVersion.c_str(),
                                          versionString.c_str(),
                                          data->agentName().data(),
                                          data->agentId().data(),
                                          data->agentVersion().data());

                                matched = true;
                                matchedCondition = MatchRuleCondition::Equal;
                                matchedConditionValue = versionString;

                                break;
                            }

                            return false;
                        }
                    }
                    else
                    {
                        // Version range specified
                        // Check if the installed version satisfies the lower bound of the version range.
                        bool lowerBoundMatch = false;
                        if (versionString.compare("0") == 0)
                        {
                            lowerBoundMatch = true;
                        }
                        else
                        {
                            const auto matchResult =
                                VersionMatcher::compare(osVersionObject, osVersion, versionString, objectType);
                            lowerBoundMatch = matchResult == VersionComparisonResult::A_GREATER_THAN_B ||
                                              matchResult == VersionComparisonResult::A_EQUAL_B;
                        }

                        if (lowerBoundMatch)
                        {
                            // Check if the installed version satisfies the upper bound of the version range.
                            bool upperBoundMatch = false;

                            if (!versionStringLessThan.empty() && versionStringLessThan.compare("*") != 0)
                            {
                                const auto matchResult = VersionMatcher::compare(
                                    osVersionObject, osVersion, versionStringLessThan, objectType);
                                upperBoundMatch = matchResult == VersionComparisonResult::A_LESS_THAN_B;
                            }
                            else if (!versionStringLessThanOrEqual.empty())
                            {
                                const auto matchResult = VersionMatcher::compare(
                                    osVersionObject, osVersion, versionStringLessThanOrEqual, objectType);
                                upperBoundMatch = matchResult == VersionComparisonResult::A_LESS_THAN_B ||
                                                  matchResult == VersionComparisonResult::A_EQUAL_B;
                            }
                            else
                            {
                                upperBoundMatch = false;
                            }

                            if (upperBoundMatch)
                            {
                                // Version match found, the OS status is defined by the vulnerability status.
                                if (version->status() == NSVulnerabilityScanner::Status::Status_affected)
                                {
                                    logDebug1(WM_VULNSCAN_LOGTAG,
                                              "Match found, the OS '%s', is vulnerable to '%s'. Current version: "
                                              "'%s' (less than '%s' or equal to '%s'). - Agent '%s' (ID: '%s', "
                                              "Version: '%s').",
                                              osCPE.product.c_str(),
                                              cveId.c_str(),
                                              osVersion.c_str(),
                                              versionStringLessThan.c_str(),
                                              versionStringLessThanOrEqual.c_str(),
                                              data->agentName().data(),
                                              data->agentId().data(),
                                              data->agentVersion().data());

                                    if (!versionStringLessThanOrEqual.empty())
                                    {
                                        auto det = createOsDetectionResult(cveId,
                                                                           cnaName,
                                                                           versionStringLessThanOrEqual,
                                                                           MatchRuleCondition::LessThanOrEqual);
                                        det.detectionIdBase = detectionId;
                                        data->addDetectedCVE(detectionId, std::move(det));
                                    }
                                    else
                                    {
                                        auto det = createOsDetectionResult(
                                            cveId, cnaName, versionStringLessThan, MatchRuleCondition::LessThan);
                                        det.detectionIdBase = detectionId;
                                        data->addDetectedCVE(detectionId, std::move(det));
                                    }

                                    return true;
                                }
                                else
                                {
                                    logDebug2(WM_VULNSCAN_LOGTAG,
                                              "No match due to default status for OS: %s, Version: %s while scanning "
                                              "for Vulnerability: %s, "
                                              "Installed Version: %s, Required Version Threshold: %s, Required Version "
                                              "Threshold (or Equal): %s",
                                              osCPE.product.c_str(),
                                              osVersion.c_str(),
                                              cveId.c_str(),
                                              versionString.c_str(),
                                              versionStringLessThan.c_str(),
                                              versionStringLessThanOrEqual.c_str());

                                    return false;
                                }
                            }
                        }
                    }
                }

                // If matched, add/update detection once.
                if (!matched)
                {
                    logDebug2(
                        WM_VULNSCAN_LOGTAG,
                        "No match due to default status for OS: %s, Version: %s while scanning for Vulnerability: %s",
                        osCPE.product.c_str(),
                        data->osVersion().data(),
                        cveId.c_str());

                    return false;
                }

                if (data->hasCVE(detectionId))
                {
                    data->removeCVE(detectionId);
                }
                else
                {
                    auto det = createOsDetectionResult(cveId, cnaName, matchedConditionValue, matchedCondition);
                    det.detectionIdBase = detectionId;
                    data->addDetectedCVE(detectionId, std::move(det));
                }

                return true;
            }
            catch (const std::exception& e)
            {
                // Log the warning and continue with the next vulnerability.
                logDebug1(WM_VULNSCAN_LOGTAG,
                          "Failed to scan OS: '%s', CVE Numbering Authorities (CNA): '%s', Error: '%s'",
                          osCPE.product.c_str(),
                          cnaName.c_str(),
                          e.what());

                return false;
            }
        };

        try
        {
            if (data->osPlatform() == "windows" || data->osPlatform() == "darwin")
            {
                if (osCPE.product.empty())
                {
                    logDebug1(WM_VULNSCAN_LOGTAG,
                              "No CPE product found for OS '%s' on Agent '%s'.",
                              data->osName().data(),
                              data->agentId().data());
                }
                else
                {
                    PackageData package = {.name = osCPE.product, .vendor = {}, .format = {}, .version = {}};

                    data->m_vulnerabilitySource = std::make_pair(OS_SCANNER_CNA, OS_SCANNER_CNA);

                    if (TGlobalData::instance().vendorMaps().contains(ADP_DEFAULT_ARRAY_KEY))
                    {
                        auto& defaultCNAsArray = TGlobalData::instance().vendorMaps().at(ADP_DEFAULT_ARRAY_KEY);

                        for (const nlohmann::json& cna : defaultCNAsArray)
                        {
                            logDebug2(WM_VULNSCAN_LOGTAG,
                                      "Using CNA '%s' from CNA array for OS.",
                                      cna.get<std::string>().c_str());
                            m_databaseFeedManager->getVulnerabilitiesCandidates(cna, package, vulnerabilityScan);
                        }
                    }
                    else
                    {
                        logDebug2(
                            WM_VULNSCAN_LOGTAG, "No CNA array found for OS, using default CNA '%s'.", OS_SCANNER_CNA);

                        m_databaseFeedManager->getVulnerabilitiesCandidates(OS_SCANNER_CNA, package, vulnerabilityScan);
                    }

                    // Windows-specific remediation filtering using hotfix information from ScanContext.
                    if (data->osPlatform() == "windows")
                    {
                        std::vector<std::string> detectionsToRemove; // detectionId only

                        const auto& installedHotfixes = data->hotfixes();

                        for (const auto& [detectionId, detection] : data->detectedCVEs())
                        {
                            if (detection.componentType != AffectedComponentType::Os)
                            {
                                continue;
                            }

                            const auto& cve = detection.cveId;

                            FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo> remediations {};
                            m_databaseFeedManager->getVulnerabilityRemediation(cve, remediations);

                            if (remediations.data == nullptr || remediations.data->updates() == nullptr ||
                                remediations.data->updates()->size() == 0)
                            {
                                logDebug2(
                                    WM_VULNSCAN_LOGTAG,
                                    "No remediation available for OS '%s' on Agent '%s' for CVE: '%s', discarding.",
                                    osCPE.product.c_str(),
                                    data->agentId().data(),
                                    cve.c_str());

                                detectionsToRemove.emplace_back(detectionId);
                                continue;
                            }

                            bool solvedByHotfix = false;

                            for (const auto& remediation : *(remediations.data->updates()))
                            {
                                if (!remediation)
                                {
                                    continue;
                                }

                                const std::string remediationName = remediation->str();

                                // Delete detection if the corresponding hotfix is already installed on the agent.
                                for (const auto& hotfix : installedHotfixes)
                                {
                                    if (hotfix.hotfixName == remediationName)
                                    {
                                        logDebug2(WM_VULNSCAN_LOGTAG,
                                                  "Remediation for OS '%s' on Agent '%s' has been found. CVE: '%s', "
                                                  "Remediation: '%s'.",
                                                  osCPE.product.c_str(),
                                                  data->agentId().data(),
                                                  cve.c_str(),
                                                  remediationName.c_str());

                                        detectionsToRemove.emplace_back(detectionId);
                                        solvedByHotfix = true;
                                        break;
                                    }
                                }

                                if (solvedByHotfix)
                                {
                                    break;
                                }
                            }
                        }

                        // Remove discarded / remediated OS detections from the detection container.
                        for (const auto& detectionId : detectionsToRemove)
                        {
                            data->removeCVE(detectionId);
                        }
                    }
                }
            }
            else
            {
                logDebug1(WM_VULNSCAN_LOGTAG,
                          "OS scan for platform '%s' on Agent '%s' is not supported.",
                          data->osPlatform().data(),
                          data->agentId().data());
                // Continue the chain to avoid cutting the orchestration (e.g., Linux without OS scan).
            }
        }
        catch (const std::exception& e)
        {
            logWarn(WM_VULNSCAN_LOGTAG,
                    "Failed to scan OS: '%s', CVE Numbering Authorities (CNA): 'nvd', Error: '%s'.",
                    osCPE.product.empty() ? data->osName().data() : osCPE.product.c_str(),
                    e.what());
        }

        logDebug1(WM_VULNSCAN_LOGTAG,
                  "Vulnerability scan for OS '%s' on Agent '%s' has completed.",
                  osCPE.product.empty() ? data->osName().data() : osCPE.product.c_str(),
                  data->agentId().data());

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
    // LCOV_EXCL_STOP
};

using OsScanner = TOsScanner<>;

#endif // _OS_SCANNER_HPP
