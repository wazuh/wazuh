/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 11, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_DETAILS_BUILDER_HPP
#define _EVENT_DETAILS_BUILDER_HPP

#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "descriptionsHelper.hpp"
#include "fieldAlertHelper.hpp"
#include "loggerHelper.h"
#include "numericHelper.h"
#include "scanContext.hpp"
#include "timeHelper.h"
#include "vdInventorySync.hpp"
#include <sstream>

constexpr auto WAZUH_SCHEMA_VERSION = "1.0.0";

/**
 * @brief Structured ECS event data (replaces nlohmann::json).
 * This struct represents a complete ECS-compliant vulnerability event.
 */
struct ECSVulnerabilityEvent
{
    // ECS Agent fields
    struct Agent
    {
        std::string id;
        std::string name;
        std::string type {"Wazuh"};
        std::string version;
        std::string ephemeral_id; // Optional (for cluster node)
    } agent;

    // ECS Package fields
    struct Package
    {
        std::string name;
        std::string version;
        std::string type;
        std::string architecture;
        std::string description;
        std::string path;
        std::string installed; // ISO8601 timestamp
        uint64_t size {0};
    } package;

    // ECS Host OS fields
    struct HostOS
    {
        std::string full;
        std::string kernel;
        std::string name;
        std::string platform;
        std::string type;
        std::string version;
    } host_os;

    // ECS Vulnerability fields
    struct Vulnerability
    {
        std::string id;
        std::string classification;
        std::string description;
        std::string detected_at;
        std::string enumeration {"CVE"};
        std::string published_at;
        std::string reference;
        std::string severity;
        std::string category;
        bool under_evaluation {false};

        struct Score
        {
            double base {0.0};
            std::string version;
        } score;

        struct Scanner
        {
            std::string vendor {"Wazuh"};
            std::string source;
            std::string reference;
            std::string condition;
        } scanner;
    } vulnerability;

    // Wazuh custom fields
    struct Wazuh
    {
        std::string cluster_name;
        std::string schema_version {WAZUH_SCHEMA_VERSION};
    } wazuh;

    // Metadata
    std::string timestamp; // ISO8601
    std::string event_kind {"alert"};
    std::string event_category {"vulnerability"};
    std::string event_type {"info"};

    /**
     * @brief Serialize to JSON string for indexing.
     * Uses nlohmann::json only for final serialization (not internal storage).
     */
    std::string toJSON() const
    {
        nlohmann::json json;

        // Agent
        json["agent"]["id"] = agent.id;
        json["agent"]["name"] = agent.name;
        json["agent"]["type"] = agent.type;
        json["agent"]["version"] = agent.version;
        if (!agent.ephemeral_id.empty())
        {
            json["agent"]["ephemeral_id"] = agent.ephemeral_id;
        }

        // Package
        json["package"]["name"] = package.name;
        json["package"]["version"] = package.version;
        json["package"]["type"] = package.type;
        if (!package.architecture.empty())
        {
            json["package"]["architecture"] = package.architecture;
        }
        if (!package.description.empty())
        {
            json["package"]["description"] = package.description;
        }
        if (!package.path.empty())
        {
            json["package"]["path"] = package.path;
        }
        if (!package.installed.empty())
        {
            json["package"]["installed"] = package.installed;
        }
        if (package.size > 0)
        {
            json["package"]["size"] = package.size;
        }

        // Host OS
        json["host"]["os"]["full"] = host_os.full;
        if (!host_os.kernel.empty())
        {
            json["host"]["os"]["kernel"] = host_os.kernel;
        }
        json["host"]["os"]["name"] = host_os.name;
        json["host"]["os"]["platform"] = host_os.platform;
        json["host"]["os"]["type"] = host_os.type;
        json["host"]["os"]["version"] = host_os.version;

        // Vulnerability
        json["vulnerability"]["id"] = vulnerability.id;
        json["vulnerability"]["classification"] = vulnerability.classification;
        json["vulnerability"]["description"] = vulnerability.description;
        json["vulnerability"]["detected_at"] = vulnerability.detected_at;
        json["vulnerability"]["enumeration"] = vulnerability.enumeration;
        json["vulnerability"]["published_at"] = vulnerability.published_at;
        json["vulnerability"]["reference"] = vulnerability.reference;
        json["vulnerability"]["severity"] = vulnerability.severity;
        json["vulnerability"]["category"] = vulnerability.category;
        json["vulnerability"]["under_evaluation"] = vulnerability.under_evaluation;

        json["vulnerability"]["score"]["base"] = vulnerability.score.base;
        json["vulnerability"]["score"]["version"] = vulnerability.score.version;

        json["vulnerability"]["scanner"]["vendor"] = vulnerability.scanner.vendor;
        json["vulnerability"]["scanner"]["source"] = vulnerability.scanner.source;
        json["vulnerability"]["scanner"]["reference"] = vulnerability.scanner.reference;
        json["vulnerability"]["scanner"]["condition"] = vulnerability.scanner.condition;

        // Wazuh
        json["wazuh"]["cluster"]["name"] = wazuh.cluster_name;
        json["wazuh"]["schema"]["version"] = wazuh.schema_version;

        // Metadata
        json["@timestamp"] = timestamp;
        json["event"]["kind"] = event_kind;
        json["event"]["category"] = event_category;
        json["event"]["type"] = event_type;

        return json.dump();
    }
};

/**
 * @brief TEventDetailsBuilder class.
 * Builds ECS-compliant vulnerability events from scan context.
 * Now uses typed CVEDetectionResult instead of nlohmann::json for internal storage.
 */
template<typename TDatabaseFeedManager = DatabaseFeedManager,
         typename TScanContext = ScanContext,
         typename TGlobalData = GlobalData>
class TEventDetailsBuilder final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;

    /**
     * @brief Build OS full name (OS name + version).
     */
    std::string buildOSFullName(const std::shared_ptr<TScanContext>& context) const
    {
        std::string fullName;
        fullName.reserve(64);
        fullName.append(context->osName());
        fullName.append(" ");
        fullName.append(context->osPlatform() == "darwin" ? context->osCodeName() : context->osVersion());
        return fullName;
    }

    /**
     * @brief Build OS version string (major.minor.patch.build).
     */
    std::string buildOSVersion(const std::shared_ptr<TScanContext>& context) const
    {
        std::string version;
        version.reserve(32);
        version.append(context->osMajorVersion());

        if (!context->osMinorVersion().empty())
        {
            version.append(".");
            version.append(context->osMinorVersion());
        }
        if (!context->osPatch().empty())
        {
            version.append(".");
            version.append(context->osPatch());
        }
        if (!context->osBuild().empty())
        {
            version.append(".");
            version.append(context->osBuild());
        }

        return version;
    }

    /**
     * @brief Build OS type (normalized to lowercase).
     */
    std::string buildOSType(const std::shared_ptr<TScanContext>& context) const
    {
        return Utils::toLowerCase(context->osPlatform() == "darwin" ? "macos" : std::string(context->osPlatform()));
    }

    /**
     * @brief Build agent metadata.
     */
    ECSVulnerabilityEvent::Agent buildAgentData(const std::shared_ptr<TScanContext>& context) const
    {
        ECSVulnerabilityEvent::Agent agent;
        agent.id = std::string(context->agentId());
        agent.name = std::string(context->agentName());
        agent.version = std::string(context->agentVersion());

        // Cluster node name for manager (agent 000)
        if (context->agentId() == "000")
        {
            agent.ephemeral_id = std::string(context->clusterNodeName());
        }

        return agent;
    }

    /**
     * @brief Build package metadata based on component type.
     * Now uses data from CVEDetectionResult instead of context.
     */
    ECSVulnerabilityEvent::Package buildPackageData(const std::shared_ptr<TScanContext>& context,
                                                    const CVEDetectionResult& detection,
                                                    const std::string& osFullName,
                                                    const std::string& osVersion,
                                                    const std::string& osType) const
    {
        ECSVulnerabilityEvent::Package package;

        switch (detection.componentType)
        {
            case AffectedComponentType::Package:
                // Use data from CVEDetectionResult (populated during scanning)
                package.name = detection.packageName;
                package.version = detection.packageVersion;
                package.type = detection.packageFormat;
                package.architecture = detection.packageArchitecture;
                package.description = detection.packageDescription;
                package.path = detection.packageLocation;
                package.size = detection.packageSize;

                // Convert install time to ISO8601
                if (!detection.packageInstallTime.empty())
                {
                    package.installed = Utils::rawTimestampToISO8601(detection.packageInstallTime);
                }
                break;

            case AffectedComponentType::Os:
                // For OS vulnerabilities, use OS data
                package.name = osFullName;
                package.version = osVersion;
                package.type = osType;
                package.architecture = std::string(context->osArchitecture());
                break;

            default: break;
        }

        return package;
    }

    /**
     * @brief Build host OS metadata.
     */
    ECSVulnerabilityEvent::HostOS buildHostOSData(const std::shared_ptr<TScanContext>& context,
                                                  const std::string& osFullName,
                                                  const std::string& osVersion,
                                                  const std::string& osType) const
    {
        ECSVulnerabilityEvent::HostOS hostOS;
        hostOS.full = osFullName;
        hostOS.kernel = std::string(context->osKernelRelease());
        hostOS.name = std::string(context->osName());
        hostOS.platform = Utils::toLowerCase(std::string(context->osPlatform()));
        hostOS.type = osType;
        hostOS.version = osVersion;
        return hostOS;
    }

    /**
     * @brief Build scanner condition string.
     */
    std::string buildScannerCondition(const CVEDetectionResult& detection) const
    {
        switch (detection.conditionType)
        {
            case MatchRuleCondition::Equal: return "Package equal to " + detection.matchCondition;

            case MatchRuleCondition::LessThan: return "Package less than " + detection.matchCondition;

            case MatchRuleCondition::LessThanOrEqual:
                return "Package less than or equal to " + detection.matchCondition;

            case MatchRuleCondition::DefaultStatus: return "Package default status";

            default:
                logDebug2(
                    WM_VULNSCAN_LOGTAG, "Unknown match condition type: %d", static_cast<int>(detection.conditionType));
                return "Unknown";
        }
    }

    /**
     * @brief Build vulnerability metadata from CVE description.
     */
    ECSVulnerabilityEvent::Vulnerability buildVulnerabilityData(const CVEDetectionResult& detection,
                                                                const CveDescription& description,
                                                                const std::shared_ptr<TScanContext>& /*context*/) const
    {
        ECSVulnerabilityEvent::Vulnerability vuln;

        vuln.id = detection.cveId;
        vuln.classification = FieldAlertHelper::fillEmptyOrNegative(description.classification);
        vuln.description = description.description;
        vuln.detected_at = Utils::getCurrentISO8601();
        vuln.published_at = description.datePublished;
        vuln.reference = description.reference;
        vuln.severity =
            FieldAlertHelper::fillEmptyOrNegative(Utils::toSentenceCase(std::string {description.severity}));

        // Category based on component type
        vuln.category = (detection.componentType == AffectedComponentType::Os) ? "OS" : "Packages";

        // CVSS Score
        vuln.score.base = FieldAlertHelper::fillEmptyOrNegative(Utils::floatToDoubleRound(description.scoreBase, 2));
        vuln.score.version = FieldAlertHelper::fillEmptyOrNegative(description.scoreVersion);

        // Under evaluation flag
        vuln.under_evaluation = (Utils::floatToDoubleRound(description.scoreBase, 2) == 0 ||
                                 description.scoreVersion.empty() || description.severity.empty());

        // Scanner metadata
        try
        {
            vuln.scanner.source = TGlobalData::instance()
                                      .vendorMaps()
                                      .at("adp_descriptions")
                                      .at(detection.cnaSource)
                                      .at("adp")
                                      .template get<std::string>();
        }
        catch (const std::exception& e)
        {
            logWarn(WM_VULNSCAN_LOGTAG,
                    "Failed to get scanner source for CNA '%s': %s (using CNA name)",
                    detection.cnaSource.c_str(),
                    e.what());
            vuln.scanner.source = detection.cnaSource;
        }

        vuln.scanner.reference = std::string(WAZUH_CTI_CVES_URL) + detection.cveId;
        vuln.scanner.condition = buildScannerCondition(detection);

        return vuln;
    }

    /**
     * @brief Build complete ECS event.
     */
    ECSVulnerabilityEvent buildECSEvent(const std::shared_ptr<TScanContext>& context,
                                        const CVEDetectionResult& detection,
                                        const CveDescription& description) const
    {
        ECSVulnerabilityEvent event;

        // Pre-compute shared data
        const auto osFullName = buildOSFullName(context);
        const auto osVersion = buildOSVersion(context);
        const auto osType = buildOSType(context);

        // Build sections
        event.agent = buildAgentData(context);
        event.package = buildPackageData(context, detection, osFullName, osVersion, osType);
        event.host_os = buildHostOSData(context, osFullName, osVersion, osType);
        event.vulnerability = buildVulnerabilityData(detection, description, context);

        // Wazuh metadata
        event.wazuh.cluster_name = std::string(context->clusterName());

        // Event metadata
        event.timestamp = Utils::getCurrentISO8601();

        return event;
    }

public:
    explicit TEventDetailsBuilder(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager)
        : m_databaseFeedManager(databaseFeedManager)
    {
    }

    ~TEventDetailsBuilder() = default;

    /**
     * @brief Build ECS events for all detected CVEs.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> context) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Building ECS events for %zu CVEs (component type: %d)",
                  context->cveCount(),
                  static_cast<int>(context->affectedComponentType()));

        // Get CVE description sources based on vulnerability source
        const auto descriptionSources =
            DescriptionsHelper::cvssAndDescriptionSources<TGlobalData>(context->m_vulnerabilitySource);

        // Process each detected CVE (non-const to allow updating feedOffset)
        for (auto& [cveId, detection] : context->detectedCVEs())
        {
            // Skip DELETED operations (no event needed)
            if (detection.operation == ElementOperation::Deleted)
            {
                continue;
            }

            try
            {
                // Fetch CVE description from feed
                DescriptionsHelper::vulnerabilityDescription<TDatabaseFeedManager, TGlobalData>(
                    cveId,
                    descriptionSources,
                    m_databaseFeedManager,
                    [&](const CveDescription& description)
                    {
                        // Update feed offset for versioned detection
                        detection.feedOffset = description.offset;

                        // Build ECS event
                        auto ecsEvent = buildECSEvent(context, detection, description);

                        // Serialize to JSON for storage/indexing
                        context->addECSEvent(cveId, ecsEvent.toJSON());

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "Built ECS event for CVE %s (agent: %s, package: %s)",
                                  cveId.c_str(),
                                  context->agentId().data(),
                                  detection.packageName.c_str());
                    });
            }
            catch (const std::exception& e)
            {
                logError(WM_VULNSCAN_LOGTAG, "Failed to build ECS event for CVE %s: %s", cveId.c_str(), e.what());
            }
        }

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Completed building %zu ECS events for agent %s",
                  context->cveCount(),
                  context->agentId().data());

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(context));
    }
};

using EventDetailsBuilder = TEventDetailsBuilder<>;

#endif // _EVENT_DETAILS_BUILDER_HPP
