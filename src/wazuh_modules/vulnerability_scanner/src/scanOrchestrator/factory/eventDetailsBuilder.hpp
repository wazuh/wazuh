/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 11, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_DETAILS_BUILDER_HPP
#define _EVENT_DETAILS_BUILDER_HPP

#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "descriptionsHelper.hpp"
#include "fieldAlertHelper.hpp"
#include "loggerHelper.h"
#include "numericHelper.h"
#include "scanContext.hpp"
#include "timeHelper.h"
#include "vdInventorySync.hpp"
#include <sstream>

constexpr auto WAZUH_SCHEMA_VERSION = "1.0.0";

/**
 * @brief Structured ECS event data (replaces nlohmann::json).
 * This struct represents a complete ECS-compliant vulnerability event
 * aligned with the wazuh-states-vulnerabilities* index template.
 */
struct ECSVulnerabilityEvent
{
    // ECS Agent fields
    struct Agent
    {
        std::string id;             // agent.id
        std::string name;           // agent.name
        std::string type {"Wazuh"}; // agent.type
        std::string version;        // agent.version
        std::string ephemeral_id;   // agent.ephemeral_id (optional)
    } agent;

    // ECS Package fields (aligned with wazuh-states-vulnerabilities* package mapping)
    struct Package
    {
        std::string name;          // package.name
        std::string version;       // package.version
        std::string type;          // package.type
        std::string architecture;  // package.architecture
        std::string description;   // package.description
        std::string path;          // package.path
        std::string installed;     // package.installed (ISO8601 timestamp)
        uint64_t size {0};         // package.size

        std::string build_version; // package.build_version
        std::string checksum;      // package.checksum
        std::string install_scope; // package.install_scope
        std::string license;       // package.license
        std::string reference;     // package.reference
    } package;

    // ECS Host OS fields (top-level host.os.*)
    struct HostOS
    {
        std::string full;      // host.os.full
        std::string kernel;    // host.os.kernel
        std::string name;      // host.os.name
        std::string platform;  // host.os.platform
        std::string type;      // host.os.type
        std::string version;   // host.os.version
    } host_os;

    // ECS Vulnerability fields
    struct Vulnerability
    {
        std::string id;             // vulnerability.id
        std::string classification; // vulnerability.classification
        std::string description;    // vulnerability.description
        std::string detected_at;    // vulnerability.detected_at
        std::string enumeration {"CVE"}; // vulnerability.enumeration
        std::string published_at;   // vulnerability.published_at
        std::string reference;      // vulnerability.reference
        std::string severity;       // vulnerability.severity
        std::string category;       // vulnerability.category
        bool under_evaluation {false}; // vulnerability.under_evaluation

        std::string report_id;      // vulnerability.report_id

        struct Score
        {
            double base {0.0};         // vulnerability.score.base
            double environmental {0.0}; // vulnerability.score.environmental
            double temporal {0.0};      // vulnerability.score.temporal
            std::string version;        // vulnerability.score.version
        } score;

        struct Scanner
        {
            std::string vendor {"Wazuh"}; // vulnerability.scanner.vendor
            std::string source;           // vulnerability.scanner.source
            std::string reference;        // vulnerability.scanner.reference
            std::string condition;        // vulnerability.scanner.condition
        } scanner;
    } vulnerability;

    // Wazuh custom fields
    struct Wazuh
    {
        std::string cluster_name;                  // wazuh.cluster.name
        std::string cluster_node;                  // wazuh.cluster.node
        std::string schema_version {WAZUH_SCHEMA_VERSION}; // wazuh.schema.version
    } wazuh;

    /**
     * @brief Serialize to JSON string for indexing.
     * Uses nlohmann::json only for final serialization (not internal storage).
     *
     * Note: Fields not present in the current mapping are intentionally omitted
     * to keep compatibility with dynamic: "strict".
     */
    std::string toJSON() const
    {
        nlohmann::json json;

        // Agent
        json["agent"]["id"] = agent.id;
        json["agent"]["name"] = agent.name;
        json["agent"]["type"] = agent.type;
        json["agent"]["version"] = agent.version;

        if (!agent.ephemeral_id.empty())
        {
            json["agent"]["ephemeral_id"] = agent.ephemeral_id;
        }

        // Package
        json["package"]["name"] = package.name;
        json["package"]["version"] = package.version;
        json["package"]["type"] = package.type;

        if (!package.architecture.empty())
        {
            json["package"]["architecture"] = package.architecture;
        }
        if (!package.description.empty())
        {
            json["package"]["description"] = package.description;
        }
        if (!package.path.empty())
        {
            json["package"]["path"] = package.path;
        }
        if (!package.installed.empty())
        {
            json["package"]["installed"] = package.installed;
        }
        if (package.size > 0)
        {
            json["package"]["size"] = package.size;
        }
        if (!package.build_version.empty())
        {
            json["package"]["build_version"] = package.build_version;
        }
        if (!package.checksum.empty())
        {
            json["package"]["checksum"] = package.checksum;
        }
        if (!package.install_scope.empty())
        {
            json["package"]["install_scope"] = package.install_scope;
        }
        if (!package.license.empty())
        {
            json["package"]["license"] = package.license;
        }
        if (!package.reference.empty())
        {
            json["package"]["reference"] = package.reference;
        }

        // Host OS (top-level host.os.*)
        json["host"]["os"]["full"] = host_os.full;

        if (!host_os.kernel.empty())
        {
            json["host"]["os"]["kernel"] = host_os.kernel;
        }
        if (!host_os.name.empty())
        {
            json["host"]["os"]["name"] = host_os.name;
        }
        if (!host_os.platform.empty())
        {
            json["host"]["os"]["platform"] = host_os.platform;
        }
        if (!host_os.type.empty())
        {
            json["host"]["os"]["type"] = host_os.type;
        }
        if (!host_os.version.empty())
        {
            json["host"]["os"]["version"] = host_os.version;
        }

        // Vulnerability
        json["vulnerability"]["id"] = vulnerability.id;
        json["vulnerability"]["classification"] = vulnerability.classification;
        json["vulnerability"]["description"] = vulnerability.description;
        json["vulnerability"]["detected_at"] = vulnerability.detected_at;
        json["vulnerability"]["enumeration"] = vulnerability.enumeration;
        json["vulnerability"]["published_at"] = vulnerability.published_at;
        json["vulnerability"]["reference"] = vulnerability.reference;
        json["vulnerability"]["severity"] = vulnerability.severity;
        json["vulnerability"]["category"] = vulnerability.category;
        json["vulnerability"]["under_evaluation"] = vulnerability.under_evaluation;

        if (!vulnerability.report_id.empty())
        {
            json["vulnerability"]["report_id"] = vulnerability.report_id;
        }

        json["vulnerability"]["score"]["base"] = vulnerability.score.base;
        json["vulnerability"]["score"]["version"] = vulnerability.score.version;

        // Only include environmental/temporal if they have meaningful values
        if (vulnerability.score.environmental > 0.0)
        {
            json["vulnerability"]["score"]["environmental"] = vulnerability.score.environmental;
        }
        if (vulnerability.score.temporal > 0.0)
        {
            json["vulnerability"]["score"]["temporal"] = vulnerability.score.temporal;
        }

        json["vulnerability"]["scanner"]["vendor"] = vulnerability.scanner.vendor;
        json["vulnerability"]["scanner"]["source"] = vulnerability.scanner.source;
        json["vulnerability"]["scanner"]["reference"] = vulnerability.scanner.reference;
        json["vulnerability"]["scanner"]["condition"] = vulnerability.scanner.condition;

        // Wazuh
        json["wazuh"]["cluster"]["name"] = wazuh.cluster_name;
        json["wazuh"]["cluster"]["node"] = wazuh.cluster_node;
        json["wazuh"]["schema"]["version"] = wazuh.schema_version;

        // Note: We intentionally do NOT set @timestamp or event.*
        // because they are not present in the wazuh-states-vulnerabilities*
        // template (dynamic: "strict").

        return json.dump();
    }
};

/**
 * @brief TEventDetailsBuilder class.
 * Builds ECS-compliant vulnerability events from scan context.
 * Now uses typed CVEDetectionResult instead of nlohmann::json for internal storage.
 */
template<typename TDatabaseFeedManager = DatabaseFeedManager,
         typename TScanContext = ScanContext,
         typename TGlobalData = GlobalData>
class TEventDetailsBuilder final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;

    /**
     * @brief Build OS full name (OS name + version or code name).
     */
    std::string buildOSFullName(const std::shared_ptr<TScanContext>& context) const
    {
        std::string fullName;
        fullName.reserve(64);
        fullName.append(context->osName());
        fullName.append(" ");
        fullName.append(context->osPlatform() == "darwin" ? context->osCodeName() : context->osVersion());
        return fullName;
    }

    /**
     * @brief Build OS version string (major.minor.patch.build).
     */
    std::string buildOSVersion(const std::shared_ptr<TScanContext>& context) const
    {
        std::string version;
        version.reserve(32);
        version.append(context->osMajorVersion());

        if (!context->osMinorVersion().empty())
        {
            version.append(".");
            version.append(context->osMinorVersion());
        }
        if (!context->osPatch().empty())
        {
            version.append(".");
            version.append(context->osPatch());
        }
        if (!context->osBuild().empty())
        {
            version.append(".");
            version.append(context->osBuild());
        }

        return version;
    }

    /**
     * @brief Build OS type (normalized to lowercase).
     */
    std::string buildOSType(const std::shared_ptr<TScanContext>& context) const
    {
        return Utils::toLowerCase(context->osPlatform() == "darwin" ? "macos" : std::string(context->osPlatform()));
    }

    /**
     * @brief Build agent metadata.
     */
    ECSVulnerabilityEvent::Agent buildAgentData(const std::shared_ptr<TScanContext>& context) const
    {
        ECSVulnerabilityEvent::Agent agent;
        agent.id = std::string(context->agentId());
        agent.name = std::string(context->agentName());
        agent.version = std::string(context->agentVersion());

        // Cluster node name for manager (agent 000)
        if (context->agentId() == "000")
        {
            agent.ephemeral_id = std::string(context->clusterNodeName());
        }

        return agent;
    }

    /**
     * @brief Build package metadata based on component type.
     * Uses data from CVEDetectionResult when the affected component is a package.
     */
    ECSVulnerabilityEvent::Package buildPackageData(const std::shared_ptr<TScanContext>& /*context*/,
                                                    const CVEDetectionResult& detection,
                                                    const std::string& osFullName,
                                                    const std::string& osVersion,
                                                    const std::string& osType) const
    {
        ECSVulnerabilityEvent::Package package;

        switch (detection.componentType)
        {
            case AffectedComponentType::Package:
                // Use data from CVEDetectionResult (populated during scanning)
                package.name = detection.packageName;
                package.version = detection.packageVersion;
                package.type = detection.packageFormat;
                package.architecture = detection.packageArchitecture;
                package.description = detection.packageDescription;
                package.path = detection.packageLocation;
                package.size = detection.packageSize;

                // Convert install time to ISO8601
                if (!detection.packageInstallTime.empty())
                {
                    package.installed = Utils::rawTimestampToISO8601(detection.packageInstallTime);
                }

                // NOTE: build_version, checksum, install_scope, license and reference
                // are not yet part of CVEDetectionResult. They are left empty and
                // will be serialized only if populated in the future.
                break;

            case AffectedComponentType::Os:
                // For OS vulnerabilities, package section describes the OS "package"
                package.name = osFullName;
                package.version = osVersion;
                package.type = osType;
                break;

            default:
                break;
        }

        return package;
    }

    /**
     * @brief Build host OS metadata.
     */
    ECSVulnerabilityEvent::HostOS buildHostOSData(const std::shared_ptr<TScanContext>& context,
                                                  const std::string& osFullName,
                                                  const std::string& osVersion,
                                                  const std::string& osType) const
    {
        ECSVulnerabilityEvent::HostOS hostOS;
        hostOS.full = osFullName;
        hostOS.kernel = std::string(context->osKernelRelease());
        hostOS.name = std::string(context->osName());
        hostOS.platform = Utils::toLowerCase(std::string(context->osPlatform()));
        hostOS.type = osType;
        hostOS.version = osVersion;
        return hostOS;
    }

    /**
     * @brief Build scanner condition string.
     */
    std::string buildScannerCondition(const CVEDetectionResult& detection) const
    {
        switch (detection.conditionType)
        {
            case MatchRuleCondition::Equal: return "Package equal to " + detection.matchCondition;
            case MatchRuleCondition::LessThan: return "Package less than " + detection.matchCondition;
            case MatchRuleCondition::LessThanOrEqual:
                return "Package less than or equal to " + detection.matchCondition;
            case MatchRuleCondition::DefaultStatus: return "Package default status";
            default:
                logDebug2(
                    WM_VULNSCAN_LOGTAG, "Unknown match condition type: %d", static_cast<int>(detection.conditionType));
                return "Unknown";
        }
    }

    /**
     * @brief Build vulnerability metadata from CVE description.
     */
    ECSVulnerabilityEvent::Vulnerability buildVulnerabilityData(const CVEDetectionResult& detection,
                                                                const CveDescription& description,
                                                                const std::shared_ptr<TScanContext>& /*context*/) const
    {
        ECSVulnerabilityEvent::Vulnerability vuln;

        vuln.id = detection.cveId;
        vuln.classification = FieldAlertHelper::fillEmptyOrNegative(description.classification);
        vuln.description = description.description;
        vuln.detected_at = Utils::getCurrentISO8601();
        vuln.published_at = description.datePublished;
        vuln.reference = description.reference;
        vuln.severity =
            FieldAlertHelper::fillEmptyOrNegative(Utils::toSentenceCase(std::string {description.severity}));

        // Category based on component type
        vuln.category = (detection.componentType == AffectedComponentType::Os) ? "OS" : "Packages";

        // CVSS Score
        vuln.score.base = FieldAlertHelper::fillEmptyOrNegative(Utils::floatToDoubleRound(description.scoreBase, 2));
        vuln.score.version = FieldAlertHelper::fillEmptyOrNegative(description.scoreVersion);

        // Under evaluation flag
        vuln.under_evaluation = (Utils::floatToDoubleRound(description.scoreBase, 2) == 0 ||
                                 description.scoreVersion.empty() || description.severity.empty());

        // Scanner metadata
        try
        {
            vuln.scanner.source = TGlobalData::instance()
                                      .vendorMaps()
                                      .at("adp_descriptions")
                                      .at(detection.cnaSource)
                                      .at("adp")
                                      .template get<std::string>();
        }
        catch (const std::exception& e)
        {
            logWarn(WM_VULNSCAN_LOGTAG,
                    "Failed to get scanner source for CNA '%s': %s (using CNA name)",
                    detection.cnaSource.c_str(),
                    e.what());
            vuln.scanner.source = detection.cnaSource;
        }

        vuln.scanner.reference = std::string(WAZUH_CTI_CVES_URL) + detection.cveId;
        vuln.scanner.condition = buildScannerCondition(detection);

        // NOTE: report_id, score.environmental and score.temporal are left with
        // default values and will only be serialized when populated.

        return vuln;
    }

    /**
     * @brief Build complete ECS event.
     */
    ECSVulnerabilityEvent buildECSEvent(const std::shared_ptr<TScanContext>& context,
                                        const CVEDetectionResult& detection,
                                        const CveDescription& description) const
    {
        ECSVulnerabilityEvent event;

        // Pre-compute shared data
        const auto osFullName = buildOSFullName(context);
        const auto osVersion = buildOSVersion(context);
        const auto osType = buildOSType(context);

        // Build sections
        event.agent = buildAgentData(context);
        event.package = buildPackageData(context, detection, osFullName, osVersion, osType);
        event.host_os = buildHostOSData(context, osFullName, osVersion, osType);
        event.vulnerability = buildVulnerabilityData(detection, description, context);

        // Wazuh metadata
        event.wazuh.cluster_name = std::string(context->clusterName());
        event.wazuh.cluster_node = std::string(context->clusterNodeName());

        return event;
    }

public:
    explicit TEventDetailsBuilder(std::shared_ptr<TDatabaseFeedManager> databaseFeedManager)
        : m_databaseFeedManager(std::move(databaseFeedManager))
    {
    }

    ~TEventDetailsBuilder() = default;

    /**
     * @brief Build ECS events for all detected CVEs.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> context) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Building ECS events for %zu CVE detections (component type: %d)",
                  context->cveCount(),
                  static_cast<int>(context->affectedComponentType()));

        // Get CVE description sources based on vulnerability source
        const auto descriptionSources =
            DescriptionsHelper::cvssAndDescriptionSources<TGlobalData>(context->m_vulnerabilitySource);

        // Process each detected CVE (non-const to allow updating feedOffset)
        for (auto& [detectionId, detection] : context->detectedCVEs())
        {
            // If the operation is DELETE, this detection will be used to delete the document,
            // not to index a new one. We do not generate an ECS event in this case.
            if (detection.operation == ElementOperation::Delete)
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Skipping ECS event build for detection '%s' (CVE %s) with Delete operation",
                          detectionId.c_str(),
                          detection.cveId.c_str());
                continue;
            }

            const auto& cveId = detection.cveId;

            try
            {
                // Fetch CVE description from feed
                DescriptionsHelper::vulnerabilityDescription<TDatabaseFeedManager, TGlobalData>(
                    cveId,
                    descriptionSources,
                    m_databaseFeedManager,
                    [&](const CveDescription& description)
                    {
                        // Update feed offset for versioned detection
                        detection.feedOffset = description.offset;

                        // Build ECS event
                        auto ecsEvent = buildECSEvent(context, detection, description);

                        // Serialize to JSON for storage/indexing
                        context->addECSEvent(detectionId, ecsEvent.toJSON());

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "Built ECS event for detection '%s' (CVE %s, agent: %s, package: %s)",
                                  detectionId.c_str(),
                                  cveId.c_str(),
                                  context->agentId().data(),
                                  detection.packageName.c_str());
                    });
            }
            catch (const std::exception& e)
            {
                logError(WM_VULNSCAN_LOGTAG,
                         "Failed to build ECS event for detection '%s' (CVE %s): %s",
                         detectionId.c_str(),
                         cveId.c_str(),
                         e.what());
            }
        }

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Completed building ECS events for agent %s (total detections: %zu)",
                  context->agentId().data(),
                  context->cveCount());

        context->logDebugContext();
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(context));
    }
};

using EventDetailsBuilder = TEventDetailsBuilder<>;

#endif // _EVENT_DETAILS_BUILDER_HPP
