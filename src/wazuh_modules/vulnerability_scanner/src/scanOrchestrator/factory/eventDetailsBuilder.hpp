/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 11, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General
 * Public License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_DETAILS_BUILDER_HPP
#define _EVENT_DETAILS_BUILDER_HPP

#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "descriptionsHelper.hpp"
#include "fieldAlertHelper.hpp"
#include "loggerHelper.h"
#include "numericHelper.h"
#include "scanContext.hpp"
#include "timeHelper.h"
#include <json.hpp>
#include <sstream>

constexpr auto WAZUH_SCHEMA_VERSION = "1.0.0";

/**
 * @brief TEventDetailsBuilder class.
 *
 * Builds ECS-compliant vulnerability documents for the wazuh-states-vulnerabilities
 * index from the data stored in ScanContext and CVEDetectionResult.
 *
 * It does NOT introduce additional structs: it reuses:
 *  - AgentContextData (inside ScanContext)
 *  - OsContextData    (inside ScanContext)
 *  - PackageContextData (inside CVEDetectionResult::package)
 *  - Vulnerability      (inside CVEDetectionResult::vulnerability)
 */
template<typename TDatabaseFeedManager = DatabaseFeedManager,
         typename TScanContext = ScanContext,
         typename TGlobalData = GlobalData>
class TEventDetailsBuilder final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;

    /**
     * @brief Build OS type (normalized to lowercase).
     *
     * For macOS we normalize "darwin" -> "macos".
     */
    std::string buildOSType(const std::shared_ptr<TScanContext>& context) const
    {
        if (!context->agentHostOsType().empty())
        {
            return Utils::toLowerCase(std::string {context->agentHostOsType()});
        }

        if (!context->osKernelSysName().empty())
        {
            return Utils::toLowerCase(std::string {context->osKernelSysName()});
        }

        return Utils::toLowerCase(context->osPlatform() == "darwin" ? std::string {"macos"}
                                                                    : std::string {context->osPlatform()});
    }

    /**
     * @brief Build scanner condition (human-readable).
     *
     * Uses detection.matchCondition and detection.conditionType to generate a short
     * explanation about why the package/OS matches the vulnerable range.
     */
    std::string buildScannerCondition(const CVEDetectionResult& detection) const
    {
        switch (detection.conditionType)
        {
            case MatchRuleCondition::Equal: return "Package equal to " + detection.matchCondition;
            case MatchRuleCondition::LessThan: return "Package less than " + detection.matchCondition;
            case MatchRuleCondition::LessThanOrEqual:
                return "Package less than or equal to " + detection.matchCondition;
            case MatchRuleCondition::DefaultStatus: return "Package default status";
            default:
                logDebug2(
                    WM_VULNSCAN_LOGTAG, "Unknown match condition type: %d", static_cast<int>(detection.conditionType));
                return "Unknown";
        }
    }

    /**
     * @brief Enrich detection.vulnerability using the CVE description from the feed.
     *
     * This method:
     *  - Ensures cveId is set (CVE id).
     *  - Fills classification, description, dates, severity.
     *  - Fills vulnerability.score.base / version.
     *  - Sets under_evaluation based on score/severity availability.
     *  - Fills scanner.source / scanner.reference / scanner.condition.
     *
     * NOTE: vulnerability.category is set outside, because it depends on the
     *       component type (OS vs Package).
     */
    void enrichVulnerabilityModel(CVEDetectionResult& detection, const CveDescription& description) const
    {
        auto& vuln = detection.vulnerability;

        // Basic descriptive fields
        vuln.id = detection.cveId;
        vuln.classification = FieldAlertHelper::fillEmptyOrNegative(description.classification);
        vuln.description = description.description;
        vuln.detected_at = Utils::getCurrentISO8601();
        vuln.published_at = description.datePublished;
        vuln.reference = description.reference;

        vuln.severity =
            FieldAlertHelper::fillEmptyOrNegative(Utils::toSentenceCase(std::string {description.severity}));

        // CVSS score (base + version)
        vuln.score.base = FieldAlertHelper::fillEmptyOrNegative(Utils::floatToDoubleRound(description.scoreBase, 2));
        vuln.score.version = FieldAlertHelper::fillEmptyOrNegative(description.scoreVersion);

        // under_evaluation flag: if we don't have a proper score/severity
        vuln.under_evaluation = (Utils::floatToDoubleRound(description.scoreBase, 2) == 0.0 ||
                                 description.scoreVersion.empty() || description.severity.empty());

        // scanner.source (ADP description)
        try
        {
            if (!detection.cnaSource.empty())
            {
                vuln.scanner.source = TGlobalData::instance()
                                          .vendorMaps()
                                          .at("adp_descriptions")
                                          .at(detection.cnaSource)
                                          .at("adp")
                                          .template get<std::string>();
            }
        }
        catch (const std::exception& e)
        {
            logWarn(WM_VULNSCAN_LOGTAG,
                    "Failed to get scanner source for CNA '%s': %s (using CNA name or leaving empty)",
                    detection.cnaSource.c_str(),
                    e.what());
            if (!detection.cnaSource.empty())
            {
                vuln.scanner.source = detection.cnaSource;
            }
        }

        // scanner.reference: Wazuh CTI CVEs URL + CVE id
        if (!vuln.id.empty())
        {
            vuln.scanner.reference = std::string(WAZUH_CTI_CVES_URL) + vuln.id;
        }

        // scanner.condition (version rule summary)
        vuln.scanner.condition = buildScannerCondition(detection);

        // vuln.scanner.vendor already defaults to "Wazuh" in struct definition.
    }

    /**
     * @brief Build the final ECS JSON document for a single detection.
     *
     * IMPORTANT:
     *  - For package vulnerabilities:
     *      - Fill package.* resolving the package entry from ScanContext using detectionId.
     *      - Always fill host.os.* from ScanContext OS cache.
     *  - For OS vulnerabilities:
     *      - Fill ONLY host.os.* (no package.* section).
     */
    std::string buildEventJSON(const std::shared_ptr<TScanContext>& context,
                               const CVEDetectionResult& detection,
                               const PackageContextData* packageCtx) const
    {
        const auto osFullName = context->buildOSFullName();
        const auto osVersion = context->buildOSVersion();
        const auto osType = buildOSType(context);

        const auto& vuln = detection.vulnerability;

        nlohmann::json json;

        // ---------------------------------------------------------------------
        // wazuh.agent.*
        // ---------------------------------------------------------------------
        json["wazuh"]["agent"]["id"] = context->agentId();
        json["wazuh"]["agent"]["name"] = context->agentName();
        json["wazuh"]["agent"]["type"] = "Wazuh";
        json["wazuh"]["agent"]["version"] = context->agentVersion();

        if (!context->agentHostArchitecture().empty())
        {
            json["wazuh"]["agent"]["host"]["architecture"] = context->agentHostArchitecture();
        }
        if (!context->agentHostName().empty())
        {
            json["wazuh"]["agent"]["host"]["hostname"] = context->agentHostName();
        }
        if (!context->agentIP().empty())
        {
            json["wazuh"]["agent"]["host"]["ip"] = context->agentIP();
        }
        if (!context->agentHostOsName().empty())
        {
            json["wazuh"]["agent"]["host"]["os"]["name"] = context->agentHostOsName();
        }
        if (!context->agentHostOsPlatform().empty())
        {
            json["wazuh"]["agent"]["host"]["os"]["platform"] = context->agentHostOsPlatform();
        }
        if (!context->agentHostOsType().empty())
        {
            json["wazuh"]["agent"]["host"]["os"]["type"] = context->agentHostOsType();
        }
        if (!context->agentHostOsVersion().empty())
        {
            json["wazuh"]["agent"]["host"]["os"]["version"] = context->agentHostOsVersion();
        }
        if (!context->agentGroups().empty())
        {
            json["wazuh"]["agent"]["groups"] = context->agentGroups();
        }

        // ---------------------------------------------------------------------
        // package.*
        //
        // For package vulnerabilities we use the package context.
        // For OS vulnerabilities we also fill package.* with OS data as the affected component.
        // ---------------------------------------------------------------------
        if (detection.componentType == AffectedComponentType::Package && packageCtx)
        {
            if (!packageCtx->name.empty())
            {
                json["package"]["name"] = packageCtx->name;
            }
            if (!packageCtx->version.empty())
            {
                json["package"]["version"] = packageCtx->version;
            }
            json["package"]["type"] = packageCtx->format;
            if (!packageCtx->architecture.empty())
            {
                json["package"]["architecture"] = packageCtx->architecture;
            }
            if (!packageCtx->description.empty())
            {
                json["package"]["description"] = packageCtx->description;
            }
            json["package"]["path"] = packageCtx->location;
            if (packageCtx->size > 0)
            {
                json["package"]["size"] = packageCtx->size;
            }

            if (!packageCtx->install_time.empty())
            {
                const auto iso = Utils::rawTimestampToISO8601(packageCtx->install_time);
                if (!iso.empty())
                {
                    json["package"]["installed"] = iso;
                }
            }
        }
        else if (detection.componentType == AffectedComponentType::Os)
        {
            // For OS detections:
            //  - If it is a DELETE and we have deleted OS data, emit that in package.*
            //  - Otherwise use the current OS cache.
            const bool useDeleted = detection.operation == ElementOperation::Delete && context->hasDeletedOSItemId();

            const auto& name = useDeleted ? context->deletedOSName() : context->osName();
            const auto& version = useDeleted ? context->deletedOSVersion() : context->osVersion();
            const auto& arch = useDeleted ? context->deletedOSArchitecture() : context->osArchitecture();
            const auto& platform = useDeleted ? context->deletedOSPlatform() : context->osPlatform();
            const auto& description = useDeleted ? context->deletedOSCodeName() : context->osCodeName();

            if (!name.empty())
            {
                json["package"]["name"] = name;
            }
            if (!version.empty())
            {
                json["package"]["version"] = version;
            }
            if (!arch.empty())
            {
                json["package"]["architecture"] = arch;
            }
            if (!platform.empty())
            {
                json["package"]["type"] = platform;
            }
            if (!description.empty())
            {
                json["package"]["description"] = description;
            }
        }

        // ---------------------------------------------------------------------
        // host.os.*
        // ---------------------------------------------------------------------
        if (!osFullName.empty())
        {
            json["host"]["os"]["full"] = osFullName;
        }
        if (!context->osKernelRelease().empty())
        {
            json["host"]["os"]["kernel"] = context->osKernelRelease();
        }
        if (!context->osName().empty())
        {
            json["host"]["os"]["name"] = context->osName();
        }
        if (!context->osPlatform().empty())
        {
            json["host"]["os"]["platform"] = Utils::toLowerCase(std::string(context->osPlatform()));
        }
        if (!osType.empty())
        {
            json["host"]["os"]["type"] = osType;
        }
        if (!osVersion.empty())
        {
            json["host"]["os"]["version"] = osVersion;
        }

        // ---------------------------------------------------------------------
        // vulnerability.*
        // ---------------------------------------------------------------------
        if (!vuln.id.empty())
        {
            json["vulnerability"]["id"] = vuln.id;
        }
        if (!vuln.classification.empty())
        {
            json["vulnerability"]["classification"] = vuln.classification;
        }
        if (!vuln.description.empty())
        {
            json["vulnerability"]["description"] = vuln.description;
        }
        if (!vuln.detected_at.empty())
        {
            json["vulnerability"]["detected_at"] = vuln.detected_at;
        }
        if (!vuln.enumeration.empty())
        {
            json["vulnerability"]["enumeration"] = vuln.enumeration;
        }
        if (!vuln.published_at.empty())
        {
            json["vulnerability"]["published_at"] = vuln.published_at;
        }
        if (!vuln.reference.empty())
        {
            json["vulnerability"]["reference"] = vuln.reference;
        }
        if (!vuln.severity.empty())
        {
            json["vulnerability"]["severity"] = vuln.severity;
        }

        // Category: OS / Packages
        if (!vuln.category.empty())
        {
            json["vulnerability"]["category"] = vuln.category;
        }

        json["vulnerability"]["under_evaluation"] = vuln.under_evaluation;

        if (!vuln.report_id.empty())
        {
            json["vulnerability"]["report_id"] = vuln.report_id;
        }

        // vulnerability.score.*
        json["vulnerability"]["score"]["base"] = vuln.score.base;
        if (vuln.score.environmental > 0.0)
        {
            json["vulnerability"]["score"]["environmental"] = vuln.score.environmental;
        }
        if (vuln.score.temporal > 0.0)
        {
            json["vulnerability"]["score"]["temporal"] = vuln.score.temporal;
        }
        if (!vuln.score.version.empty())
        {
            json["vulnerability"]["score"]["version"] = vuln.score.version;
        }

        // vulnerability.scanner.*
        json["vulnerability"]["scanner"]["vendor"] = vuln.scanner.vendor;
        if (!vuln.scanner.source.empty())
        {
            json["vulnerability"]["scanner"]["source"] = vuln.scanner.source;
        }
        if (!vuln.scanner.reference.empty())
        {
            json["vulnerability"]["scanner"]["reference"] = vuln.scanner.reference;
        }
        if (!vuln.scanner.condition.empty())
        {
            json["vulnerability"]["scanner"]["condition"] = vuln.scanner.condition;
        }

        // ---------------------------------------------------------------------
        // wazuh.*
        // ---------------------------------------------------------------------
        if (!context->clusterName().empty())
        {
            json["wazuh"]["cluster"]["name"] = context->clusterName();
        }
        if (!context->clusterNodeName().empty())
        {
            json["wazuh"]["cluster"]["node"] = context->clusterNodeName();
        }
        json["wazuh"]["schema"]["version"] = WAZUH_SCHEMA_VERSION;

        // NOTE: We intentionally do NOT set @timestamp or event.* because
        // the wazuh-states-vulnerabilities template uses dynamic: "strict"
        // and those fields are not part of the current mapping.

        return json.dump();
    }

public:
    explicit TEventDetailsBuilder(std::shared_ptr<TDatabaseFeedManager> databaseFeedManager)
        : m_databaseFeedManager(std::move(databaseFeedManager))
    {
    }

    ~TEventDetailsBuilder() = default;

    /**
     * @brief Build ECS events for all detected CVEs.
     *
     * IMPORTANT:
     *  - We DO build events for both Upsert and Delete operations.
     *  - The Indexer/Dispatcher will decide whether the document is indexed
     *    or deleted using detection.operation.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> context) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Building ECS events for %zu CVE detections (affectedComponentType=%d)",
                  context->cveCount(),
                  static_cast<int>(context->affectedComponentType()));

        if (context->cveCount() == 0)
        {
            logDebug1(WM_VULNSCAN_LOGTAG,
                      "No vulnerabilities found for agent '%s', stopping scan chain",
                      context->agentId().data());
            return nullptr;
        }

        // Determine description sources based on m_vulnerabilitySource (base / expanded).
        const auto descriptionSources =
            DescriptionsHelper::cvssAndDescriptionSources<TGlobalData>(context->m_vulnerabilitySource);

        // Iterate over ALL detections (including Delete operations).
        for (auto& [detectionId, detection] : context->detectedCVEs())
        {

            const auto& cveId = detection.cveId;

            if (cveId.empty())
            {
                logWarn(WM_VULNSCAN_LOGTAG, "Detection '%s' has empty cveId, skipping ECS build", detectionId.c_str());
                continue;
            }

            try
            {
                // Fetch CVE description and enrich the detection model.
                DescriptionsHelper::vulnerabilityDescription<TDatabaseFeedManager, TGlobalData>(
                    cveId,
                    descriptionSources,
                    m_databaseFeedManager,
                    [&](const CveDescription& description)
                    {
                        // Update feed offset (for feed versioning).
                        detection.feedOffset = description.offset;

                        // Enrich detection.vulnerability from CVE description.
                        enrichVulnerabilityModel(detection, description);

                        // Set category depending on affected component.
                        detection.vulnerability.category =
                            (detection.componentType == AffectedComponentType::Os) ? "OS" : "Packages";

                        const PackageContextData* pkgCtxPtr = nullptr;
                        if (detection.componentType == AffectedComponentType::Package)
                        {
                            pkgCtxPtr = context->findPackageByDetectionId(detectionId);

                            if (!pkgCtxPtr)
                            {
                                logWarn(WM_VULNSCAN_LOGTAG,
                                        "Package context not found for detection '%s' (CVE %s), building ECS without "
                                        "package",
                                        detectionId.c_str(),
                                        cveId.c_str());
                            }
                        }

                        // Build ECS JSON.
                        auto eventJson = buildEventJSON(context, detection, pkgCtxPtr);

                        // Store ECS event JSON in context (keyed by detectionId).
                        context->addECSEvent(detectionId, std::move(eventJson));

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "Built ECS event for detection '%s' (CVE %s, op=%d, agent=%s)",
                                  detectionId.c_str(),
                                  cveId.c_str(),
                                  static_cast<int>(detection.operation),
                                  context->agentId().data());
                    });
            }
            catch (const std::exception& e)
            {
                logError(WM_VULNSCAN_LOGTAG,
                         "Failed to build ECS event for detection '%s' (CVE %s): %s",
                         detectionId.c_str(),
                         cveId.c_str(),
                         e.what());
            }
        }

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Completed building ECS events for agent %s (detections=%zu, ecsEvents=%zu)",
                  context->agentId().data(),
                  context->cveCount(),
                  context->ecsEventCount());

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(context));
    }
};

using EventDetailsBuilder = TEventDetailsBuilder<>;

#endif // _EVENT_DETAILS_BUILDER_HPP
