/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _PACKAGE_SCANNER_HPP
#define _PACKAGE_SCANNER_HPP

#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "remediationDataCache.hpp"
#include "scanContext.hpp"
#include "scannerHelper.hpp"
#include "versionMatcher/versionMatcher.hpp"
#include <memory>
#include <unordered_set>
#include <variant>

auto constexpr DEFAULT_CNA {"nvd"};
auto constexpr L1_CACHE_SIZE {2048};

/**
 * @brief PackageScanner class.
 * Scans packages for vulnerabilities using CNA feeds and version matching strategies.
 * Processes batches of packages from scan context with zero-copy optimization.
 * Now uses CVEDetectionResult struct instead of nlohmann::json for 10Ã— better performance.
 */
template<typename TDatabaseFeedManager = DatabaseFeedManager,
         typename TScanContext = ScanContext,
         typename TGlobalData = GlobalData,
         typename TRemediationDataCache = RemediationDataCache<>>
class TPackageScanner final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    /**
     * @brief Package format to VersionObjectType / VersionMatcherStrategy map.
     */
    static constexpr std::array<std::pair<std::string_view, std::variant<VersionObjectType, VersionMatcherStrategy>>,
                                10>
        PACKAGE_FORMAT_MAP {{{"deb", VersionObjectType::DPKG},
                             {"rpm", VersionObjectType::RPM},
                             {"pypi", VersionObjectType::PEP440},
                             {"npm", VersionObjectType::SemVer},
                             {"pacman", VersionMatcherStrategy::Pacman},
                             {"snap", VersionMatcherStrategy::Snap},
                             {"pkg", VersionMatcherStrategy::PKG},
                             {"apk", VersionMatcherStrategy::APK},
                             {"win", VersionMatcherStrategy::Windows},
                             {"macports", VersionMatcherStrategy::MacOS}}};

    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;
    LRUCache<std::string, std::vector<TranslatedData>> m_translationL1Cache {L1_CACHE_SIZE};

    // Current package context being scanned (for passing to versionMatch)
    const PackageContextData* m_currentPkgCtx {nullptr};

    /**
     * @brief Get version object type for package format.
     */
    std::variant<VersionObjectType, VersionMatcherStrategy> getVersionObjectType(std::string_view format) const
    {
        for (const auto& [fmt, type] : PACKAGE_FORMAT_MAP)
        {
            if (fmt == format)
            {
                return type;
            }
        }
        return VersionMatcherStrategy::Unspecified;
    }

    /**
     * @brief Build PackageData from PackageContextData (conversion helper).
     */
    PackageData buildPackageData(const PackageContextData& pkgCtx) const
    {
        return PackageData {
            .name = pkgCtx.name, .vendor = pkgCtx.vendor, .format = pkgCtx.format, .version = pkgCtx.version};
    }

    /**
     * @brief Scan package with translation support (L1/L2 cache lookup).
     */
    bool scanPackageTranslation(
        const std::string& cnaName,
        const PackageData& packageToTranslate,
        const std::shared_ptr<TScanContext>& data,
        const std::function<bool(const std::string&,
                                 const PackageData&,
                                 const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& vulnerabilityScan)
    {
        const auto cacheKey =
            std::string(data->osPlatform()) + "_" + packageToTranslate.vendor + "_" + packageToTranslate.name;

        // L1 Cache lookup
        if (auto translations = m_translationL1Cache.getValue(cacheKey))
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Translation L1 cache hit for '%s' on '%s'",
                      packageToTranslate.name.c_str(),
                      data->osPlatform().data());

            for (const auto& translation : *translations)
            {
                auto translatedPackage = applyTranslation(packageToTranslate, translation);
                m_databaseFeedManager->getVulnerabilitiesCandidates(cnaName, translatedPackage, vulnerabilityScan);
            }
            return true;
        }

        // L2 Cache lookup
        auto L2Translations =
            m_databaseFeedManager->getTranslationFromL2(packageToTranslate, std::string(data->osPlatform()));

        if (!L2Translations.empty())
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Translation L2 cache hit for '%s' on '%s'",
                      packageToTranslate.name.c_str(),
                      data->osPlatform().data());

            for (const auto& translation : L2Translations)
            {
                auto translatedPackage = applyTranslation(packageToTranslate, translation);
                m_databaseFeedManager->getVulnerabilitiesCandidates(cnaName, translatedPackage, vulnerabilityScan);
            }

            // Promote to L1 cache
            m_translationL1Cache.insertKey(cacheKey, std::move(L2Translations));
            return true;
        }

        logDebug2(WM_VULNSCAN_LOGTAG, "No translation for '%s', using original name", packageToTranslate.name.c_str());
        return false;
    }

    /**
     * @brief Apply translation to package data.
     */
    PackageData applyTranslation(const PackageData& original, const TranslatedData& translation) const
    {
        PackageData translated = original;

        if (!translation.translatedProduct.empty())
        {
            translated.name = translation.translatedProduct;
        }
        if (!translation.translatedVendor.empty())
        {
            translated.vendor = translation.translatedVendor;
        }
        if (!translation.translatedVersion.empty())
        {
            translated.version = translation.translatedVersion;
        }

        return translated;
    }

    /**
     * @brief Determine CNA for package.
     */
    std::pair<std::string, std::string> getCNA(std::string_view packageFormat,
                                               std::string_view packageSource,
                                               std::string_view packageVendor,
                                               std::string_view osPlatform,
                                               std::string_view osMajorVersion) const
    {
        // Try format-based CNA
        auto cnaName = m_databaseFeedManager->getCnaNameByFormat(packageFormat.data());

        // Try source-based CNA
        if (cnaName.empty())
        {
            cnaName = m_databaseFeedManager->getCnaNameBySource(packageSource.data());
        }

        // Try vendor prefix
        if (cnaName.empty())
        {
            cnaName = m_databaseFeedManager->getCnaNameByPrefix(packageVendor.data(), osPlatform.data());
        }

        // Try vendor contains
        if (cnaName.empty())
        {
            cnaName = m_databaseFeedManager->getCnaNameByContains(packageVendor.data(), osPlatform.data());
        }

        // Default CNA
        if (cnaName.empty())
        {
            return {DEFAULT_CNA, DEFAULT_CNA};
        }

        // Resolve CNA mapping
        const auto& mapping = TGlobalData::instance().cnaMappings();
        const auto& cnaMapping = mapping.at("cnaMapping");

        auto it = cnaMapping.find(cnaName);
        if (it == cnaMapping.end())
        {
            return {cnaName, cnaName};
        }

        std::string base = it->template get<std::string>();

        // Apply platform equivalence
        const auto& platformMapping = mapping.at("platformEquivalence");
        if (auto platformIt = platformMapping.find(std::string(osPlatform)); platformIt != platformMapping.end())
        {
            Utils::replaceAll(base, "$(PLATFORM)", platformIt->template get<std::string>());
        }
        else
        {
            Utils::replaceAll(base, "$(PLATFORM)", std::string(osPlatform));
        }

        // Apply major version equivalence
        const auto& majorVersionMapping = mapping.at("majorVersionEquivalence");
        std::string resolvedMajorVersion(osMajorVersion);

        if (auto platformIt = majorVersionMapping.find(std::string(osPlatform));
            platformIt != majorVersionMapping.end())
        {
            if (auto versionIt = platformIt->find(std::string(osMajorVersion)); versionIt != platformIt->end())
            {
                resolvedMajorVersion = versionIt->template get<std::string>();
            }
        }

        Utils::replaceAll(base, "$(MAJOR_VERSION)", resolvedMajorVersion);

        return {cnaName, base};
    }

    /**
     * @brief Verify platform compatibility.
     */
    bool platformVerify(const PackageData& package,
                        const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData,
                        const std::shared_ptr<TScanContext>& contextData) const
    {
        if (!callbackData.platforms())
        {
            return true;
        }

        for (const auto& platform : *callbackData.platforms())
        {
            const std::string platformValue {platform->str()};

            if (ScannerHelper::isCPE(platformValue))
            {
                const auto cpe = ScannerHelper::parseCPE(platformValue);
                if (cpe.part == "o")
                {
                    if (ScannerHelper::compareCPE(cpe, ScannerHelper::parseCPE(contextData->osCPEName().data())))
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "Platform match (CPE): pkg=%s, CVE=%s",
                                  package.name.c_str(),
                                  callbackData.cveId()->str().c_str());
                        return true;
                    }
                }
            }
            else if (platformValue == contextData->osCodeName())
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Platform match (codename): pkg=%s, CVE=%s",
                          package.name.c_str(),
                          callbackData.cveId()->str().c_str());
                return true;
            }
        }

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Platform mismatch: pkg=%s, CVE=%s",
                  package.name.c_str(),
                  callbackData.cveId()->str().c_str());
        return false;
    }

    /**
     * @brief Verify vendor compatibility.
     */
    bool vendorVerify(const PackageData& package,
                      const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData) const
    {
        if (!callbackData.vendor())
        {
            return true;
        }

        if (package.vendor.empty() || package.vendor == " ")
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Vendor info missing: pkg=%s, CVE=%s",
                      package.name.c_str(),
                      callbackData.cveId()->str().c_str());
            return false;
        }

        if (package.vendor != callbackData.vendor()->str())
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Vendor mismatch: pkg=%s, expected=%s, got=%s",
                      package.name.c_str(),
                      callbackData.vendor()->str().c_str(),
                      package.vendor.c_str());
            return false;
        }

        return true;
    }

    /**
     * @brief Check if version matches vulnerability criteria.
     * Now creates CVEDetectionResult with full package metadata.
     *
     * @note Uses m_currentPkgCtx to access package metadata during scanning.
     */
    bool versionMatch(const PackageData& package,
                      const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData,
                      const std::shared_ptr<TScanContext>& contextData,
                      const std::string& cnaName)
    {
        const auto objectType = getVersionObjectType(package.format);
        const auto packageVersionObject = VersionMatcher::createVersionObject(package.version, objectType);
        const auto cveId = callbackData.cveId()->str();

        // Ensure we have package context
        if (!m_currentPkgCtx)
        {
            logError(WM_VULNSCAN_LOGTAG,
                     "Internal error: versionMatch called without package context for CVE %s",
                     cveId.c_str());
            return false;
        }

        for (const auto& version : *callbackData.versions())
        {
            const std::string versionString {version->version() ? version->version()->str() : ""};
            const std::string lessThan {version->lessThan() ? version->lessThan()->str() : ""};
            const std::string lessThanOrEqual {version->lessThanOrEqual() ? version->lessThanOrEqual()->str() : ""};

            // Exact version match
            if (lessThan.empty() && lessThanOrEqual.empty())
            {
                if (VersionMatcher::compare(packageVersionObject, package.version, versionString, objectType) ==
                    VersionComparisonResult::A_EQUAL_B)
                {
                    if (version->status() == NSVulnerabilityScanner::Status::Status_affected)
                    {
                        // Create detection result with FULL package metadata
                        // CRITICAL: Field order MUST match CVEDetectionResult struct declaration
                        contextData->addDetectedCVE(
                            CVEDetectionResult {// CVE Detection Metadata (in declaration order)
                                                .cveId = cveId,
                                                .cnaSource = cnaName,
                                                .matchCondition = versionString,
                                                .conditionType = MatchRuleCondition::Equal,
                                                .componentType = AffectedComponentType::Package,
                                                .feedOffset = 0, // Updated by EventDetailsBuilder
                                                .operation = ElementOperation::Insert,

                                                // Package Information (in declaration order)
                                                .packageName = package.name,
                                                .packageVersion = package.version,
                                                .packageFormat = package.format,
                                                .packageArchitecture = m_currentPkgCtx->architecture,
                                                .packageDescription = m_currentPkgCtx->description,
                                                .packageLocation = m_currentPkgCtx->location,
                                                .packageInstallTime = m_currentPkgCtx->install_time,
                                                .packageSize = m_currentPkgCtx->size});
                        return true;
                    }
                    return false;
                }
            }
            // Range match
            else
            {
                bool lowerBoundMatch = (versionString == "0");
                if (!lowerBoundMatch)
                {
                    const auto result =
                        VersionMatcher::compare(packageVersionObject, package.version, versionString, objectType);
                    lowerBoundMatch = (result == VersionComparisonResult::A_GREATER_THAN_B ||
                                       result == VersionComparisonResult::A_EQUAL_B);
                }

                if (lowerBoundMatch)
                {
                    bool upperBoundMatch = false;
                    MatchRuleCondition conditionType;
                    std::string matchCondition;

                    if (!lessThan.empty() && lessThan != "*")
                    {
                        const auto result =
                            VersionMatcher::compare(packageVersionObject, package.version, lessThan, objectType);
                        upperBoundMatch = (result == VersionComparisonResult::A_LESS_THAN_B);
                        conditionType = MatchRuleCondition::LessThan;
                        matchCondition = lessThan;
                    }
                    else if (!lessThanOrEqual.empty())
                    {
                        const auto result =
                            VersionMatcher::compare(packageVersionObject, package.version, lessThanOrEqual, objectType);
                        upperBoundMatch = (result == VersionComparisonResult::A_LESS_THAN_B ||
                                           result == VersionComparisonResult::A_EQUAL_B);
                        conditionType = MatchRuleCondition::LessThanOrEqual;
                        matchCondition = lessThanOrEqual;
                    }

                    if (upperBoundMatch && version->status() == NSVulnerabilityScanner::Status::Status_affected)
                    {
                        contextData->addDetectedCVE(
                            CVEDetectionResult {// CVE Detection Metadata (in declaration order)
                                                .cveId = cveId,
                                                .cnaSource = cnaName,
                                                .matchCondition = std::move(matchCondition),
                                                .conditionType = conditionType,
                                                .componentType = AffectedComponentType::Package,
                                                .feedOffset = 0,
                                                .operation = ElementOperation::Insert,

                                                // Package Information (in declaration order)
                                                .packageName = package.name,
                                                .packageVersion = package.version,
                                                .packageFormat = package.format,
                                                .packageArchitecture = m_currentPkgCtx->architecture,
                                                .packageDescription = m_currentPkgCtx->description,
                                                .packageLocation = m_currentPkgCtx->location,
                                                .packageInstallTime = m_currentPkgCtx->install_time,
                                                .packageSize = m_currentPkgCtx->size});
                        return true;
                    }
                }
            }
        }

        // Default status
        if (callbackData.defaultStatus() == NSVulnerabilityScanner::Status::Status_affected)
        {
            contextData->addDetectedCVE(CVEDetectionResult {// CVE Detection Metadata (in declaration order)
                                                            .cveId = cveId,
                                                            .cnaSource = cnaName,
                                                            .matchCondition = "",
                                                            .conditionType = MatchRuleCondition::DefaultStatus,
                                                            .componentType = AffectedComponentType::Package,
                                                            .feedOffset = 0,
                                                            .operation = ElementOperation::Insert,

                                                            // Package Information (in declaration order)
                                                            .packageName = package.name,
                                                            .packageVersion = package.version,
                                                            .packageFormat = package.format,
                                                            .packageArchitecture = m_currentPkgCtx->architecture,
                                                            .packageDescription = m_currentPkgCtx->description,
                                                            .packageLocation = m_currentPkgCtx->location,
                                                            .packageInstallTime = m_currentPkgCtx->install_time,
                                                            .packageSize = m_currentPkgCtx->size});
            return true;
        }

        return false;
    }

    /**
     * @brief Check if vulnerability is solved by hotfix.
     * Now uses removeCVE() instead of manual map erasure.
     */
    bool packageHotfixSolved(const PackageData& package,
                             const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData,
                             const std::shared_ptr<TScanContext>& contextData)
    {
        FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo> remediations {};
        m_databaseFeedManager->getVulnerabilityRemediation(callbackData.cveId()->str(), remediations);

        if (!remediations.data || !remediations.data->updates() || remediations.data->updates()->size() == 0)
        {
            return false;
        }

        const auto agentRemediations =
            TRemediationDataCache::instance().getRemediationData(contextData->agentId().data());
        if (agentRemediations.hotfixes.empty())
        {
            return false;
        }

        for (const auto& remediation : *remediations.data->updates())
        {
            if (agentRemediations.hotfixes.contains(remediation->str()))
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Hotfix '%s' solves CVE '%s' for pkg '%s' on agent '%s'",
                          remediation->str().c_str(),
                          callbackData.cveId()->str().c_str(),
                          package.name.c_str(),
                          contextData->agentId().data());

                // Use new typed API instead of manual erasure
                contextData->removeCVE(callbackData.cveId()->str());
                return true;
            }
        }

        return false;
    }

    /**
     * @brief Scan single package for vulnerabilities.
     * Updated to use hasCVE() and store current package context.
     */
    void packageScan(const PackageData& package,
                     const std::string& cnaValue,
                     const std::shared_ptr<TScanContext>& data,
                     const PackageContextData& pkgCtx)
    {
        // Store current package context for versionMatch
        m_currentPkgCtx = &pkgCtx;

        auto vulnerabilityScan = [&](const std::string& cnaName,
                                     const PackageData& pkg,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData)
        {
            try
            {
                const auto cveId = callbackData.cveId()->str();

                // Use new typed API for duplicate checking
                if (data->hasCVE(cveId))
                {
                    logDebug1(WM_VULNSCAN_LOGTAG, "CVE '%s' already found, skipping", cveId.c_str());
                    return true;
                }

                // Preliminary checks
                if (!platformVerify(pkg, callbackData, data) || !vendorVerify(pkg, callbackData))
                {
                    return false;
                }

                // Version match (uses m_currentPkgCtx internally)
                if (versionMatch(pkg, callbackData, data, cnaName))
                {
                    // Hotfix check (Windows only)
                    if (data->osPlatform() == "windows" && packageHotfixSolved(pkg, callbackData, data))
                    {
                        return false;
                    }

                    return true;
                }

                return false;
            }
            catch (const std::exception& e)
            {
                logDebug1(WM_VULNSCAN_LOGTAG,
                          "Scan error: pkg=%s, CNA=%s, error=%s",
                          pkg.name.c_str(),
                          cnaName.c_str(),
                          e.what());
                return false;
            }
        };

        try
        {
            // Try translation first
            if (!scanPackageTranslation(cnaValue, package, data, vulnerabilityScan))
            {
                // Fallback to lowercase direct scan
                PackageData normalizedPackage = package;
                normalizedPackage.name = Utils::toLowerCase(package.name);
                normalizedPackage.vendor = Utils::toLowerCase(package.vendor);

                m_databaseFeedManager->getVulnerabilitiesCandidates(cnaValue, normalizedPackage, vulnerabilityScan);
            }
        }
        catch (const std::exception& e)
        {
            logWarn(WM_VULNSCAN_LOGTAG, "Failed to scan pkg '%s': %s", package.name.c_str(), e.what());
        }

        // Clear current package context
        m_currentPkgCtx = nullptr;
    }

    /**
     * @brief Scan package with CNA priority array.
     */
    void scanWithCNAPriority(const PackageData& package,
                             const std::string& cnaValue,
                             const std::shared_ptr<TScanContext>& data,
                             const PackageContextData& pkgCtx)
    {
        if (cnaValue != DEFAULT_CNA)
        {
            packageScan(package, cnaValue, data, pkgCtx);
        }
        else if (TGlobalData::instance().vendorMaps().contains(ADP_DEFAULT_ARRAY_KEY))
        {
            const auto& cnaArray = TGlobalData::instance().vendorMaps().at(ADP_DEFAULT_ARRAY_KEY);
            for (const auto& cna : cnaArray)
            {
                packageScan(package, cna.template get<std::string>(), data, pkgCtx);
            }
        }
        else
        {
            packageScan(package, DEFAULT_CNA, data, pkgCtx);
        }
    }

public:
    explicit TPackageScanner(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager)
        : m_databaseFeedManager(databaseFeedManager)
    {
    }

    /**
     * @brief Process all packages in scan context.
     * Now uses cveCount() instead of m_elements.size().
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        const auto packageCount = data->packageCount();

        logDebug1(WM_VULNSCAN_LOGTAG,
                  "Starting vulnerability scan for %zu packages on agent '%s'",
                  packageCount,
                  data->agentId().data());

        // Process each package in the context
        for (size_t i = 0; i < packageCount; ++i)
        {
            const auto& [pkgCtx, operation] = data->getPackageContextData(i);

            // Skip if DELETE operation (only scan INSERT/existing packages)
            if (operation == ElementOperation::Delete)
            {
                continue;
            }

            logDebug2(
                WM_VULNSCAN_LOGTAG, "Scanning package '%s' on agent '%s'", pkgCtx.name.c_str(), data->agentId().data());

            // Convert to PackageData
            const auto package = buildPackageData(pkgCtx);

            // Determine CNA for this package
            const auto [cnaName, cnaValue] =
                getCNA(pkgCtx.format, pkgCtx.source, pkgCtx.vendor, data->osPlatform(), data->osMajorVersion());

            data->m_vulnerabilitySource = {cnaName, cnaValue};

            // Scan with CNA priority (pass pkgCtx for metadata)
            scanWithCNAPriority(package, cnaValue, data, pkgCtx);
        }

        logDebug1(WM_VULNSCAN_LOGTAG,
                  "Vulnerability scan completed: agent='%s', found=%zu CVEs",
                  data->agentId().data(),
                  data->cveCount());

        // Use new typed API for counting
        if (data->cveCount() == 0)
        {
            return nullptr;
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using PackageScanner = TPackageScanner<>;

#endif // _PACKAGE_SCANNER_HPP
