/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _PACKAGE_SCANNER_HPP
#define _PACKAGE_SCANNER_HPP

#include "chainOfResponsability.hpp"
#include "databaseFeedManager.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "scannerHelper.hpp"
#include "versionMatcher/versionMatcher.hpp"
#include <chrono>
#include <memory>
#include <unordered_set>
#include <variant>

auto constexpr DEFAULT_CNA {"nvd"};
auto constexpr L1_CACHE_SIZE {2048};

/**
 * @brief PackageScanner class.
 * Scans packages for vulnerabilities using CNA feeds and version matching strategies.
 * Processes batches of packages from scan context with zero-copy optimization.
 * Now uses CVEDetectionResult struct instead of nlohmann::json for better performance.
 */
template<typename TDatabaseFeedManager = DatabaseFeedManager,
         typename TScanContext = ScanContext,
         typename TGlobalData = GlobalData>
class TPackageScanner final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    /**
     * @brief Get string representation of comparison result.
     */
    static const char* getComparisonString(VersionComparisonResult result)
    {
        switch (result)
        {
            case VersionComparisonResult::A_LESS_THAN_B: return "LOWER";
            case VersionComparisonResult::A_EQUAL_B: return "EQUAL";
            case VersionComparisonResult::A_GREATER_THAN_B: return "HIGHER";
            default: return "UNKNOWN";
        }
    }

    /**
     * @brief Package format to VersionObjectType / VersionMatcherStrategy map.
     */
    static constexpr std::array<std::pair<std::string_view, std::variant<VersionObjectType, VersionMatcherStrategy>>,
                                10>
        PACKAGE_FORMAT_MAP {{{"deb", VersionObjectType::DPKG},
                             {"rpm", VersionObjectType::RPM},
                             {"pypi", VersionObjectType::PEP440},
                             {"npm", VersionObjectType::SemVer},
                             {"pacman", VersionMatcherStrategy::Pacman},
                             {"snap", VersionMatcherStrategy::Snap},
                             {"pkg", VersionMatcherStrategy::PKG},
                             {"apk", VersionMatcherStrategy::APK},
                             {"win", VersionMatcherStrategy::Windows},
                             {"macports", VersionMatcherStrategy::MacOS}}};

    std::shared_ptr<TDatabaseFeedManager> m_databaseFeedManager;
    LRUCache<std::string, std::vector<TranslatedData>> m_translationL1Cache {L1_CACHE_SIZE};

    /**
     * @brief Per-package scan statistics.
     */
    struct PackageScanStats
    {
        std::string packageName;
        std::string packageVersion;
        size_t cveCandidates {0};
        size_t vulnerabilitiesFound {0};
        size_t platformMismatches {0};
        size_t vendorMismatches {0};
        size_t versionMismatches {0};
        size_t hotfixesSolved {0};
    };

    /**
     * @brief Overall scan statistics (per handleRequest call).
     */
    struct ScanStatistics
    {
        std::chrono::steady_clock::time_point startTime;
        size_t totalPackages {0};
        size_t scannedPackages {0};
        size_t skippedPackages {0};
        size_t vulnerablePackages {0};
        size_t totalCVECandidates {0};
        size_t totalVulnerabilities {0};
        size_t translationHits {0};
        size_t platformMismatches {0};
        size_t vendorMismatches {0};
        size_t versionMismatches {0};
        size_t hotfixesSolved {0};

        // Per-package details
        std::vector<PackageScanStats> packageStats;
    };

    mutable ScanStatistics m_stats;

    /**
     * @brief Get version object type for package format.
     */
    std::variant<VersionObjectType, VersionMatcherStrategy> getVersionObjectType(std::string_view format) const
    {
        for (const auto& [fmt, type] : PACKAGE_FORMAT_MAP)
        {
            if (fmt == format)
            {
                return type;
            }
        }

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Unknown package format: '%.*s', using 'Unspecified strategy'",
                  static_cast<int>(format.size()),
                  format.data());

        return VersionMatcherStrategy::Unspecified;
    }

    /**
     * @brief Build PackageData from PackageContextData (conversion helper).
     */
    PackageData buildPackageData(const PackageContextData& pkgCtx) const
    {
        return PackageData {
            .name = pkgCtx.name, .vendor = pkgCtx.vendor, .format = pkgCtx.format, .version = pkgCtx.version};
    }

    /**
     * @brief Build a unique detection identifier for "agent + package + CVE".
     *
     * This ID is used as the key in the detected CVE map and will be later
     * reused as the _id / item_id of the vulnerability document in the indexer.
     *
     * For packages:
     *   detectionId = <agentId>_<packageInventoryId>_<cveId>
     */
    static std::string buildDetectionId(std::string_view detectionIdBase, const std::string& cveId)
    {
        std::string detectionId {detectionIdBase};
        detectionId.push_back('_');
        detectionId.append(cveId);
        return detectionId;
    }

    /**
     * @brief Scan package with translation support (L1/L2 cache lookup).
     */
    bool scanPackageTranslation(
        const std::string& cnaName,
        const PackageData& packageToTranslate,
        const std::shared_ptr<TScanContext>& data,
        const std::function<bool(const std::string&,
                                 const PackageData&,
                                 const NSVulnerabilityScanner::ScanVulnerabilityCandidate&)>& vulnerabilityScan)
    {
        const auto cacheKey =
            std::string(data->osPlatform()) + "_" + packageToTranslate.vendor + "_" + packageToTranslate.name;

        // L1 Cache lookup
        if (auto translations = m_translationL1Cache.getValue(cacheKey))
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Translation L1 cache hit for '%s' (vendor: '%s') on '%s'",
                      packageToTranslate.name.c_str(),
                      packageToTranslate.vendor.c_str(),
                      data->osPlatform().data());

            m_stats.translationHits++;

            for (const auto& translation : *translations)
            {
                auto translatedPackage = applyTranslation(packageToTranslate, translation);

                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Applying translation: Name: '%s' -> '%s' / Vendor: '%s' -> '%s'",
                          packageToTranslate.name.c_str(),
                          translatedPackage.name.c_str(),
                          packageToTranslate.vendor.c_str(),
                          translatedPackage.vendor.c_str());

                m_databaseFeedManager->getVulnerabilitiesCandidates(cnaName, translatedPackage, vulnerabilityScan);
            }
            return true;
        }

        // L2 Cache lookup
        auto L2Translations =
            m_databaseFeedManager->getTranslationFromL2(packageToTranslate, std::string(data->osPlatform()));

        if (!L2Translations.empty())
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Translation L2 cache hit for '%s' (vendor: '%s') on '%s', promoting to L1",
                      packageToTranslate.name.c_str(),
                      packageToTranslate.vendor.c_str(),
                      data->osPlatform().data());

            m_stats.translationHits++;

            for (const auto& translation : L2Translations)
            {
                auto translatedPackage = applyTranslation(packageToTranslate, translation);

                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Applying translation: Name: '%s' -> '%s' / Vendor: '%s' -> '%s'",
                          packageToTranslate.name.c_str(),
                          translatedPackage.name.c_str(),
                          packageToTranslate.vendor.c_str(),
                          translatedPackage.vendor.c_str());

                m_databaseFeedManager->getVulnerabilitiesCandidates(cnaName, translatedPackage, vulnerabilityScan);
            }

            // Promote to L1 cache
            m_translationL1Cache.insertKey(cacheKey, std::move(L2Translations));
            return true;
        }

        logDebug2(
            WM_VULNSCAN_LOGTAG, "No translation found for '%s', using original name", packageToTranslate.name.c_str());
        return false;
    }

    /**
     * @brief Apply translation to package data.
     */
    PackageData applyTranslation(const PackageData& original, const TranslatedData& translation) const
    {
        PackageData translated = original;

        if (!translation.translatedProduct.empty())
        {
            translated.name = translation.translatedProduct;
        }
        if (!translation.translatedVendor.empty())
        {
            translated.vendor = translation.translatedVendor;
        }
        if (!translation.translatedVersion.empty())
        {
            translated.version = translation.translatedVersion;
        }

        return translated;
    }

    /**
     * @brief Determine CNA for package.
     */
    std::pair<std::string, std::string> getCNA(std::string_view packageFormat,
                                               std::string_view packageSource,
                                               std::string_view packageVendor,
                                               std::string_view osPlatform,
                                               std::string_view osMajorVersion) const
    {
        // Try format-based CNA
        auto cnaName = m_databaseFeedManager->getCnaNameByFormat(packageFormat.data());

        // Try source-based CNA
        if (cnaName.empty() && !packageSource.empty())
        {
            cnaName = m_databaseFeedManager->getCnaNameBySource(packageSource.data());
        }

        // Try vendor prefix
        if (cnaName.empty() && !packageVendor.empty())
        {
            cnaName = m_databaseFeedManager->getCnaNameByPrefix(packageVendor.data(), osPlatform.data());
        }

        // Try vendor contains
        if (cnaName.empty() && !packageVendor.empty())
        {
            cnaName = m_databaseFeedManager->getCnaNameByContains(packageVendor.data(), osPlatform.data());
        }

        // Default CNA
        if (cnaName.empty())
        {
            logDebug2(WM_VULNSCAN_LOGTAG, "No specific CNA found for package, using default: '%s'", DEFAULT_CNA);
            return {DEFAULT_CNA, DEFAULT_CNA};
        }

        // Resolve CNA mapping
        const auto& mapping = TGlobalData::instance().cnaMappings();

        auto cnaMappingIt = mapping.find("cnaMapping");
        if (cnaMappingIt == mapping.end())
        {
            logWarn(
                WM_VULNSCAN_LOGTAG, "cnaMapping not found in global data, using CNA name as-is: '%s'", cnaName.c_str());
            return {cnaName, cnaName};
        }

        const auto& cnaMapping = cnaMappingIt.value();

        auto it = cnaMapping.find(cnaName);
        if (it == cnaMapping.end())
        {
            logDebug2(WM_VULNSCAN_LOGTAG, "CNA '%s' not in mapping, using as-is", cnaName.c_str());
            return {cnaName, cnaName};
        }

        std::string base = it->template get<std::string>();

        // Apply platform equivalence
        auto platformMappingIt = mapping.find("platformEquivalence");
        if (platformMappingIt != mapping.end())
        {
            const auto& platformMapping = platformMappingIt.value();
            if (auto platformIt = platformMapping.find(std::string(osPlatform)); platformIt != platformMapping.end())
            {
                Utils::replaceAll(base, "$(PLATFORM)", platformIt->template get<std::string>());
            }
            else
            {
                Utils::replaceAll(base, "$(PLATFORM)", std::string(osPlatform));
            }
        }
        else
        {
            Utils::replaceAll(base, "$(PLATFORM)", std::string(osPlatform));
        }

        // Apply major version equivalence
        std::string resolvedMajorVersion(osMajorVersion);
        auto majorVersionMappingIt = mapping.find("majorVersionEquivalence");

        if (majorVersionMappingIt != mapping.end())
        {
            const auto& majorVersionMapping = majorVersionMappingIt.value();

            if (auto platformIt = majorVersionMapping.find(std::string(osPlatform));
                platformIt != majorVersionMapping.end())
            {
                if (auto versionIt = platformIt->find(std::string(osMajorVersion)); versionIt != platformIt->end())
                {
                    resolvedMajorVersion = versionIt->template get<std::string>();
                }
            }
        }

        Utils::replaceAll(base, "$(MAJOR_VERSION)", resolvedMajorVersion);

        logDebug2(WM_VULNSCAN_LOGTAG, "Resolved CNA: name='%s', base='%s'", cnaName.c_str(), base.c_str());

        return {cnaName, base};
    }

    /**
     * @brief Verify platform compatibility with statistics tracking.
     */
    bool platformVerify(const PackageData& package,
                        const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData,
                        const std::shared_ptr<TScanContext>& contextData,
                        PackageScanStats& pkgStats) const
    {
        if (!callbackData.platforms() || callbackData.platforms()->size() == 0)
        {
            // No platform restrictions - matches all
            return true;
        }

        for (const auto& platform : *callbackData.platforms())
        {
            if (!platform)
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Null platform entry for CVE '%s', skipping",
                          callbackData.cveId()->str().c_str());
                continue;
            }

            const std::string platformValue {platform->str()};

            if (ScannerHelper::isCPE(platformValue))
            {
                const auto cpe = ScannerHelper::parseCPE(platformValue);
                if (cpe.part == "o") // Operating system CPE
                {
                    if (ScannerHelper::compareCPE(cpe, ScannerHelper::parseCPE(contextData->osCPEName().data())))
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "Platform match (CPE): pkg='%s', CVE='%s'",
                                  package.name.c_str(),
                                  callbackData.cveId()->str().c_str());
                        return true;
                    }
                }
            }
            else if (platformValue == contextData->osCodeName())
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Platform match (codename): pkg='%s', CVE='%s'",
                          package.name.c_str(),
                          callbackData.cveId()->str().c_str());
                return true;
            }
        }

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Platform mismatch: pkg='%s', CVE='%s'",
                  package.name.c_str(),
                  callbackData.cveId()->str().c_str());

        pkgStats.platformMismatches++;
        m_stats.platformMismatches++;
        return false;
    }

    /**
     * @brief Verify vendor compatibility with statistics tracking.
     */
    bool vendorVerify(const PackageData& package,
                      const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData,
                      PackageScanStats& pkgStats) const
    {
        if (!callbackData.vendor())
        {
            // No vendor requirement - matches all
            return true;
        }

        if (package.vendor.empty() || package.vendor == " ")
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Vendor info missing: pkg='%s', CVE='%s', expected='%s'",
                      package.name.c_str(),
                      callbackData.cveId()->str().c_str(),
                      callbackData.vendor()->str().c_str());

            pkgStats.vendorMismatches++;
            m_stats.vendorMismatches++;
            return false;
        }

        if (package.vendor != callbackData.vendor()->str())
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Vendor mismatch: pkg='%s', CVE='%s', expected='%s', got='%s'",
                      package.name.c_str(),
                      callbackData.cveId()->str().c_str(),
                      callbackData.vendor()->str().c_str(),
                      package.vendor.c_str());

            pkgStats.vendorMismatches++;
            m_stats.vendorMismatches++;
            return false;
        }

        return true;
    }

    /**
     * @brief Check if version matches vulnerability criteria.
     *
     * @param package Package metadata.
     * @param callbackData Vulnerability candidate.
     * @param pkgStats Per-package statistics accumulator.
     * @param matchedCondition Out param with the matched condition type (if any).
     * @param matchedConditionValue Out param with the matched condition string.
     *
     * This function only determines if the package matches the vulnerability rules.
     * It does not add/remove detections from the ScanContext.
     */
    bool versionMatch(const PackageData& package,
                      const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData,
                      PackageScanStats& pkgStats,
                      MatchRuleCondition& matchedCondition,
                      std::string& matchedConditionValue)
    {
        const auto objectType = getVersionObjectType(package.format);
        const auto packageVersionObject = VersionMatcher::createVersionObject(package.version, objectType);
        const auto cveId = callbackData.cveId()->str();

        // If there are no explicit version rules, rely on default status.
        if (!callbackData.versions() || callbackData.versions()->size() == 0)
        {
            logDebug2(WM_VULNSCAN_LOGTAG, "No version rules for CVE '%s', checking default status", cveId.c_str());

            if (callbackData.defaultStatus() == NSVulnerabilityScanner::Status::Status_affected)
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Analyzing CVE: %s - Package '%s' (%s) is VULNERABLE - Default status: AFFECTED",
                          cveId.c_str(),
                          package.name.c_str(),
                          package.version.c_str());

                matchedCondition = MatchRuleCondition::DefaultStatus;
                matchedConditionValue = "";
                return true;
            }
            return false;
        }

        bool matched = false;

        for (const auto& version : *callbackData.versions())
        {
            if (!version)
            {
                logDebug2(WM_VULNSCAN_LOGTAG, "Null version entry for CVE '%s', skipping", cveId.c_str());
                continue;
            }

            const std::string versionString {version->version() ? version->version()->str() : ""};
            const std::string lessThan {version->lessThan() ? version->lessThan()->str() : ""};
            const std::string lessThanOrEqual {version->lessThanOrEqual() ? version->lessThanOrEqual()->str() : ""};

            // Exact version match
            if (lessThan.empty() && lessThanOrEqual.empty())
            {
                auto result = VersionMatcher::compare(packageVersionObject, package.version, versionString, objectType);

                if (result == VersionComparisonResult::A_EQUAL_B)
                {
                    if (version->status() == NSVulnerabilityScanner::Status::Status_affected)
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "Analyzing CVE: %s - Package '%s' (%s) is VULNERABLE - "
                                  "Installed version is EQUAL to affected version '%s'",
                                  cveId.c_str(),
                                  package.name.c_str(),
                                  package.version.c_str(),
                                  versionString.c_str());

                        matchedCondition = MatchRuleCondition::Equal;
                        matchedConditionValue = versionString;
                        matched = true;
                        break;
                    }
                    else
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "Analyzing CVE: %s - Package '%s' (%s) is NOT vulnerable - "
                                  "Version matches but status is not AFFECTED",
                                  cveId.c_str(),
                                  package.name.c_str(),
                                  package.version.c_str());
                    }
                }
                else
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Analyzing CVE: %s - Package '%s' (%s) is NOT vulnerable - "
                              "Installed version is %s to affected version '%s'",
                              cveId.c_str(),
                              package.name.c_str(),
                              package.version.c_str(),
                              getComparisonString(result),
                              versionString.c_str());
                }
            }
            // Range match
            else
            {
                // Check lower bound
                bool lowerBoundMatch = (versionString == "0" || versionString.empty());
                if (!lowerBoundMatch && !versionString.empty())
                {
                    const auto result =
                        VersionMatcher::compare(packageVersionObject, package.version, versionString, objectType);
                    lowerBoundMatch = (result == VersionComparisonResult::A_GREATER_THAN_B ||
                                       result == VersionComparisonResult::A_EQUAL_B);

                    if (!lowerBoundMatch)
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "Package '%s' (%s) below lower bound '%s' for CVE '%s'",
                                  package.name.c_str(),
                                  package.version.c_str(),
                                  versionString.c_str(),
                                  cveId.c_str());
                    }
                }

                if (lowerBoundMatch)
                {
                    bool upperBoundMatch = false;
                    MatchRuleCondition conditionType;
                    std::string matchCondition;

                    // Check upper bound (lessThan)
                    if (!lessThan.empty() && lessThan != "*")
                    {
                        const auto result =
                            VersionMatcher::compare(packageVersionObject, package.version, lessThan, objectType);
                        upperBoundMatch = (result == VersionComparisonResult::A_LESS_THAN_B);
                        conditionType = MatchRuleCondition::LessThan;
                        matchCondition = lessThan;

                        if (upperBoundMatch)
                        {
                            logDebug2(WM_VULNSCAN_LOGTAG,
                                      "Package '%s' (%s) is LESS THAN upper bound '%s' for CVE '%s'",
                                      package.name.c_str(),
                                      package.version.c_str(),
                                      lessThan.c_str(),
                                      cveId.c_str());
                        }
                        else
                        {
                            logDebug2(WM_VULNSCAN_LOGTAG,
                                      "Analyzing CVE: %s - Package '%s' (%s) is NOT vulnerable - "
                                      "Installed version is %s to upper bound '%s'",
                                      cveId.c_str(),
                                      package.name.c_str(),
                                      package.version.c_str(),
                                      getComparisonString(result),
                                      lessThan.c_str());
                        }
                    }
                    // Check upper bound (lessThanOrEqual)
                    else if (!lessThanOrEqual.empty())
                    {
                        const auto result =
                            VersionMatcher::compare(packageVersionObject, package.version, lessThanOrEqual, objectType);
                        upperBoundMatch = (result == VersionComparisonResult::A_LESS_THAN_B ||
                                           result == VersionComparisonResult::A_EQUAL_B);
                        conditionType = MatchRuleCondition::LessThanOrEqual;
                        matchCondition = lessThanOrEqual;

                        if (upperBoundMatch)
                        {
                            logDebug2(WM_VULNSCAN_LOGTAG,
                                      "Package '%s' (%s) is %s upper bound '%s' for CVE '%s'",
                                      package.name.c_str(),
                                      package.version.c_str(),
                                      (result == VersionComparisonResult::A_EQUAL_B ? "EQUAL TO" : "LESS THAN"),
                                      lessThanOrEqual.c_str(),
                                      cveId.c_str());
                        }
                        else
                        {
                            logDebug2(WM_VULNSCAN_LOGTAG,
                                      "Analyzing CVE: %s - Package '%s' (%s) is NOT vulnerable - "
                                      "Installed version is HIGHER than upper bound '%s'",
                                      cveId.c_str(),
                                      package.name.c_str(),
                                      package.version.c_str(),
                                      lessThanOrEqual.c_str());
                        }
                    }

                    if (upperBoundMatch && version->status() == NSVulnerabilityScanner::Status::Status_affected)
                    {
                        const char* condStr =
                            (conditionType == MatchRuleCondition::LessThan) ? "LOWER" : "LOWER OR EQUAL";

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "Analyzing CVE: %s - Package '%s' (%s) is VULNERABLE - "
                                  "Installed version is %s to affected version '%s'",
                                  cveId.c_str(),
                                  package.name.c_str(),
                                  package.version.c_str(),
                                  condStr,
                                  matchCondition.c_str());

                        matchedCondition = conditionType;
                        matchedConditionValue = std::move(matchCondition);
                        matched = true;
                        break;
                    }
                }
            }
        }

        // Default status check (if no version matched)
        if (!matched && callbackData.defaultStatus() == NSVulnerabilityScanner::Status::Status_affected)
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Analyzing CVE: %s - Package '%s' (%s) is VULNERABLE - Default status: AFFECTED",
                      cveId.c_str(),
                      package.name.c_str(),
                      package.version.c_str());

            matchedCondition = MatchRuleCondition::DefaultStatus;
            matchedConditionValue = "";
            matched = true;
        }

        if (!matched)
        {
            pkgStats.versionMismatches++;
            m_stats.versionMismatches++;
        }

        return matched;
    }

    /**
     * @brief Helper to create CVEDetectionResult with full package metadata.
     *
     * NOTE: The detectionId is not part of CVEDetectionResult. It is used
     * externally as the key in ScanContext::addDetectedCVE.
     *
     * This fills:
     *  - CVE metadata (cveId, cnaSource, condition, componentType, operation)
     *  - Package information (full PackageContextData, con nombre/vendor formateados)
     *  - Vulnerability struct with basic fields (id, enumeration, scanner.*)
     */
    CVEDetectionResult createDetectionResult(const std::string& cveId,
                                             const std::string& cnaName,
                                             std::string matchCondition,
                                             MatchRuleCondition conditionType,
                                             const std::string& detectionIdBase) const
    {
        CVEDetectionResult result;

        // --- CVE detection metadata ---
        result.cveId = cveId;
        result.cnaSource = cnaName;
        result.matchCondition = std::move(matchCondition);
        result.conditionType = conditionType;
        result.componentType = AffectedComponentType::Package;
        result.feedOffset.clear();
        result.operation = ElementOperation::Upsert;
        result.detectionIdBase = detectionIdBase;

        // --- Vulnerability information (minimum necessary) ---
        result.vulnerability.id = cveId;          // vulnerability.id
        result.vulnerability.enumeration = "CVE"; // vulnerability.enumeration
        result.vulnerability.classification.clear();
        result.vulnerability.description.clear();
        result.vulnerability.published_at.clear();
        result.vulnerability.reference.clear();
        result.vulnerability.severity.clear();
        result.vulnerability.category.clear();
        result.vulnerability.under_evaluation = false;
        result.vulnerability.report_id.clear();

        // Score will be filled later from feed (if applicable)
        result.vulnerability.score.base = 0.0;
        result.vulnerability.score.environmental = 0.0;
        result.vulnerability.score.temporal = 0.0;
        result.vulnerability.score.version.clear();

        // Scanner metadata
        result.vulnerability.scanner.vendor = "Wazuh"; // vulnerability.scanner.vendor
        result.vulnerability.scanner.source = cnaName; // vulnerability.scanner.source
        result.vulnerability.scanner.reference.clear();
        result.vulnerability.scanner.condition = result.matchCondition; // matching rule/version

        return result;
    }

    /**
     * @brief Check if vulnerability is solved by hotfix with statistics tracking.
     *
     * Uses:
     *  - Remediation info from the feed (CVE -> list of hotfix names).
     *  - Installed hotfix list from ScanContext::hotfixes() (inventory sync).
     */
    static std::string normalizeHotfixName(std::string_view name)
    {
        std::string normalized(name);
        std::transform(normalized.begin(), normalized.end(), normalized.begin(), ::tolower);
        return normalized;
    }

    bool packageHotfixSolved(const PackageData& package,
                             const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData,
                             const std::shared_ptr<TScanContext>& contextData,
                             const std::string& detectionId,
                             PackageScanStats& pkgStats)
    {
        FlatbufferDataPair<NSVulnerabilityScanner::RemediationInfo> remediations {};
        m_databaseFeedManager->getVulnerabilityRemediation(callbackData.cveId()->str(), remediations);

        if (!remediations.data || !remediations.data->updates() || remediations.data->updates()->size() == 0)
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "No remediation info found in feed for CVE '%s' (package '%s'), skipping hotfix check",
                      callbackData.cveId()->str().c_str(),
                      package.name.c_str());
            return false;
        }

        const auto& installedHotfixes = contextData->hotfixes();
        if (installedHotfixes.empty())
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Agent '%s' has no hotfixes registered, skipping hotfix remediation check for CVE '%s'",
                      contextData->agentId().data(),
                      callbackData.cveId()->str().c_str());
            return false;
        }

        for (const auto& remediation : *remediations.data->updates())
        {
            if (!remediation)
            {
                continue;
            }

            const auto remediationName = normalizeHotfixName(remediation->str());

            // Check if this remediation hotfix is installed on the agent
            for (const auto& hotfix : installedHotfixes)
            {
                if (normalizeHotfixName(hotfix.hotfixName) == remediationName)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Hotfix '%s' solves CVE '%s' for package '%s' (%s) on agent '%s'",
                              hotfix.hotfixName.c_str(),
                              callbackData.cveId()->str().c_str(),
                              package.name.c_str(),
                              package.version.c_str(),
                              contextData->agentId().data());

                    // Remove the specific detection (cluster + agent + package item_id + CVE)
                    contextData->removeCVE(detectionId);

                    pkgStats.hotfixesSolved++;
                    m_stats.hotfixesSolved++;

                    return true;
                }
            }
        }

        return false;
    }

    /**
     * @brief Scan single package with statistics tracking.
     */
    void packageScan(const PackageData& package,
                     const std::string& cnaValue,
                     const std::shared_ptr<TScanContext>& data,
                     const std::pair<std::string, PackageContextData>& pkgEntry,
                     PackageScanStats& pkgStats)
    {
        const auto& detectionIdBase = pkgEntry.first;
        const auto& pkgCtx = pkgEntry.second;

        auto vulnerabilityScan = [&](const std::string& cnaName,
                                     const PackageData& pkg,
                                     const NSVulnerabilityScanner::ScanVulnerabilityCandidate& callbackData)
        {
            try
            {
                pkgStats.cveCandidates++;
                m_stats.totalCVECandidates++;

                const auto cveId = callbackData.cveId()->str();
                const auto detectionId = buildDetectionId(detectionIdBase, cveId);

                if (!platformVerify(pkg, callbackData, data, pkgStats))
                {
                    return false;
                }

                if (!vendorVerify(pkg, callbackData, pkgStats))
                {
                    return false;
                }

                MatchRuleCondition matchCond {MatchRuleCondition::Unknown};
                std::string matchCondValue;

                if (versionMatch(pkg, callbackData, pkgStats, matchCond, matchCondValue))
                {
                    // Hotfix check (Windows-specific)
                    if (data->osPlatform() == "windows" &&
                        packageHotfixSolved(pkg, callbackData, data, detectionId, pkgStats))
                    {
                        return false;
                    }

                    if (data->hasCVE(detectionId))
                    {
                        data->removeCVE(detectionId);
                    }
                    else
                    {
                        auto det = createDetectionResult(
                            cveId, cnaName, std::move(matchCondValue), matchCond, detectionIdBase);
                        data->addDetectedCVE(detectionId, std::move(det));
                    }

                    pkgStats.vulnerabilitiesFound++;
                    return true;
                }

                return false;
            }
            catch (const std::exception& e)
            {
                logError(WM_VULNSCAN_LOGTAG,
                         "Exception scanning CVE for package '%s' (CNA: '%s'): %s",
                         pkg.name.c_str(),
                         cnaName.c_str(),
                         e.what());
                return false;
            }
        };

        try
        {
            if (!scanPackageTranslation(cnaValue, package, data, vulnerabilityScan))
            {
                PackageData normalizedPackage = package;
                normalizedPackage.name = Utils::toLowerCase(package.name);
                normalizedPackage.vendor = Utils::toLowerCase(package.vendor);

                m_databaseFeedManager->getVulnerabilitiesCandidates(cnaValue, normalizedPackage, vulnerabilityScan);
            }

            // Log per-package results
            if (pkgStats.vulnerabilitiesFound > 0)
            {
                logDebug1(WM_VULNSCAN_LOGTAG,
                          "Scan for package '%s' - Vendor: '%s' - Version: '%s' ended - "
                          "Found %zu vulnerabilities (analyzed %zu CVE candidates)",
                          package.name.c_str(),
                          package.vendor.c_str(),
                          package.version.c_str(),
                          pkgStats.vulnerabilitiesFound,
                          pkgStats.cveCandidates);
            }
            else
            {
                logDebug1(WM_VULNSCAN_LOGTAG,
                          "Scan for package '%s' - Vendor: '%s' - Version: '%s' ended - "
                          "No vulnerabilities found (analyzed %zu CVE candidates)",
                          package.name.c_str(),
                          package.vendor.c_str(),
                          package.version.c_str(),
                          pkgStats.cveCandidates);
            }
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "Failed to scan package '%s': %s", package.name.c_str(), e.what());
        }
    }

    /**
     * @brief Scan with CNA priority.
     */
    void scanWithCNAPriority(const PackageData& package,
                             const std::string& cnaValue,
                             const std::shared_ptr<TScanContext>& data,
                             const std::pair<std::string, PackageContextData>& pkgCtx,
                             PackageScanStats& pkgStats)
    {
        if (cnaValue != DEFAULT_CNA)
        {
            packageScan(package, cnaValue, data, pkgCtx, pkgStats);
        }
        else if (TGlobalData::instance().vendorMaps().contains(ADP_DEFAULT_ARRAY_KEY))
        {
            const auto& cnaArray = TGlobalData::instance().vendorMaps().at(ADP_DEFAULT_ARRAY_KEY);
            for (const auto& cna : cnaArray)
            {
                packageScan(package, cna.template get<std::string>(), data, pkgCtx, pkgStats);
            }
        }
        else
        {
            packageScan(package, DEFAULT_CNA, data, pkgCtx, pkgStats);
        }
    }

public:
    explicit TPackageScanner(std::shared_ptr<TDatabaseFeedManager>& databaseFeedManager)
        : m_databaseFeedManager(databaseFeedManager)
    {
    }

    /**
     * @brief Process all packages with comprehensive statistics.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        // Reset and initialize statistics
        m_stats = ScanStatistics {};
        m_stats.startTime = std::chrono::steady_clock::now();
        m_stats.totalPackages = data->packageCount();

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "Starting package scan for agent '%s' (%s) - Packages to scan: %zu",
                  data->agentId().data(),
                  data->agentVersion().data(),
                  m_stats.totalPackages);

        // Process each package
        for (const auto& entry : data->packages())
        {
            const auto& pkgCtx = entry.second;
            const auto operation = pkgCtx.operation;
            const auto package = buildPackageData(pkgCtx);

            if (operation == ElementOperation::Delete)
            {
                logDebug2(WM_VULNSCAN_LOGTAG, "Skipping package '%s' (DELETE operation)", pkgCtx.name.c_str());
                m_stats.skippedPackages++;
                continue;
            }

            m_stats.scannedPackages++;

            // Create per-package stats
            PackageScanStats pkgStats;
            pkgStats.packageName = pkgCtx.name;
            pkgStats.packageVersion = pkgCtx.version;

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "Scanning package [%zu/%zu]: '%s' - Vendor: '%s' - Version: '%s'",
                      m_stats.scannedPackages,
                      m_stats.totalPackages - m_stats.skippedPackages,
                      pkgCtx.name.c_str(),
                      pkgCtx.vendor.c_str(),
                      pkgCtx.version.c_str());

            const auto [cnaName, cnaValue] =
                getCNA(pkgCtx.format, pkgCtx.source, pkgCtx.vendor, data->osPlatform(), data->osMajorVersion());

            data->m_vulnerabilitySource = std::make_pair(cnaName, cnaValue);

            scanWithCNAPriority(package, cnaValue, data, entry, pkgStats);

            // Track vulnerable packages
            if (pkgStats.vulnerabilitiesFound > 0)
            {
                m_stats.vulnerablePackages++;
            }

            // Store per-package stats
            m_stats.packageStats.push_back(std::move(pkgStats));
        }

        const auto endTime = std::chrono::steady_clock::now();
        const auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - m_stats.startTime);

        m_stats.totalVulnerabilities = data->cveCount();

        // Print comprehensive summary
        logInfo(WM_VULNSCAN_LOGTAG,
                "Agent '%s' - Packages scan completed in %zu ms: "
                "%zu packages scanned, %zu skipped, %zu vulnerable packages, %zu total vulnerabilities found",
                data->agentId().data(),
                duration.count(),
                m_stats.scannedPackages,
                m_stats.skippedPackages,
                m_stats.vulnerablePackages,
                m_stats.totalVulnerabilities);

        logDebug1(WM_VULNSCAN_LOGTAG,
                  "Scan statistics: cve_candidates=%zu, translation_hits=%zu, "
                  "platform_mismatches=%zu, vendor_mismatches=%zu, version_mismatches=%zu, hotfixes_solved=%zu",
                  m_stats.totalCVECandidates,
                  m_stats.translationHits,
                  m_stats.platformMismatches,
                  m_stats.vendorMismatches,
                  m_stats.versionMismatches,
                  m_stats.hotfixesSolved);

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using PackageScanner = TPackageScanner<>;

#endif // _PACKAGE_SCANNER_HPP
