/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 8, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General
 * Public License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_SEND_REPORT_HPP
#define _EVENT_SEND_REPORT_HPP

#include "UNIXSocketRequest.hpp"
#include "chainOfResponsability.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "timeHelper.h"
#include "vulnerabilityScanner.hpp"

#include "defs.h"

#include <atomic>
#include <functional>
#include <json.hpp>
#include <sstream>
#include <string>
#include <string_view>
#include <unordered_set>
#include <vector>

/**
 * @brief Class in charge of sending formatted report messages.
 *
 * Sends vulnerability events to the Engine through the enriched-events HTTP
 * endpoint (UNIX socket: queue/sockets/queue-http.sock) using the legacy
 * H/E protocol expected by the engine:
 *
 *   H <json-metadata>
 *   E <queue>:<location>:<event>
 *   E <queue>:<location>:<event>
 *
 * The event payload follows the 4.x JSON format:
 * {
 *   "collector": "packages" | "system",
 *   "module": "vulnerability-scanner",
 *   "data": { "event": { "created": "...", "type": "upsert|delete" }, ... }
 * }
 *
 * @tparam TScanContext scan context type.
 */
template<typename TScanContext = ScanContext>
class TEventSendReport final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    static constexpr long HTTP_PAYLOAD_TOO_LARGE = 413;
    static constexpr size_t MAX_LOG_PAYLOAD_SIZE = 4096;
    // Engine queue identifier for VD events in the H/E protocol.
    static constexpr std::string_view QUEUE_ID = "v";

public:
    // LCOV_EXCL_START
    TEventSendReport() = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        const auto& detected = data->detectedCVEs();

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "EventSendReport - Sending %zu detections (ecsEvents=%zu)",
                  detected.size(),
                  data->ecsEventCount());

        if (detected.empty())
        {
            return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
        }

        nlohmann::json header;
        header["wazuh"]["agent"]["id"] = data->agentId();
        header["wazuh"]["agent"]["name"] = data->agentName();

        if (!data->agentHostName().empty())
        {
            header["wazuh"]["agent"]["host"]["hostname"] = data->agentHostName();
        }
        if (!data->agentHostArchitecture().empty())
        {
            header["wazuh"]["agent"]["host"]["architecture"] = data->agentHostArchitecture();
        }
        if (!data->agentHostOsName().empty())
        {
            header["wazuh"]["agent"]["host"]["os"]["name"] = data->agentHostOsName();
        }
        if (!data->agentHostOsVersion().empty())
        {
            header["wazuh"]["agent"]["host"]["os"]["version"] = data->agentHostOsVersion();
        }
        if (!data->agentHostOsPlatform().empty())
        {
            header["wazuh"]["agent"]["host"]["os"]["platform"] = data->agentHostOsPlatform();
        }
        if (!data->agentHostOsType().empty())
        {
            header["wazuh"]["agent"]["host"]["os"]["type"] = data->agentHostOsType();
        }

        std::vector<std::string> eventLines;
        eventLines.reserve(detected.size());
        for (const auto& [detectionId, detection] : detected)
        {
            const std::string* ecsJson = data->getECSEvent(detectionId);
            if (!ecsJson)
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "EventSendReport - No ECS event found for detection '%s', skipping",
                          detectionId.c_str());
                continue;
            }

            const std::string opType = (detection.operation == ElementOperation::Delete) ? "delete" : "upsert";
            const std::string collector =
                (detection.componentType == AffectedComponentType::Os) ? "system" : "packages";

            try
            {
                const auto ecs = nlohmann::json::parse(*ecsJson);

                nlohmann::json event;
                event["collector"] = collector;
                event["module"] = "vulnerability-scanner";
                event["data"]["event"]["created"] = Utils::getCurrentISO8601();
                event["data"]["event"]["type"] = opType;

                if (ecs.contains("host"))
                {
                    event["data"]["host"] = ecs["host"];
                }
                if (ecs.contains("package"))
                {
                    event["data"]["package"] = ecs["package"];
                }
                if (ecs.contains("vulnerability"))
                {
                    event["data"]["vulnerability"] = ecs["vulnerability"];
                }
                if (ecs.contains("wazuh") && ecs["wazuh"].is_object() && ecs["wazuh"].contains("cluster"))
                {
                    event["data"]["wazuh"]["cluster"] = ecs["wazuh"]["cluster"];
                }

                std::string line;
                line.reserve(64 + event.dump().size());
                line.append("E ");
                line.append(QUEUE_ID);
                line.append(":");
                line.append("vulnerability-scanner");
                line.append(":");
                line.append(event.dump());
                line.append("\n");
                eventLines.emplace_back(std::move(line));
            }
            catch (const std::exception& ex)
            {
                logWarn(WM_VULNSCAN_LOGTAG,
                        "EventSendReport - Failed to format ECS event for detection '%s': %s",
                        detectionId.c_str(),
                        ex.what());
            }
        }

        const std::size_t eventCount = eventLines.size();

        if (eventCount > 0)
        {
            const HttpUnixSocketURL url(ANLSYS_ENRICH_SOCK, "http://localhost/events/enriched");
            const std::unordered_set<std::string> headers {"Content-Type: application/x-wev1"};
            const std::atomic<bool> shouldRun {true};
            const std::string userAgent {"wazuh-vulnerability-scanner/1.0"};
            const ConfigurationParameters config {5000, CurlHandlerTypeEnum::SINGLE, shouldRun, userAgent};

            std::string headerLine = "H ";
            headerLine.append(header.dump());
            headerLine.append("\n");

            std::function<bool(size_t, size_t)> sendBatchRange;
            sendBatchRange = [&](size_t start, size_t end) -> bool
            {
                if (start >= end || end > eventLines.size())
                {
                    return true;
                }

                std::string payload;
                payload.reserve(headerLine.size() + (end - start) * 512);
                payload.append(headerLine);
                for (size_t i = start; i < end; ++i)
                {
                    payload.append(eventLines[i]);
                }

                if (payload.size() <= MAX_LOG_PAYLOAD_SIZE)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "EventSendReport - Payload (events=%zu, bytes=%zu): %s",
                              end - start,
                              payload.size(),
                              payload.c_str());
                }
                else
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "EventSendReport - Payload (events=%zu, bytes=%zu, truncated=%zu): %.*s...",
                              end - start,
                              payload.size(),
                              static_cast<size_t>(MAX_LOG_PAYLOAD_SIZE),
                              static_cast<int>(MAX_LOG_PAYLOAD_SIZE),
                              payload.c_str());
                }

                bool success = false;
                long statusCode = 0;
                std::string error;
                std::string responseBody;

                TRequestParameters<std::string_view> requestParams {url, std::string_view {payload}, {}, headers};
                TPostRequestParameters<const std::string&> postParams;
                postParams.onSuccess = [&](const std::string&)
                {
                    success = true;
                };
                postParams.onError = [&](const std::string& err, const long code, const std::string& body)
                {
                    statusCode = code;
                    error = err;
                    responseBody = body;
                };

                try
                {
                    UNIXSocketRequest::instance().post(requestParams, postParams, config);
                }
                catch (const std::exception& ex)
                {
                    logWarn(WM_VULNSCAN_LOGTAG, "EventSendReport - Engine POST failed (exception): %s", ex.what());
                    return false;
                }

                if (success)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG, "EventSendReport - Engine POST ok (events=%zu)", end - start);
                    return true;
                }

                if (statusCode == HTTP_PAYLOAD_TOO_LARGE)
                {
                    const auto count = end - start;
                    if (count <= 1)
                    {
                        logWarn(WM_VULNSCAN_LOGTAG,
                                "EventSendReport - Engine POST failed: single event exceeds payload limits "
                                "(events=%zu, size=%zu)",
                                count,
                                payload.size());
                        return false;
                    }

                    logDebug2(
                        WM_VULNSCAN_LOGTAG, "EventSendReport - Payload too large, splitting batch (events=%zu)", count);
                    const size_t mid = start + (count / 2);
                    return sendBatchRange(start, mid) && sendBatchRange(mid, end);
                }

                logWarn(WM_VULNSCAN_LOGTAG,
                        "EventSendReport - Engine POST failed (code=%ld): %s (body=%s)",
                        statusCode,
                        error.c_str(),
                        responseBody.c_str());
                return false;
            };

            sendBatchRange(0, eventLines.size());
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventSendReport = TEventSendReport<>;

#endif // _EVENT_SEND_REPORT_HPP
