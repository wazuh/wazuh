/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 8, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General
 * Public License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_SEND_REPORT_HPP
#define _EVENT_SEND_REPORT_HPP

#include "chainOfResponsability.hpp"
#include "defs.h"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "timeHelper.h"
#include "vulnerabilityScanner.hpp"
#include "UNIXSocketRequest.hpp"
#include <atomic>
#include <json.hpp>
#include <sstream>
#include <string>
#include <string_view>
#include <unordered_set>
#include <vector>

/**
 * @brief Class in charge of sending formatted report messages.
 *
 * Sends vulnerability events to the Engine through the enriched-events HTTP
 * endpoint (UNIX socket: queue/sockets/queue-http.sock) using the legacy
 * H/E protocol expected by the engine:
 *
 *   H\t<json-metadata>
 *   E\t<queue>:<location>:<event>
 *   E\t<queue>:<location>:<event>
 *
 * The event payload follows the 4.x JSON format:
 * {
 *   "collector": "packages" | "system",
 *   "module": "vulnerability-scanner",
 *   "data": { "event": { "created": "...", "type": "upsert|delete" }, ... }
 * }
 *
 * @tparam TScanContext scan context type.
 * @tparam TReportDispatcher report dispatcher type.
 */
template<typename TScanContext = ScanContext, typename TReportDispatcher = ReportDispatcher>
class TEventSendReport final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TReportDispatcher> m_reportDispatcher;
public:
    // LCOV_EXCL_START
    /**
     * @brief Construct a new Send Report object.
     *
     * @param reportDispatcher Report queue instance (unused, kept for interface compatibility).
     */
    explicit TEventSendReport(std::shared_ptr<TReportDispatcher> reportDispatcher)
        : m_reportDispatcher(std::move(reportDispatcher))
    {
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        const auto& detected = data->detectedCVEs();

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "EventSendReport - Sending %zu detections (ecsEvents=%zu)",
                  detected.size(),
                  data->ecsEventCount());

        if (detected.empty())
        {
            return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
        }

        nlohmann::json header;
        header["agent"]["id"] = data->agentId();
        header["agent"]["name"] = data->agentName();

        if (!data->agentHostName().empty())
        {
            header["host"]["hostname"] = data->agentHostName();
        }
        if (!data->agentHostArchitecture().empty())
        {
            header["host"]["architecture"] = data->agentHostArchitecture();
        }
        if (!data->agentHostOsName().empty())
        {
            header["host"]["os"]["name"] = data->agentHostOsName();
        }
        if (!data->agentHostOsVersion().empty())
        {
            header["host"]["os"]["version"] = data->agentHostOsVersion();
        }
        if (!data->agentHostOsPlatform().empty())
        {
            header["host"]["os"]["platform"] = data->agentHostOsPlatform();
        }
        if (!data->agentHostOsType().empty())
        {
            header["host"]["os"]["type"] = data->agentHostOsType();
        }

        std::string batch;
        batch.reserve(detected.size() * 512);
        batch.append("H\t");
        batch.append(header.dump());
        batch.append("\n");

        std::size_t eventCount = 0;
        for (const auto& [detectionId, detection] : detected)
        {
            try
            {
                // Get ECS JSON previously built by EventDetailsBuilder
                const std::string* ecsJson = data->getECSEvent(detectionId);
                if (!ecsJson)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "EventSendReport - No ECS event found for detection '%s', skipping",
                              detectionId.c_str());
                    continue;
                }

                try
                {
                    const std::string opType =
                        (detection.operation == ElementOperation::Delete) ? "delete" : "upsert";
                    const std::string collector =
                        (detection.componentType == AffectedComponentType::Os) ? "system" : "packages";

                    const auto ecs = nlohmann::json::parse(*ecsJson);

                    nlohmann::json event;
                    event["collector"] = collector;
                    event["module"] = "vulnerability-scanner";
                    event["data"]["event"]["created"] = Utils::getCurrentISO8601();
                    event["data"]["event"]["type"] = opType;

                    if (ecs.contains("host"))
                    {
                        event["data"]["host"] = ecs["host"];
                    }
                    if (ecs.contains("package"))
                    {
                        event["data"]["package"] = ecs["package"];
                    }
                    if (ecs.contains("vulnerability"))
                    {
                        event["data"]["vulnerability"] = ecs["vulnerability"];
                    }

                    batch.append("E\t");
                    batch.append("v");
                    batch.append(":");
                    batch.append("vulnerability-scanner");
                    batch.append(":");
                    batch.append(event.dump());
                    batch.append("\n");
                    ++eventCount;
                }
                catch (const std::exception& ex)
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "EventSendReport - Failed to format ECS event for detection '%s': %s",
                            detectionId.c_str(),
                            ex.what());
                    continue;
                }
            }
            catch (...)
            {
                logWarn(WM_VULNSCAN_LOGTAG,
                        "EventSendReport - Couldn't send vulnerability JSON report for detection '%s'.",
                        detectionId.c_str());
            }
        }

        if (eventCount > 0)
        {
            const HttpUnixSocketURL url(ANLSYS_ENRICH_SOCK, "http://localhost/events/enriched");
            const std::unordered_set<std::string> headers {"Content-Type: application/x-wev1"};
            const std::atomic<bool> shouldRun {true};
            const std::string userAgent {"wazuh-vulnerability-scanner/1.0"};
            const ConfigurationParameters config {5000, CurlHandlerTypeEnum::SINGLE, shouldRun, userAgent};

            TRequestParameters<std::string_view> requestParams {url, std::string_view {batch}, {}, headers};
            TPostRequestParameters<const std::string&> postParams;
            postParams.onError = [&](const std::string& error, const long code, const std::string& body)
            {
                logWarn(WM_VULNSCAN_LOGTAG,
                        "EventSendReport - Engine POST failed (code=%ld): %s (body=%s)",
                        code,
                        error.c_str(),
                        body.c_str());
            };

            try
            {
                UNIXSocketRequest::instance().post(requestParams, postParams, config);
                logDebug2(WM_VULNSCAN_LOGTAG, "EventSendReport - Engine POST ok (events=%zu)", eventCount);
            }
            catch (const std::exception& ex)
            {
                logWarn(WM_VULNSCAN_LOGTAG,
                        "EventSendReport - Engine POST failed (exception): %s",
                        ex.what());
            }
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventSendReport = TEventSendReport<>;

#endif // _EVENT_SEND_REPORT_HPP
