/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 8, 2024.
 */

#ifndef _EVENT_SEND_REPORT_HPP
#define _EVENT_SEND_REPORT_HPP

#include "chainOfResponsability.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "vulnerabilityScanner.hpp"

/**
 * @brief Sends vulnerability events to analysisd (engine).
 *
 * Sends:
 *  - INSERT events  -> full ECS JSON
 *  - DELETE events  -> minimal delete event {_id, op=delete, cve, package}
 */
template<typename TScanContext = ScanContext, typename TReportDispatcher = ReportDispatcher>
class TEventSendReport final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TReportDispatcher> m_reportDispatcher;

public:
    explicit TEventSendReport(std::shared_ptr<TReportDispatcher> reportDispatcher)
        : m_reportDispatcher(std::move(reportDispatcher))
    {
    }

    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG,
                  "TEventSendReport - sending %zu detections to analysisd",
                  data->detectedCVEs().size());

        for (const auto& [detectionId, detection] : data->detectedCVEs())
        {
            if (detection.operation == ElementOperation::Upsert)
            {
                crear -> {"index":{"_index":"wazuh-states-inventory-packages","_id":"cluster01_001_"}}

            }




            try
            {
                std::ostringstream oss;

                //
                // ------------------------------------------------------------
                // 1) DELETE EVENT
                // ------------------------------------------------------------
                //
                if (detection.operation == ElementOperation::Delete)
                {
                    nlohmann::json deleteEvent;
                    deleteEvent["_id"] = detectionId;
                    deleteEvent["operation"] = "delete";
                    deleteEvent["agent_id"] = data->agentId();
                    deleteEvent["cve"] = detection.cveId;
                    deleteEvent["component_type"] =
                        (detection.componentType == AffectedComponentType::Os      ? "os" :
                         detection.componentType == AffectedComponentType::Package ? "package" :
                         detection.componentType == AffectedComponentType::Hotfix  ? "hotfix" : "unknown");

                    if (detection.componentType == AffectedComponentType::Package)
                    {
                        deleteEvent["package"]["name"] = detection.packageName;
                        deleteEvent["package"]["version"] = detection.packageVersion;
                    } else if (detection.componentType == AffectedComponentType::Os)
                    {
                        deleteEvent["os"]["name"] = data->osName();
                        deleteEvent["os"]["version"] = data->osVersion();
                    }

                    // MQ format
                    oss << LOCALFILE_MQ << ":"
                        << "[" << data->agentId() << "] (" << data->agentName() << ") "
                        << data->agentIP() << "->vulnerability-detector:"
                        << deleteEvent.dump();

                    m_reportDispatcher->push(oss.str());

                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Vulnerability DELETE event for detection '%s' (CVE %s)",
                              detectionId.c_str(),
                              detection.cveId.c_str());

                    continue; // go to next detection
                }

                //
                // ------------------------------------------------------------
                // 2) INSERT EVENT (default / upsert)
                // ------------------------------------------------------------
                //
                const auto* ecsJsonPtr = data->getECSEvent(detectionId);
                if (!ecsJsonPtr)
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "TEventSendReport - Missing ECS JSON for detection '%s' (CVE %s)",
                            detectionId.c_str(),
                            detection.cveId.c_str());
                    continue;
                }

                const std::string& ecsJson = *ecsJsonPtr;

                oss << LOCALFILE_MQ << ":"
                    << "[" << data->agentId() << "] (" << data->agentName() << ") "
                    << data->agentIP() << "->vulnerability-detector:"
                    << ecsJson;

                m_reportDispatcher->push(oss.str());

                if (data->affectedComponentType() == AffectedComponentType::Package)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Vulnerability INSERT event sent for agent %s (Package CVE: %s)",
                              data->agentId().data(),
                              detection.cveId.c_str());
                }
                else if (data->affectedComponentType() == AffectedComponentType::Os)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Vulnerability INSERT event sent for agent %s (OS: %s, CVE: %s)",
                              data->agentId().data(),
                              data->osName().data(),
                              detection.cveId.c_str());
                }
                else
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "INSERT event sent (unknown component type) for agent %s, CVE: %s",
                            data->agentId().data(),
                            detection.cveId.c_str());
                }
            }
            catch (...)
            {
                logWarn(WM_VULNSCAN_LOGTAG,
                        "Couldn't send vulnerability event for detection '%s'.",
                        detectionId.c_str());
            }
        }

        data->logDebugContext();
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventSendReport = TEventSendReport<>;

#endif // _EVENT_SEND_REPORT_HPP
