/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 8, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General
 * Public License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_SEND_REPORT_HPP
#define _EVENT_SEND_REPORT_HPP

#include "chainOfResponsability.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "vulnerabilityScanner.hpp"
#include <cstdlib>
#include <cstring>
#include <json.hpp>
#include <sstream>
#include <string>
#include <string_view>
#include <vector>

// Forward declarations to avoid including C11 _Atomic types in C++.
extern "C"
{
    struct w_rr_queue;
    typedef struct w_rr_queue w_rr_queue_t;
    int batch_queue_enqueue_ex(w_rr_queue_t* sched, const char* agent_key, void* data) __attribute__((weak));
    extern w_rr_queue_t* events_queue __attribute__((weak));
}

/**
 * @brief Class in charge of sending formatted report messages.
 *
 * This class is responsible for sending the vulnerability events (ECS JSON)
 * to the analysisd queue.
 *
 * It now uses:
 *   - ScanContext::detectedCVEs() to know operation and component type.
 *   - ScanContext::ecsEvents() / getECSEvent() to get the final ECS JSON.
 *
 * To distinguish INSERT vs DELETE operations (because ECS JSON is identical),
 * we encode the operation in the "location" field of the log line:
 *
 *   LOCALFILE_MQ:[id] (name) ip->vulnerability-detector-insert:<json>
 *   LOCALFILE_MQ:[id] (name) ip->vulnerability-detector-delete:<json>
 *
 * So the engine can differentiate them without touching the ECS payload.
 *
 * @tparam TScanContext scan context type.
 * @tparam TReportDispatcher report dispatcher type.
 */
template<typename TScanContext = ScanContext, typename TReportDispatcher = ReportDispatcher>
class TEventSendReport final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TReportDispatcher> m_reportDispatcher;

public:
    // LCOV_EXCL_START
    /**
     * @brief Construct a new Send Report object.
     *
     * @param reportDispatcher Report queue instance (unused, kept for interface compatibility).
     */
    explicit TEventSendReport(std::shared_ptr<TReportDispatcher> reportDispatcher)
        : m_reportDispatcher(std::move(reportDispatcher))
    {
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        const auto& detected = data->detectedCVEs();

        logDebug2(WM_VULNSCAN_LOGTAG,
                  "EventSendReport - Sending %zu detections (ecsEvents=%zu)",
                  detected.size(),
                  data->ecsEventCount());

        for (const auto& [detectionId, detection] : detected)
        {
            try
            {
                // Get ECS JSON previously built by EventDetailsBuilder
                const std::string* ecsJson = data->getECSEvent(detectionId);
                if (!ecsJson)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "EventSendReport - No ECS event found for detection '%s', skipping",
                              detectionId.c_str());
                    continue;
                }

                const char* opSuffix = (detection.operation == ElementOperation::Delete) ? "delete" : "insert";

                // Wrap ECS payload to carry operation alongside the data
                try
                {
                    if (!batch_queue_enqueue_ex || !events_queue)
                    {
                        logWarn(WM_VULNSCAN_LOGTAG,
                                "EventSendReport - batch_queue_enqueue_ex/events_queue unavailable, dropping detection "
                                "'%s'",
                                detectionId.c_str());
                        continue;
                    }

                    nlohmann::json wrapper;
                    wrapper["operation"] = opSuffix;
                    wrapper["data"] = nlohmann::json::parse(*ecsJson);

                    const auto payload = wrapper.dump();
                    const auto agentKey = std::string {data->agentId()};
                    const auto payloadLen = payload.size();

                    // Allocate event item compatible with remoted's dispatcher
                    struct EventItem
                    {
                        char* raw;
                        size_t len;
                    };

                    auto* e = static_cast<EventItem*>(std::calloc(1, sizeof(EventItem)));
                    if (!e)
                    {
                        logWarn(WM_VULNSCAN_LOGTAG,
                                "EventSendReport - Memory allocation failed for detection '%s'",
                                detectionId.c_str());
                        continue;
                    }

                    e->raw = static_cast<char*>(std::calloc(payloadLen, sizeof(char)));
                    if (!e->raw)
                    {
                        std::free(e);
                        logWarn(WM_VULNSCAN_LOGTAG,
                                "EventSendReport - Memory allocation failed (payload) for detection '%s'",
                                detectionId.c_str());
                        continue;
                    }

                    std::memcpy(e->raw, payload.data(), payloadLen);
                    e->len = payloadLen;

                    const int rc = batch_queue_enqueue_ex(events_queue, agentKey.c_str(), e);
                    if (rc < 0)
                    {
                        std::free(e->raw);
                        std::free(e);
                        logWarn(WM_VULNSCAN_LOGTAG,
                                "EventSendReport - Dropping event for agent '%.*s' (detection '%s', rc=%d)",
                                static_cast<int>(agentKey.size()),
                                agentKey.c_str(),
                                detectionId.c_str(),
                                rc);
                        continue;
                    }

                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "EventSendReport - Sent ECS event for detection '%s' (fullMsg=%s)",
                              detectionId.c_str(),
                              payload.c_str());
                }
                catch (const std::exception& ex)
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "EventSendReport - Failed to wrap/send ECS event for detection '%s': %s",
                            detectionId.c_str(),
                            ex.what());
                    continue;
                }
            }
            catch (...)
            {
                logWarn(WM_VULNSCAN_LOGTAG,
                        "EventSendReport - Couldn't send vulnerability JSON report for detection '%s'.",
                        detectionId.c_str());
            }
        }

        // data->logDebugContext();
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventSendReport = TEventSendReport<>;

#endif // _EVENT_SEND_REPORT_HPP
