/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 8, 2024.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_SEND_REPORT_HPP
#define _EVENT_SEND_REPORT_HPP

#include "chainOfResponsability.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "vulnerabilityScanner.hpp"

/**
 * @brief Class in charge of sending vulnerability events to the Wazuh engine.
 *
 * In the refactored VD architecture, this class is responsible for sending the
 * same ECS-compliant vulnerability event that we index (built in EventDetailsBuilder)
 * directly to the analysisd/engine queue.
 *
 * @tparam TScanContext scan context type.
 * @tparam TReportDispatcher report dispatcher type.
 */
template<typename TScanContext = ScanContext, typename TReportDispatcher = ReportDispatcher>
class TEventSendReport final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TReportDispatcher> m_reportDispatcher;

public:
    // LCOV_EXCL_START
    /**
     * @brief Construct a new Send Report object
     *
     * @param reportDispatcher Report queue instance.
     */
    explicit TEventSendReport(std::shared_ptr<TReportDispatcher> reportDispatcher)
        : m_reportDispatcher(std::move(reportDispatcher))
    {
    }
    // LCOV_EXCL_STOP

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * It iterates over ScanContext::ecsEvents(), which contains the serialized
     * ECS vulnerability events built by EventDetailsBuilder, and forwards them
     * to the engine through the report dispatcher.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        // TODO: In the new VD architecture, review that the ECS payload sent here
        //       matches exactly what the Wazuh engine expects as vulnerability
        //       alert input. If a dedicated engine dispatcher is introduced in
        //       the future, this class should be refactored to use that component
        //       instead of the generic ReportDispatcher.

        for (const auto& [cveId, ecsJson] : data->ecsEvents())
        {
            try
            {
                std::ostringstream oss;

                // 1:[001] (agent_name) ip->location:
                oss << LOCALFILE_MQ << ":"
                    << "[" << data->agentId() << "] (" << data->agentName() << ") " << data->agentIP() << "->"
                    << "vulnerability-detector"
                    << ":"
                    // ECS vulnerability event (already serialized JSON)
                    << ecsJson;

                // The report is sent in another thread.
                m_reportDispatcher->push(oss.str());

                if (data->affectedComponentType() == AffectedComponentType::Package)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Vulnerability event sent for agent ID %s (Package CVE: %s)",
                              data->agentId().data(),
                              cveId.c_str());
                }
                else if (data->affectedComponentType() == AffectedComponentType::Os)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Vulnerability event sent for agent ID %s (OS: %s, CVE: %s)",
                              data->agentId().data(),
                              data->osName().data(),
                              cveId.c_str());
                }
                else if (data->affectedComponentType() == AffectedComponentType::Hotfix)
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Vulnerability event sent for agent ID %s (Hotfix CVE: %s)",
                              data->agentId().data(),
                              cveId.c_str());
                }
                else
                {
                    logWarn(WM_VULNSCAN_LOGTAG,
                            "Vulnerability event sent for agent ID %s, CVE: %s (unknown component type).",
                            data->agentId().data(),
                            cveId.c_str());
                }
            }
            catch (...)
            {
                logWarn(WM_VULNSCAN_LOGTAG,
                        "Couldn't send vulnerability ECS event for CVE %s.",
                        cveId.c_str());
            }
        }
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventSendReport = TEventSendReport<>;

#endif // _EVENT_SEND_REPORT_HPP
