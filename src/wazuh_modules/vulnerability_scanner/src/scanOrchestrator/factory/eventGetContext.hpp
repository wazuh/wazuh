/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * November 11, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General
 * Public License (version 2) as published by the FSF - Free
 * Software Foundation.
 */

#ifndef _EVENT_GET_CONTEXT_HPP
#define _EVENT_GET_CONTEXT_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "inventorySyncQueryBuilder.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include "stringHelper.h"
#include <algorithm>
#include <iterator>
#include <memory>
#include <unordered_map>
#include <unordered_set>
#include <vector>

/**
 * @brief EventGetContext class.
 *
 * Full-scan bootstrap for existing vulnerabilities in the indexer.
 *
 * This handler queries wazuh-states-vulnerabilities to fetch ALL existing
 * vulnerabilities for the agent and preloads them into ScanContext as Delete
 * operations. Later the scanners (OS / packages) will remove the ones still
 * present and add Upserts for new findings.
 *
 * @tparam TIndexerConnector indexer connector type.
 * @tparam TScanContext scan context type.
 */
template<typename TIndexerConnector = IndexerConnectorSync, typename TScanContext = ScanContext>
class TEventGetContext final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    static constexpr size_t DEFAULT_PAGE_SIZE = 1000;

    /// @brief Helper to safely extract detectionId (_id) from a search hit.
    static const std::string* getDetectionIdPtr(const nlohmann::json& hit)
    {
        auto idIt = hit.find("_id");
        if (idIt != hit.end() && idIt->is_string())
        {
            return &idIt->get_ref<const std::string&>();
        }
        return nullptr;
    }

    /// @brief Helper to safely extract CVE id (vulnerability.id) from a search hit.
    ///
    /// We assume the query returns _source.vulnerability.id for each hit.
    static const std::string* getCveIdPtr(const nlohmann::json& hit)
    {
        auto srcIt = hit.find("_source");
        if (srcIt == hit.end() || !srcIt->is_object())
        {
            return nullptr;
        }

        const auto& src = *srcIt;
        auto vulnIt = src.find("vulnerability");
        if (vulnIt == src.end() || !vulnIt->is_object())
        {
            return nullptr;
        }

        const auto& vuln = *vulnIt;
        auto idIt = vuln.find("id");
        if (idIt != vuln.end() && idIt->is_string())
        {
            return &idIt->get_ref<const std::string&>();
        }

        return nullptr;
    }

    static PackageContextData parsePackage(const nlohmann::json& hit)
    {
        PackageContextData pkg {};

        auto srcIt = hit.find("_source");
        if (srcIt == hit.end() || !srcIt->is_object())
        {
            return pkg;
        }

        const auto& src = *srcIt;
        auto pkgIt = src.find("package");
        if (pkgIt == src.end() || !pkgIt->is_object())
        {
            return pkg;
        }

        const auto& pkgObj = *pkgIt;

        auto setString = [&](const char* key, std::string& out)
        {
            auto it = pkgObj.find(key);
            if (it != pkgObj.end() && it->is_string())
            {
                out = it->get_ref<const std::string&>();
            }
        };

        setString("name", pkg.name);
        setString("version", pkg.version);
        setString("type", pkg.format);
        setString("source", pkg.source);
        setString("path", pkg.location);
        setString("architecture", pkg.architecture);
        setString("multiarch", pkg.multiarch);
        setString("priority", pkg.priority);
        setString("vendor", pkg.vendor);
        setString("install_scope", pkg.groups);
        setString("description", pkg.description);
        setString("license", pkg.groups); // reuse groups field if present (best effort)

        if (auto it = pkgObj.find("size"); it != pkgObj.end() && it->is_number_integer())
        {
            pkg.size = it->get<uint64_t>();
        }

        return pkg;
    }

    std::unordered_map<std::string, PackageContextData>
    fetchPackagesFromIndexer(const std::string& index, const std::vector<std::string>& detectionIds) const
    {
        std::unordered_map<std::string, PackageContextData> packagesByBase;

        if (detectionIds.empty())
        {
            return packagesByBase;
        }

        try
        {
            const auto query = InventorySyncQueryBuilder::buildVulnerabilityPackagesGetByIdsQuery(detectionIds);
            const auto response = m_indexerConnector->executeSearchQuery(index, query);

            if (!response.contains("hits") || !response["hits"].is_object())
            {
                return packagesByBase;
            }

            const auto& hitsObj = response["hits"];
            if (!hitsObj.contains("hits") || !hitsObj["hits"].is_array())
            {
                return packagesByBase;
            }

            for (const auto& hit : hitsObj["hits"])
            {
                const std::string* detectionIdPtr = getDetectionIdPtr(hit);
                if (!detectionIdPtr)
                {
                    continue;
                }

                const auto detectionIdBase = TScanContext::detectionIdBaseFromDetection(*detectionIdPtr);
                if (packagesByBase.contains(detectionIdBase))
                {
                    continue;
                }

                auto pkg = parsePackage(hit);
                if (pkg.name.empty())
                {
                    continue;
                }

                packagesByBase.emplace(detectionIdBase, std::move(pkg));
            }
        }
        catch (const std::exception& e)
        {
            logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetContext - Failed to batch fetch packages: %s", e.what());
        }

        return packagesByBase;
    }

public:
    /**
     * @brief EventGetContext constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    explicit TEventGetContext(std::shared_ptr<TIndexerConnector> indexerConnector)
        : m_indexerConnector(std::move(indexerConnector))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * For the current agent, fetch all vulnerabilities from wazuh-states-vulnerabilities
     * and load them into ScanContext as Delete operations (detectionId + cveId). Scanners
     * will later remove the ones still present and add new ones as Upserts.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Scan context passed to next handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetContext - Starting full-scan reconciliation against indexer");

        try
        {
            const std::string index = "wazuh-states-vulnerabilities";
            const std::string agentId = std::string(data->agentId());

            if (data->hasDeletedOSItemId() && !data->osName().empty())
            {
                std::string osPlatform = std::string {data->osPlatform()};
                osPlatform = Utils::toLowerCase(osPlatform);

                std::string osType;
                if (!data->agentHostOsType().empty())
                {
                    osType = std::string {data->agentHostOsType()};
                }
                else if (!data->osKernelSysName().empty())
                {
                    osType = std::string {data->osKernelSysName()};
                }
                else
                {
                    osType = (osPlatform == "darwin") ? "macos" : osPlatform;
                }
                osType = Utils::toLowerCase(osType);

                const auto updateQuery = InventorySyncQueryBuilder::buildVulnerabilitiesHostOsUpdateQuery(
                    agentId,
                    std::string {data->osName()},
                    osPlatform,
                    osType,
                    data->buildOSVersion(),
                    data->buildOSFullName(),
                    std::string {data->osKernelRelease()});

                m_indexerConnector->executeUpdateByQuery({index}, updateQuery);

                logDebug2(WM_VULNSCAN_LOGTAG,
                          "TEventGetContext - Updated host.os metadata in '%s' for agent '%s'",
                          index.c_str(),
                          agentId.c_str());
            }

            int totalExistingInIndexer = 0;
            int scheduledDeletes = 0;
            std::unordered_set<std::string> packageContextChecked;
            std::unordered_map<std::string, std::vector<std::string>> pendingDetectionsByBase;
            std::unordered_map<std::string, std::string> fetchIdByBase;

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetContext - Building vulnerabilities GET query for agent '%s'",
                      agentId.c_str());

            // Query all vulnerabilities for this agent, ordered by _id (pagination handled by connector).
            auto query = InventorySyncQueryBuilder::buildContextGetQuery(agentId,
                                                                         DEFAULT_PAGE_SIZE,
                                                                         ""); // first page, no search_after

            m_indexerConnector->executeSearchQueryWithPagination(
                index,
                query,
                [data,
                 &totalExistingInIndexer,
                 &scheduledDeletes,
                 &packageContextChecked,
                 &pendingDetectionsByBase,
                 &fetchIdByBase,
                 this,
                 &index](const nlohmann::json& response) mutable
                {
                    std::size_t pageHits = 0;

                    if (!response.contains("hits") || !response["hits"].is_object())
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - Response without 'hits' object, skipping page");
                        return;
                    }

                    const auto& hitsObj = response["hits"];
                    auto hitsIt = hitsObj.find("hits");
                    if (hitsIt == hitsObj.end() || !hitsIt->is_array())
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - 'hits.hits' missing or not an array, skipping page");
                        return;
                    }

                    const auto& hits = *hitsIt;
                    pageHits = hits.size();

                    for (const auto& hit : hits)
                    {
                        const std::string* detectionIdPtr = getDetectionIdPtr(hit);
                        const std::string* cveIdPtr = getCveIdPtr(hit);

                        if (!detectionIdPtr || !cveIdPtr)
                        {
                            continue;
                        }

                        const std::string detectionId = *detectionIdPtr;
                        const std::string cveId = *cveIdPtr;
                        const std::string detectionIdBase = TScanContext::detectionIdBaseFromDetection(detectionId);
                        bool hasPackageContext = (data->findPackageByDetectionBase(detectionIdBase) != nullptr);

                        if (!hasPackageContext)
                        {
                            pendingDetectionsByBase[detectionIdBase].push_back(detectionId);

                            if (!packageContextChecked.contains(detectionIdBase))
                            {
                                packageContextChecked.insert(detectionIdBase);
                                fetchIdByBase.emplace(detectionIdBase, detectionId);
                            }
                        }

                        ++totalExistingInIndexer;
                        // Preload as DELETE. Scanners will remove entries that remain present.
                        CVEDetectionResult det;
                        det.operation = ElementOperation::Delete;
                        det.cveId = cveId;
                        det.detectionIdBase = detectionIdBase;
                        det.componentType =
                            hasPackageContext ? AffectedComponentType::Package : AffectedComponentType::Os;

                        data->addDetectedCVE(detectionId, std::move(det));
                        ++scheduledDeletes;

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - Detection '%s' (CVE '%s') "
                                  "Scheduling DELETE operation.",
                                  detectionId.c_str(),
                                  cveId.c_str());
                    }

                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "TEventGetContext - Processed page: %zu hits, cumulative existing: %d, "
                              "deletes scheduled: %d",
                              pageHits,
                              totalExistingInIndexer,
                              scheduledDeletes);
                });

            if (!fetchIdByBase.empty())
            {
                std::vector<std::string> detectionIds;
                detectionIds.reserve(fetchIdByBase.size());
                std::transform(fetchIdByBase.begin(),
                               fetchIdByBase.end(),
                               std::back_inserter(detectionIds),
                               [](const auto& item) { return item.second; });

                const auto packagesByBase = fetchPackagesFromIndexer(index, detectionIds);

                for (const auto& [baseId, pkg] : packagesByBase)
                {
                    if (pkg.name.empty())
                    {
                        continue;
                    }

                    if (!data->findPackageByDetectionBase(baseId))
                    {
                        auto pkgCopy = pkg;
                        pkgCopy.operation = ElementOperation::Delete;
                        data->addPackageToContext(baseId, std::move(pkgCopy), ElementOperation::Delete);

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - Registered DELETE package context '%s' (%s) for base '%s'",
                                  pkg.name.c_str(),
                                  pkg.version.c_str(),
                                  baseId.c_str());
                    }

                    const auto pendingIt = pendingDetectionsByBase.find(baseId);
                    if (pendingIt != pendingDetectionsByBase.end())
                    {
                        for (const auto& detId : pendingIt->second)
                        {
                            if (auto det = data->getCVE(detId); det != nullptr)
                            {
                                det->componentType = AffectedComponentType::Package;
                            }
                        }
                    }
                }
            }

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetContext - Completed reconciliation for agent '%s'. "
                      "Existing in indexer: %d, deletes scheduled: %d, remaining detections in context: %zu",
                      agentId.c_str(),
                      totalExistingInIndexer,
                      scheduledDeletes,
                      data->cveCount());
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG,
                     "TEventGetContext - Failed to execute vulnerabilities reconciliation query: %s",
                     e.what());
            // Continue with the chain even if the query fails.
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventGetContext = TEventGetContext<>;

#endif // _EVENT_GET_CONTEXT_HPP
