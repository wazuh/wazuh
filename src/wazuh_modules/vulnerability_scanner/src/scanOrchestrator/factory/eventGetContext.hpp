/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * November 11, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General
 * Public License (version 2) as published by the FSF - Free
 * Software Foundation.
 */

#ifndef _EVENT_GET_CONTEXT_HPP
#define _EVENT_GET_CONTEXT_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "scanContext.hpp"
#include "wazuh_modules/inventory_sync/src/inventorySyncQueryBuilder.hpp"
#include <memory>
#include <unordered_set>

/**
 * @brief EventGetContext class.
 *
 * Full-scan bootstrap for existing vulnerabilities in the indexer.
 *
 * This handler queries wazuh-states-vulnerabilities to fetch ALL existing
 * vulnerabilities for the agent and preloads them into ScanContext as Delete
 * operations. Later the scanners (OS / packages) will remove the ones still
 * present and add Upserts for new findings.
 *
 * @tparam TIndexerConnector indexer connector type.
 * @tparam TScanContext scan context type.
 */
template<typename TIndexerConnector = IndexerConnectorSync, typename TScanContext = ScanContext>
class TEventGetContext final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    static constexpr size_t DEFAULT_PAGE_SIZE = 1000;

    /// @brief Helper to safely extract detectionId (_id) from a search hit.
    static const std::string* getDetectionIdPtr(const nlohmann::json& hit)
    {
        auto idIt = hit.find("_id");
        if (idIt != hit.end() && idIt->is_string())
        {
            return &idIt->get_ref<const std::string&>();
        }
        return nullptr;
    }

    /// @brief Helper to safely extract CVE id (vulnerability.id) from a search hit.
    ///
    /// We assume the query returns _source.vulnerability.id for each hit.
    static const std::string* getCveIdPtr(const nlohmann::json& hit)
    {
        auto srcIt = hit.find("_source");
        if (srcIt == hit.end() || !srcIt->is_object())
        {
            return nullptr;
        }

        const auto& src = *srcIt;
        auto vulnIt = src.find("vulnerability");
        if (vulnIt == src.end() || !vulnIt->is_object())
        {
            return nullptr;
        }

        const auto& vuln = *vulnIt;
        auto idIt = vuln.find("id");
        if (idIt != vuln.end() && idIt->is_string())
        {
            return &idIt->get_ref<const std::string&>();
        }

        return nullptr;
    }

    static PackageContextData parsePackage(const nlohmann::json& hit)
    {
        PackageContextData pkg {};

        auto srcIt = hit.find("_source");
        if (srcIt == hit.end() || !srcIt->is_object())
        {
            return pkg;
        }

        const auto& src = *srcIt;
        auto pkgIt = src.find("package");
        if (pkgIt == src.end() || !pkgIt->is_object())
        {
            return pkg;
        }

        const auto& pkgObj = *pkgIt;

        auto setString = [&](const char* key, std::string& out)
        {
            auto it = pkgObj.find(key);
            if (it != pkgObj.end() && it->is_string())
            {
                out = it->get_ref<const std::string&>();
            }
        };

        setString("name", pkg.name);
        setString("version", pkg.version);
        setString("type", pkg.format);
        setString("source", pkg.source);
        setString("path", pkg.location);
        setString("architecture", pkg.architecture);
        setString("multiarch", pkg.multiarch);
        setString("priority", pkg.priority);
        setString("vendor", pkg.vendor);
        setString("install_scope", pkg.groups);
        setString("description", pkg.description);
        setString("license", pkg.groups); // reuse groups field if present (best effort)

        if (auto it = pkgObj.find("size"); it != pkgObj.end() && it->is_number_integer())
        {
            pkg.size = it->get<uint64_t>();
        }

        return pkg;
    }

    PackageContextData fetchPackageFromIndexer(const std::string& index, const std::string& detectionId) const
    {
        PackageContextData pkg {};

        try
        {
            const auto query = InventorySyncQueryBuilder::buildVulnerabilityPackageGetByIdQuery(detectionId);
            const auto response = m_indexerConnector->executeSearchQuery(index, query);

            if (!response.contains("hits") || !response["hits"].is_object())
            {
                return pkg;
            }

            const auto& hitsObj = response["hits"];
            if (!hitsObj.contains("hits") || !hitsObj["hits"].is_array() || hitsObj["hits"].empty())
            {
                return pkg;
            }

            const auto& hit = hitsObj["hits"][0];
            pkg = parsePackage(hit);
        }
        catch (const std::exception& e)
        {
            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetContext - Failed to fetch package for detection '%s': %s",
                      detectionId.c_str(),
                      e.what());
        }

        return pkg;
    }

public:
    /**
     * @brief EventGetContext constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    explicit TEventGetContext(std::shared_ptr<TIndexerConnector> indexerConnector)
        : m_indexerConnector(std::move(indexerConnector))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * For the current agent, fetch all vulnerabilities from wazuh-states-vulnerabilities
     * and load them into ScanContext as Delete operations (detectionId + cveId). Scanners
     * will later remove the ones still present and add new ones as Upserts.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Scan context passed to next handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetContext - Starting full-scan reconciliation against indexer");

        try
        {
            const std::string index = "wazuh-states-vulnerabilities";
            const std::string agentId = std::string(data->agentId());

            int totalExistingInIndexer = 0;
            int scheduledDeletes = 0;
            std::unordered_set<std::string> packageContextChecked;

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetContext - Building vulnerabilities GET query for agent '%s'",
                      agentId.c_str());

            // Query all vulnerabilities for this agent, ordered by _id (pagination handled by connector).
            auto query = InventorySyncQueryBuilder::buildContextGetQuery(agentId,
                                                                         DEFAULT_PAGE_SIZE,
                                                                         ""); // first page, no search_after

            m_indexerConnector->executeSearchQueryWithPagination(
                index,
                query,
                [data, &totalExistingInIndexer, &scheduledDeletes, &packageContextChecked, this, &index](
                    const nlohmann::json& response) mutable
                {
                    std::size_t pageHits = 0;

                    if (!response.contains("hits") || !response["hits"].is_object())
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - Response without 'hits' object, skipping page");
                        return;
                    }

                    const auto& hitsObj = response["hits"];
                    auto hitsIt = hitsObj.find("hits");
                    if (hitsIt == hitsObj.end() || !hitsIt->is_array())
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - 'hits.hits' missing or not an array, skipping page");
                        return;
                    }

                    const auto& hits = *hitsIt;
                    pageHits = hits.size();

                    for (const auto& hit : hits)
                    {
                        const std::string* detectionIdPtr = getDetectionIdPtr(hit);
                        const std::string* cveIdPtr = getCveIdPtr(hit);

                        if (!detectionIdPtr || !cveIdPtr)
                        {
                            continue;
                        }

                        const std::string detectionId = *detectionIdPtr;
                        const std::string cveId = *cveIdPtr;
                        const std::string detectionIdBase = TScanContext::detectionIdBaseFromDetection(detectionId);
                        bool hasPackageContext = (data->findPackageByDetectionBase(detectionIdBase) != nullptr);
                        PackageContextData pkg;

                        if (!hasPackageContext && !packageContextChecked.contains(detectionIdBase))
                        {
                            packageContextChecked.insert(detectionIdBase);
                            pkg = fetchPackageFromIndexer(index, detectionId);
                            if (!pkg.name.empty())
                            {
                                hasPackageContext = true;
                            }
                        }

                        ++totalExistingInIndexer;
                        // Preload as DELETE. Scanners will remove entries that remain present.
                        CVEDetectionResult det;
                        det.operation = ElementOperation::Delete;
                        det.cveId = cveId;
                        det.detectionIdBase = detectionIdBase;
                        det.componentType =
                            hasPackageContext ? AffectedComponentType::Package : AffectedComponentType::Os;

                        data->addDetectedCVE(detectionId, std::move(det));
                        ++scheduledDeletes;

                        // Also preload package context if not already present
                        if (hasPackageContext && !pkg.name.empty())
                        {
                            if (!data->findPackageByDetectionBase(detectionIdBase))
                            {
                                auto pkgCopy = pkg;
                                pkgCopy.operation = ElementOperation::Delete;
                                data->addPackageToContext(
                                    detectionIdBase, std::move(pkgCopy), ElementOperation::Delete);

                                logDebug2(
                                    WM_VULNSCAN_LOGTAG,
                                    "TEventGetContext - Registered DELETE package context '%s' (v.%s) for base '%s'",
                                    pkg.name.c_str(),
                                    pkg.version.c_str(),
                                    detectionIdBase.c_str());
                            }
                        }

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - Detection '%s' (CVE '%s') "
                                  "Scheduling DELETE operation.",
                                  detectionId.c_str(),
                                  cveId.c_str());
                    }

                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "TEventGetContext - Processed page: %zu hits, cumulative existing: %d, "
                              "deletes scheduled: %d",
                              pageHits,
                              totalExistingInIndexer,
                              scheduledDeletes);
                });

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetContext - Completed reconciliation for agent '%s'. "
                      "Existing in indexer: %d, deletes scheduled: %d, remaining detections in context: %zu",
                      agentId.c_str(),
                      totalExistingInIndexer,
                      scheduledDeletes,
                      data->cveCount());
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG,
                     "TEventGetContext - Failed to execute vulnerabilities reconciliation query: %s",
                     e.what());
            // Continue with the chain even if the query fails.
        }

        // data->logDebugContext();
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventGetContext = TEventGetContext<>;

#endif // _EVENT_GET_CONTEXT_HPP
