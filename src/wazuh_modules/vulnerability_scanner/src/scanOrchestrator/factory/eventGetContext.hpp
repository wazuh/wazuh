/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * November 11, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General
 * Public License (version 2) as published by the FSF - Free
 * Software Foundation.
 */

#ifndef _EVENT_GET_CONTEXT_HPP
#define _EVENT_GET_CONTEXT_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "scanContext.hpp"
#include "wazuh_modules/inventory_sync/src/inventorySyncQueryBuilder.hpp"
#include <memory>

/**
 * @brief EventGetContext class.
 *
 * Full-scan reconciliation handler for existing vulnerabilities in the indexer.
 *
 * This handler queries the wazuh-states-vulnerabilities index for all
 * vulnerability documents of a given agent and reconciles them with the
 * in-memory detections already present in the ScanContext:
 *
 * - If a hit _id (detectionId) exists in ScanContext::detectedCVEs(), it means
 *   the vulnerability is still present and already accounted for in the current
 *   scan → remove that detection from the context (no upsert / no alert needed).
 *
 * - If a hit _id does NOT exist in ScanContext::detectedCVEs(), it means the
 *   vulnerability has disappeared in this full scan → schedule a DELETE
 *   operation by adding a CVEDetectionResult with operation = Delete and
 *   vulnerability.id = <CVE_ID>.
 *
 * @tparam TIndexerConnector indexer connector type.
 * @tparam TScanContext scan context type.
 */
template<typename TIndexerConnector = IndexerConnectorSync, typename TScanContext = ScanContext>
class TEventGetContext final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    static constexpr size_t DEFAULT_PAGE_SIZE = 1000;

    /// @brief Helper to safely extract detectionId (_id) from a search hit.
    static const std::string* getDetectionIdPtr(const nlohmann::json& hit)
    {
        auto idIt = hit.find("_id");
        if (idIt != hit.end() && idIt->is_string())
        {
            return &idIt->get_ref<const std::string&>();
        }
        return nullptr;
    }

    /// @brief Helper to safely extract CVE id (vulnerability.id) from a search hit.
    ///
    /// We assume the query returns _source.vulnerability.id for each hit.
    static const std::string* getCveIdPtr(const nlohmann::json& hit)
    {
        auto srcIt = hit.find("_source");
        if (srcIt == hit.end() || !srcIt->is_object())
        {
            return nullptr;
        }

        const auto& src = *srcIt;
        auto        vulnIt = src.find("vulnerability");
        if (vulnIt == src.end() || !vulnIt->is_object())
        {
            return nullptr;
        }

        const auto& vuln = *vulnIt;
        auto        idIt = vuln.find("id");
        if (idIt != vuln.end() && idIt->is_string())
        {
            return &idIt->get_ref<const std::string&>();
        }

        return nullptr;
    }

public:
    /**
     * @brief EventGetContext constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    explicit TEventGetContext(std::shared_ptr<TIndexerConnector> indexerConnector)
        : m_indexerConnector(std::move(indexerConnector))
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * For the current agent, fetches all vulnerability documents from
     * wazuh-states-vulnerabilities and reconciles them with ScanContext:
     *
     * - Existing in both indexer and ScanContext → removed from ScanContext
     *   (no change, no re-index, no alert).
     *
     * - Existing only in indexer → added to ScanContext as DELETE operations,
     *   storing only detectionId and vulnerability.id.
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Scan context passed to next handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetContext - Starting full-scan reconciliation against indexer");

        try
        {
            const std::string index   = "wazuh-states-vulnerabilities";
            const std::string agentId = std::string(data->agentId());

            int totalExistingInIndexer  = 0;
            int unchangedRemovedFromCtx = 0;
            int scheduledDeletes        = 0;

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetContext - Building vulnerabilities GET query for agent '%s'",
                      agentId.c_str());

            // Query all vulnerabilities for this agent, ordered by _id (pagination handled by connector).
            auto query = InventorySyncQueryBuilder::buildContextGetQuery(agentId,
                                                                         DEFAULT_PAGE_SIZE,
                                                                         ""); // first page, no search_after

            m_indexerConnector->executeSearchQueryWithPagination(
                index,
                query,
                [data,
                 &totalExistingInIndexer,
                 &unchangedRemovedFromCtx,
                 &scheduledDeletes](const nlohmann::json& response) mutable
                {
                    std::size_t pageHits = 0;

                    if (!response.contains("hits") || !response["hits"].is_object())
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - Response without 'hits' object, skipping page");
                        return;
                    }

                    const auto& hitsObj = response["hits"];
                    auto        hitsIt  = hitsObj.find("hits");
                    if (hitsIt == hitsObj.end() || !hitsIt->is_array())
                    {
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - 'hits.hits' missing or not an array, skipping page");
                        return;
                    }

                    const auto& hits = *hitsIt;
                    pageHits         = hits.size();

                    for (const auto& hit : hits)
                    {
                        const std::string* detectionIdPtr = getDetectionIdPtr(hit);
                        const std::string* cveIdPtr       = getCveIdPtr(hit);

                        if (!detectionIdPtr || !cveIdPtr)
                        {
                            continue;
                        }

                        const std::string detectionId = *detectionIdPtr;
                        const std::string cveId       = *cveIdPtr;

                        ++totalExistingInIndexer;

                        // Case 1: Detection already present in ScanContext → unchanged, drop it.
                        if (data->hasCVE(detectionId))
                        {
                            data->removeCVE(detectionId);
                            ++unchangedRemovedFromCtx;

                            logDebug2(WM_VULNSCAN_LOGTAG,
                                      "TEventGetContext - Detection '%s' already present in ScanContext. "
                                      "Marking as unchanged and removing from in-memory detections.",
                                      detectionId.c_str());
                            continue;
                        }

                        // Case 2: Detection only in indexer → vulnerability solved, schedule DELETE.
                        CVEDetectionResult det;
                        det.operation        = ElementOperation::Delete;
                        det.vulnerability.id = cveId;

                        data->addDetectedCVE(detectionId, std::move(det));
                        ++scheduledDeletes;

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - Detection '%s' (CVE '%s') not found in ScanContext. "
                                  "Scheduling DELETE operation.",
                                  detectionId.c_str(),
                                  cveId.c_str());
                    }

                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "TEventGetContext - Processed page: %zu hits, cumulative existing: %d, "
                              "unchanged removed: %d, deletes scheduled: %d",
                              pageHits,
                              totalExistingInIndexer,
                              unchangedRemovedFromCtx,
                              scheduledDeletes);
                });

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetContext - Completed reconciliation for agent '%s'. "
                      "Existing in indexer: %d, unchanged removed from context: %d, "
                      "deletes scheduled: %d, remaining detections in context: %zu",
                      agentId.c_str(),
                      totalExistingInIndexer,
                      unchangedRemovedFromCtx,
                      scheduledDeletes,
                      data->cveCount());
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG,
                     "TEventGetContext - Failed to execute vulnerabilities reconciliation query: %s",
                     e.what());
            // Continue with the chain even if the query fails.
        }

        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetContext::handleRequest - Passing to next handler in chain");
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventGetContext = TEventGetContext<>;

#endif // _EVENT_GET_CONTEXT_HPP
