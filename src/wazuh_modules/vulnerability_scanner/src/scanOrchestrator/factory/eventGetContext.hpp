/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * November 11, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_GET_CONTEXT_HPP
#define _EVENT_GET_CONTEXT_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "scanContext.hpp"
#include "wazuh_modules/inventory_sync/src/inventorySyncQueryBuilder.hpp"
#include <memory>

/**
 * @brief EventGetContext class.
 *
 * This handler queries the indexer for system inventory context information.
 * It executes a GET query to retrieve context data from inventory indices.
 *
 * @tparam TIndexerConnector indexer connector type.
 * @tparam TScanContext scan context type.
 */
template<typename TIndexerConnector = IndexerConnectorSync, typename TScanContext = ScanContext>
class TEventGetContext final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    static constexpr size_t DEFAULT_PAGE_SIZE = 1000;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * Executes a GET query to the indexer to retrieve system inventory context data
     * across multiple indices:
     * - wazuh-states-inventory-system
     * - wazuh-states-inventory-packages
     * - wazuh-states-inventory-hotfixes
     * - wazuh-states-vulnerabilities
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Scan context passed to next handler.
     */
    // Helper to safely extract _id from a hit
    static const std::string* getContextIdPtr(const nlohmann::json& hit)
    {
        if (const auto* idPtr = hit.find("_id"); idPtr != hit.end() && idPtr->is_string())
        {
            return &idPtr->get_ref<const std::string&>();
        }
        return nullptr;
    }

public:
    /**
     * @brief EventGetContext constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    explicit TEventGetContext(std::shared_ptr<TIndexerConnector> indexerConnector)
        : m_indexerConnector(std::move(indexerConnector))
    {
    }

    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetContext - Starting GET context query handler");

        try
        {
            // Define the indices to query
            const std::vector<std::string> indexes = {"wazuh-states-inventory-system",
                                                      "wazuh-states-inventory-packages",
                                                      "wazuh-states-inventory-hotfixes",
                                                      "wazuh-states-vulnerabilities"};

            int totalContextItems = 0;

            logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetContext - Building context query");

            // Build query without search_after - pagination is now automatic
            auto query = InventorySyncQueryBuilder::buildContextGetQuery(std::string(data->agentId()),
                                                                         DEFAULT_PAGE_SIZE,
                                                                         ""); // Empty search_after - first page

            // Execute query for each index separately
            for (const auto& index : indexes)
            {
                m_indexerConnector->executeSearchQueryWithPagination(
                    index,
                    query,
                    [&totalContextItems, data](const nlohmann::json& response) mutable
                    {
                        std::size_t pageHits = 0;
                        std::size_t storedItems = 0;
                        if (const auto* hitsPtr = response["hits"].find("hits");
                            hitsPtr != response["hits"].end() && hitsPtr->is_array())
                        {
                            const auto& hits = *hitsPtr;
                            pageHits = hits.size();
                            // Process each context item hit
                            for (const auto& hit : hits)
                            {
                                const auto* idPtr = getContextIdPtr(hit);
                                const auto* srcPtr = hit.find("_source");
                                const auto* idxPtr = hit.find("_index");
                                if (idPtr && srcPtr != hit.end() && srcPtr->is_object() && idxPtr != hit.end() &&
                                    idxPtr->is_string())
                                {
                                    data->m_elements[*idPtr] = *srcPtr;
                                    totalContextItems++;
                                    storedItems++;
                                    logDebug2(WM_VULNSCAN_LOGTAG,
                                              "TEventGetContext - Stored context item from index: %s, id: %s",
                                              idxPtr->get_ref<const std::string&>().c_str(),
                                              idPtr->c_str());
                                }
                            }
                        }
                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetContext - Processing page: %zu hits, %zu context items stored",
                                  pageHits,
                                  storedItems);
                    });
            }

            logDebug2(
                WM_VULNSCAN_LOGTAG, "TEventGetContext - Completed. Total context items stored: %d", totalContextItems);
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "TEventGetContext - Failed to execute GET context query: %s", e.what());
            // Continue with the chain even if the query fails
        }

        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetContext::handleRequest - Passing to next handler in chain");
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventGetContext = TEventGetContext<>;

#endif // _EVENT_GET_CONTEXT_HPP
