/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * November 7, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General
 * Public License (version 2) as published by the FSF - Free
 * Software Foundation.
 */

#ifndef _EVENT_GET_CVE_HPP
#define _EVENT_GET_CVE_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "inventorySyncQueryBuilder.hpp"
#include "loggerHelper.h"
#include "scanContext.hpp"
#include <memory>

/**
 * @brief EventGetCve class.
 *
 * This handler queries the indexer for existing CVEs/vulnerabilities by package information.
 * It executes GET queries to retrieve vulnerability documents from the indexer based on
 * deleted package information and populates CVEDetectionResult entries with:
 *
 *   - operation = Delete
 *   - componentType = Package
 *   - package      = PackageContextData of the deleted package
 *   - cveId        = vulnerability.id returned by the index
 *
 * The rest of the fields in vulnerability.* can be completed in later steps if needed.
 *
 * @tparam TIndexerConnector indexer connector type.
 * @tparam TScanContext scan context type.
 */
template<typename TIndexerConnector = IndexerConnectorSync, typename TScanContext = ScanContext>
class TEventGetCve final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    static constexpr size_t PAGE_SIZE = 1000;

    /**
     * @brief Helper to safely extract CVE id from a hit.
     *
     * {
     *   "_id": "...",
     *   "_source": {
     *     "vulnerability": {
     *       "id": "CVE-2024-1234",
     *       ...
     *     }
     *   }
     * }
     */
    static const std::string* getCveIdPtr(const nlohmann::json& hit)
    {
        if (auto srcIt = hit.find("_source"); srcIt != hit.end() && srcIt->is_object())
        {
            const auto& src = srcIt.value();

            if (auto vulnIt = src.find("vulnerability"); vulnIt != src.end() && vulnIt->is_object())
            {
                const auto& vuln = vulnIt.value();

                if (auto idIt = vuln.find("id"); idIt != vuln.end() && idIt->is_string())
                {
                    return &idIt->get_ref<const std::string&>();
                }
            }
        }

        return nullptr;
    }

public:
    /**
     * @brief EventGetCve constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    explicit TEventGetCve(std::shared_ptr<TIndexerConnector> indexerConnector)
        : m_indexerConnector(std::move(indexerConnector))
    {
    }

    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetCve - Starting GET CVE query handler");

        try
        {
            const std::string indexName = "wazuh-states-vulnerabilities";
            int totalDetections = 0;

            const std::string agentId {data->agentId()};

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetCve - Processing %zu packages for potential deletions",
                      data->packageCount());

            size_t indexCounter = 0;
            for (const auto& entry : data->packages())
            {
                const auto& pkgCtx = entry.second;
                const auto op = pkgCtx.operation;
                ++indexCounter;

                if (op != ElementOperation::Delete)
                {
                    continue;
                }

                if (pkgCtx.name.empty() || pkgCtx.version.empty())
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "TEventGetCve - Package [%zu] marked DELETE but missing name/version (skipping)",
                              indexCounter - 1);
                    continue;
                }

                logDebug2(WM_VULNSCAN_LOGTAG,
                          "TEventGetCve - Building CVE GET query for deleted package '%s' (%s) on agent '%s'",
                          pkgCtx.name.c_str(),
                          pkgCtx.version.c_str(),
                          agentId.c_str());

                // Note: PackageContextData uses 'location' and 'format',
                // which map to package.path and package.type in the index.
                auto query = InventorySyncQueryBuilder::buildCveGetQuery(
                    agentId, pkgCtx.name, pkgCtx.version, pkgCtx.location, pkgCtx.format, PAGE_SIZE, "");

                logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetCve - Query string '%s'", query.dump().c_str());

                const PackageContextData pkgCopy = pkgCtx;
                int pkgDetections = 0;

                m_indexerConnector->executeSearchQueryWithPagination(
                    indexName,
                    query,
                    [data, &totalDetections, &pkgDetections, pkgCopy](const nlohmann::json& response) mutable
                    {
                        std::size_t pageHits = 0;
                        std::size_t storedCves = 0;

                        if (!response.contains("hits") || !response["hits"].is_object())
                        {
                            return;
                        }

                        const auto& hitsObj = response["hits"];
                        if (!hitsObj.contains("hits") || !hitsObj["hits"].is_array())
                        {
                            return;
                        }

                        const auto& hits = hitsObj["hits"];
                        pageHits = hits.size();

                        for (const auto& hit : hits)
                        {
                            // detectionId = _id of the document
                            if (!hit.contains("_id") || !hit["_id"].is_string())
                            {
                                continue;
                            }

                            const std::string detectionId = hit["_id"].get<std::string>();

                            // Extract the cveId from _source.vulnerability.id
                            const std::string* cveIdPtr = getCveIdPtr(hit);
                            if (!cveIdPtr)
                            {
                                logDebug2(WM_VULNSCAN_LOGTAG,
                                          "TEventGetCve - Hit without vulnerability.id for detectionId '%s', skipping",
                                          detectionId.c_str());
                                continue;
                            }

                            // Avoid duplicates.
                            if (data->hasCVE(detectionId))
                            {
                                logDebug2(WM_VULNSCAN_LOGTAG,
                                          "TEventGetCve - Detection '%s' already present, skipping",
                                          detectionId.c_str());
                                continue;
                            }

                            // Create minimal CVEDetectionResult for DELETE
                            CVEDetectionResult det {};
                            det.cveId = *cveIdPtr; // CVE-XXXX
                            det.cnaSource = "";    // We donâ€™t need a CNA for deletion.
                            det.matchCondition = "";
                            det.conditionType = MatchRuleCondition::Unknown;
                            det.componentType = AffectedComponentType::Package;
                            det.feedOffset = "";
                            det.operation = ElementOperation::Delete;
                            det.detectionIdBase = TScanContext::detectionIdBaseFromDetection(detectionId);
                            data->addDetectedCVE(detectionId, std::move(det));

                            ++totalDetections;
                            ++pkgDetections;
                            ++storedCves;

                            logDebug2(WM_VULNSCAN_LOGTAG,
                                      "TEventGetCve - Registered DELETE operation for CVE '%s' "
                                      "(detectionId='%s', package='%s')",
                                      cveIdPtr->c_str(),
                                      detectionId.c_str(),
                                      pkgCopy.name.c_str());
                        }

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetCve - Page processed for package '%s': %zu hits, %zu detections registered",
                                  pkgCopy.name.c_str(),
                                  pageHits,
                                  storedCves);
                    });

                logDebug2(WM_VULNSCAN_LOGTAG,
                          "TEventGetCve - Completed CVE lookup for deleted package '%s' (%s). "
                          "Total detections for this package: %d",
                          pkgCtx.name.c_str(),
                          pkgCtx.version.c_str(),
                          pkgDetections);
            }

            logDebug2(
                WM_VULNSCAN_LOGTAG, "TEventGetCve - Completed. Total CVEs scheduled for deletion: %d", totalDetections);
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "TEventGetCve - Failed to execute GET CVE queries: %s", e.what());
            // We continue the chain even if this step fails.
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventGetCve = TEventGetCve<>;

#endif // _EVENT_GET_CVE_HPP
