/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * November 7, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_GET_CVE_HPP
#define _EVENT_GET_CVE_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "scanContext.hpp"
#include "wazuh_modules/inventory_sync/src/inventorySyncQueryBuilder.hpp"
#include <memory>

/**
 * @brief EventGetCve class.
 *
 * This handler queries the indexer for existing CVEs/vulnerabilities by package information.
 * It executes a GET query to retrieve vulnerability data from the indexer based on
 * package name and version.
 *
 * @tparam TIndexerConnector indexer connector type.
 * @tparam TScanContext scan context type.
 */
template<typename TIndexerConnector = IndexerConnectorSync, typename TScanContext = ScanContext>
class TEventGetCve final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    static constexpr size_t DEFAULT_PAGE_SIZE = 1000;

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * Executes a GET query to the indexer to retrieve existing CVE/vulnerability data
     * based on package information (agent.id, package.name, package.version).
     *
     * @param data Scan context.
     * @return std::shared_ptr<TScanContext> Scan context passed to next handler.
     */
    // Helper to safely extract CVE id from a hit
    static const std::string* getCveIdPtr(const nlohmann::json& hit)
    {
        if (const auto* srcPtr = hit.find("_source"); srcPtr != hit.end() && srcPtr->is_object())
        {
            const auto& src = *srcPtr;
            if (const auto* vulnPtr = src.find("vulnerability"); vulnPtr != src.end() && vulnPtr->is_object())
            {
                const auto& vuln = *vulnPtr;
                if (const auto* idPtr = vuln.find("id"); idPtr != vuln.end() && idPtr->is_string())
                {
                    return &idPtr->get_ref<const std::string&>();
                }
            }
        }
        return nullptr;
    }

public:
    /**
     * @brief EventGetCve constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    explicit TEventGetCve(std::shared_ptr<TIndexerConnector> indexerConnector)
        : m_indexerConnector(std::move(indexerConnector))
    {
    }

    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetCve - Starting GET CVE query handler");

        try
        {
            const std::string index = "wazuh-states-vulnerabilities";
            int totalCves = 0;
            logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetCve - Building CVE query");

            // Build query without search_after - pagination is now automatic
            auto query = InventorySyncQueryBuilder::buildCveGetQuery(std::string(data->agentId()),
                                                                     std::string(data->packageName()),
                                                                     std::string(data->packageVersion()),
                                                                     DEFAULT_PAGE_SIZE,
                                                                     ""); // Empty search_after - first page

            m_indexerConnector->executeSearchQueryWithPagination(
                index,
                query,
                [&totalCves, data](const nlohmann::json& response) mutable
                {
                    std::size_t pageHits = 0;
                    std::size_t storedCves = 0;
                    if (const auto* hitsPtr = response["hits"].find("hits");
                        hitsPtr != response["hits"].end() && hitsPtr->is_array())
                    {
                        const auto& hits = *hitsPtr;
                        pageHits = hits.size();
                        // Process each CVE hit
                        for (const auto& hit : hits)
                        {
                            if (const std::string* cveIdPtr = getCveIdPtr(hit))
                            {
                                // Store CVE data in context
                                const auto* srcPtr = hit.find("_source");
                                if (srcPtr != hit.end() && srcPtr->is_object())
                                {
                                    data->m_elements[*cveIdPtr] = *srcPtr;
                                    totalCves++;
                                    storedCves++;
                                    logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetCve - Stored CVE: %s", cveIdPtr->c_str());
                                }
                            }
                        }
                    }
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "TEventGetCve - Processing page: %zu hits, %zu CVEs stored",
                              pageHits,
                              storedCves);
                });

            logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetCve - Completed. Total CVEs stored: %d", totalCves);
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "TEventGetCve - Failed to execute GET CVE query: %s", e.what());
            // Continue with the chain even if the query fails
        }

        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetCve::handleRequest - Passing to next handler in chain");
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventGetCve = TEventGetCve<>;

#endif // _EVENT_GET_CVE_HPP
