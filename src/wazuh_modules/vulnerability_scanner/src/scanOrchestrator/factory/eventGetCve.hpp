/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * November 7, 2025.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_GET_CVE_HPP
#define _EVENT_GET_CVE_HPP

#include "chainOfResponsability.hpp"
#include "indexerConnector.hpp"
#include "scanContext.hpp"
#include "wazuh_modules/inventory_sync/src/inventorySyncQueryBuilder.hpp"
#include <memory>

/**
 * @brief EventGetCve class.
 *
 * This handler queries the indexer for existing CVEs/vulnerabilities by package information.
 * It executes GET queries to retrieve vulnerability data from the indexer based on
 * deleted package information (agent.id, package.name, package.version) and populates
 * CVEDetectionResult entries with operation = Delete.
 *
 * @tparam TIndexerConnector indexer connector type.
 * @tparam TScanContext scan context type.
 */
template<typename TIndexerConnector = IndexerConnectorSync, typename TScanContext = ScanContext>
class TEventGetCve final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    static constexpr size_t DEFAULT_PAGE_SIZE = 1000;

    /**
     * @brief Helper to safely extract CVE id from a hit.
     */
    static const std::string* getCveIdPtr(const nlohmann::json& hit)
    {
        // hit._source
        if (auto srcIt = hit.find("_source"); srcIt != hit.end() && srcIt->is_object())
        {
            const auto& src = srcIt.value();

            // _source.vulnerability
            if (auto vulnIt = src.find("vulnerability"); vulnIt != src.end() && vulnIt->is_object())
            {
                const auto& vuln = vulnIt.value();

                // vulnerability.id
                if (auto idIt = vuln.find("id"); idIt != vuln.end() && idIt->is_string())
                {
                    // get_ref returns an internal reference to the JSON string
                    return &idIt->get_ref<const std::string&>();
                }
            }
        }

        return nullptr;
    }

public:
    /**
     * @brief EventGetCve constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    explicit TEventGetCve(std::shared_ptr<TIndexerConnector> indexerConnector)
        : m_indexerConnector(std::move(indexerConnector))
    {
    }

    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetCve - Starting GET CVE query handler");

        try
        {
            const std::string index = "wazuh-states-vulnerabilities";
            int totalCves = 0;

            const auto agentIdStr = std::string(data->agentId());
            const auto pkgCount   = data->getPackageCount();

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetCve - Processing %zu packages for potential deletions",
                      pkgCount);

            for (size_t i = 0; i < pkgCount; ++i)
            {
                const auto& pkgEntry = data->getPackageContextData(i);
                const auto& pkgCtx   = pkgEntry.first;
                const auto  op       = pkgEntry.second;

                if (op != ElementOperation::Delete)
                {
                    continue;
                }

                if (pkgCtx.name.empty() || pkgCtx.version.empty())
                {
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "TEventGetCve - Package [%zu] marked for DELETE but missing name/version, skipping",
                              i);
                    continue;
                }

                logDebug2(WM_VULNSCAN_LOGTAG,
                          "TEventGetCve - Building CVE GET query for deleted package '%s' (v.%s) on agent '%s'",
                          pkgCtx.name.c_str(),
                          pkgCtx.version.c_str(),
                          agentIdStr.c_str());

                auto query = InventorySyncQueryBuilder::buildCveGetQuery(agentIdStr,
                                                                         pkgCtx.name,
                                                                         pkgCtx.version,
                                                                         pkgCtx.location,
                                                                         pkgCtx.type,
                                                                         pkgCtx.architecture,
                                                                         DEFAULT_PAGE_SIZE,
                                                                         "");

                int packageCves = 0;
                const PackageContextData pkgCtxCopy = pkgCtx;

                m_indexerConnector->executeSearchQueryWithPagination(
                    index,
                    query,
                    [data, &totalCves, &packageCves, pkgCtxCopy](const nlohmann::json& response) mutable
                    {
                        std::size_t pageHits   = 0;
                        std::size_t storedCves = 0;

                        if (response.contains("hits") && response["hits"].is_object())
                        {
                            const auto& hitsObj = response["hits"];

                            // hitsObj.hits
                            nlohmann::json::const_iterator hitsIt = hitsObj.find("hits");
                            if (hitsIt != hitsObj.end() && hitsIt->is_array())
                            {
                                const auto& hits = hitsIt.value();
                                pageHits         = hits.size();

                                // Process each CVE hit
                                for (const auto& hit : hits)
                                {
                                    const std::string* cveIdPtr = getCveIdPtr(hit);
                                    if (!cveIdPtr)
                                    {
                                        continue;
                                    }

                                    // detectionId: we always use the _id from the index
                                    std::string detectionId;
                                    nlohmann::json::const_iterator idIt = hit.find("_id");
                                    if (idIt != hit.end() && idIt->is_string())
                                    {
                                        detectionId = idIt->get<std::string>();
                                    }

                                    // Avoid duplicates
                                    if (data->hasCVE(detectionId))
                                    {
                                        logDebug2(WM_VULNSCAN_LOGTAG,
                                                  "TEventGetCve - Detection '%s' already present, skipping",
                                                  detectionId.c_str());
                                        continue;
                                    }

                                    // Fill CVEDetectionResult marking DELETE operation
                                    CVEDetectionResult det;
                                    det.cveId          = *cveIdPtr;
                                    det.cnaSource      = ""; // No source needed for delete
                                    det.matchCondition = "";
                                    det.conditionType  = MatchRuleCondition::Unknown;
                                    det.componentType  = AffectedComponentType::Package;
                                    det.feedOffset     = "";
                                    det.operation      = ElementOperation::Delete;

                                    // Package information obtained from context
                                    det.packageName         = pkgCtxCopy.name;
                                    det.packageVersion      = pkgCtxCopy.version;
                                    det.packageFormat       = pkgCtxCopy.format;
                                    det.packageArchitecture = pkgCtxCopy.architecture;
                                    det.packageDescription  = pkgCtxCopy.description;
                                    det.packageLocation     = pkgCtxCopy.location;
                                    det.packageInstallTime  = pkgCtxCopy.install_time;
                                    det.packageSize         = pkgCtxCopy.size;

                                    data->addDetectedCVE(detectionId, std::move(det));

                                    ++totalCves;
                                    ++packageCves;
                                    ++storedCves;

                                    logDebug2(WM_VULNSCAN_LOGTAG,
                                              "TEventGetCve - Registered DELETE operation for CVE '%s' "
                                              "(detectionId='%s')",
                                              cveIdPtr->c_str(),
                                              detectionId.c_str());
                                }
                            }
                        }

                        logDebug2(WM_VULNSCAN_LOGTAG,
                                  "TEventGetCve - Processing page for package '%s': %zu hits, %zu delete-operations "
                                  "registered",
                                  pkgCtxCopy.name.c_str(),
                                  pageHits,
                                  storedCves);
                    });

                logDebug2(WM_VULNSCAN_LOGTAG,
                          "TEventGetCve - Completed CVE lookup for deleted package '%s' (v.%s). "
                          "Total CVEs scheduled for deletion for this package: %d",
                          pkgCtx.name.c_str(),
                          pkgCtx.version.c_str(),
                          packageCves);
            }

            logDebug2(WM_VULNSCAN_LOGTAG,
                      "TEventGetCve - Completed. Total CVEs scheduled for deletion: %d",
                      totalCves);
        }
        catch (const std::exception& e)
        {
            logError(WM_VULNSCAN_LOGTAG, "TEventGetCve - Failed to execute GET CVE queries: %s", e.what());
            // Continue with the chain even if the queries fail
        }

        logDebug2(WM_VULNSCAN_LOGTAG, "TEventGetCve::handleRequest - Passing to next handler in chain");
        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
};

using EventGetCve = TEventGetCve<>;

#endif // _EVENT_GET_CVE_HPP
