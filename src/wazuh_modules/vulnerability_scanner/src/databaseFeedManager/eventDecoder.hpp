/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _EVENT_DECODER_HPP
#define _EVENT_DECODER_HPP

#include "chainOfResponsability.hpp"
#include "cve5_generated.h"
#include "cve5_schema.h"
#include "eventContext.hpp"
#include "flatbuffers/idl.h"
#include "packageTranslation_generated.h"
#include "packageTranslation_schema.h"
#include "stringHelper.h"

/**
 * @brief EventDecoder class.
 *
 */
class EventDecoder final : public AbstractHandler<std::shared_ptr<EventContext>>
{
private:
    const std::unique_ptr<Utils::RocksDBWrapper>& m_translationsDatabase;
    bool m_isCVEResource {true};

    /**
     * @brief Process a CVE5 or Translation message.
     *
     * @param data Event context.
     */
    void processEvent(std::shared_ptr<EventContext> data)
    {
        if (data->resource.contains("resource"))
        {
            if (Utils::startsWith(data->resource.at("resource"), "TID-"))
            {
                m_isCVEResource = false;
            }
            else if (!Utils::startsWith(data->resource.at("resource"), "CVE-"))
            {
                throw std::runtime_error("Invalid resource type.");
            }

            auto schema = m_isCVEResource ? cve5_SCHEMA : packageTranslation_SCHEMA;
            auto& database = m_isCVEResource ? data->cvesDatabase : m_translationsDatabase;

            if ("create" == data->resource.at("type"))
            {
                flatbuffers::Parser parser;

                if (!parser.Parse(schema) || !parser.Parse(data->resource.at("payload").dump().c_str()))
                {
                    throw std::runtime_error("Unable to parse payload: " + parser.error_);
                }

                rocksdb::Slice flatbufferResource(reinterpret_cast<const char*>(parser.builder_.GetBufferPointer()),
                                                  parser.builder_.GetSize());
                database->put(data->resource.at("resource"), flatbufferResource);
                if (m_isCVEResource)
                {
                    flatbuffers::FlatBufferBuilder& builder = parser.builder_;
                    data->cve5Buffer = builder.Release();
                }
            }

            else if ("update" == data->resource.at("type"))
            {
                rocksdb::PinnableSlice slice;
                if (!database->get(data->resource.at("resource"), slice))
                {
                    throw std::runtime_error("Unable to find resource.");
                }

                flatbuffers::IDLOptions options;
                options.output_default_scalars_in_json = true;
                options.strict_json = true;
                flatbuffers::Parser parser(options);
                parser.Parse(schema);

                std::string strData;
                flatbuffers::GenText(parser, reinterpret_cast<const uint8_t*>(slice.data()), &strData);
                auto jsonData = nlohmann::json::parse(strData);

                jsonData.patch_inplace(data->resource.at("operations"));
                if (!parser.Parse(jsonData.dump().c_str()))
                {
                    throw std::runtime_error("Unable to parse patched data: " + parser.error_);
                }

                rocksdb::Slice flatbufferResource(reinterpret_cast<const char*>(parser.builder_.GetBufferPointer()),
                                                  parser.builder_.GetSize());

                database->put(data->resource.at("resource"), flatbufferResource);
                if (m_isCVEResource)
                {
                    flatbuffers::FlatBufferBuilder& builder = parser.builder_;
                    data->cve5Buffer = builder.Release();
                }
            }
            // TODO: This is not fully supported and needs revision.
            else if ("delete" == data->resource.at("type"))
            {
                if (!m_isCVEResource)
                {
                    database->delete_(data->resource.at("resource"));
                }
            }

            else
            {
                throw std::runtime_error("Unknown event type");
            }
        }
        else
        {
            throw std::runtime_error("Missing key 'resource'.");
        }
    }

public:
    /**
     * @brief Constructor.
     *
     * @param translationsDatabase A translations database.
     */
    explicit EventDecoder(const std::unique_ptr<Utils::RocksDBWrapper>& translationsDatabase)
        : m_translationsDatabase(translationsDatabase)
    {
        if (!translationsDatabase)
        {
            throw std::runtime_error("Translations database is null");
        }
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Event context.
     * @return std::shared_ptr<EventContext> Abstract handler.
     */
    std::shared_ptr<EventContext> handleRequest(std::shared_ptr<EventContext> data) override
    {
        processEvent(data);
        std::shared_ptr<EventContext> ret = nullptr;

        if (m_isCVEResource)
        {
            ret = AbstractHandler<std::shared_ptr<EventContext>>::handleRequest(data);
        }

        return ret;
    }
};

#endif // _EVENT_DECODER_HPP
