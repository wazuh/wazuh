/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * May 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _UPSERT_TRANSLATION_HPP
#define _UPSERT_TRANSLATION_HPP

#include "flatbuffers/flatbuffer_builder.h"
#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/idl.h"
#include "flatbuffers/util.h"
#include "json.hpp"
#include "rocksDBWrapper.hpp"
#include "vulnerabilityTranslationPackages_generated.h"
#include "vulnerabilityTranslationPackages_schema.h"

constexpr auto TRANSLATION_DATABASE_PATH {"queue/vd/translations"};

/**
 * @brief UpsertTranslation class.
 *
 */
class UpsertTranslation final
{
private:
    /**
     * @brief Inserts a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void insertTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        std::string translationEntryStr;

        if (data.contains("payload"))
        {
            const std::string payload = data.at("payload").dump();
            const auto resource = data.at("resource").get_ref<const std::string&>();
            flatbuffers::Parser parser;

            if (!(parser.Parse(vulnerabilityTranslationPackages_SCHEMA) && parser.Parse(payload.c_str())))
            {
                throw std::runtime_error(parser.error_);
            }
            else
            {
                const auto buf = parser.builder_.GetBufferPointer();
                const auto flatbufferSize = parser.builder_.GetSize();
                const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(buf), flatbufferSize);

                rocksDbWrapper.put(resource, translationSlice);
            }
        }
        else
        {
            throw std::runtime_error("No payload data");
        }
    }

    /**
     * @brief Updates a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void updateTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        std::string translationEntryStr;

        if (rocksDbWrapper.get(data.at("resource").get_ref<const std::string&>(), translationEntryStr))
        {
            const auto resource = data.at("resource").get_ref<const std::string&>();
            std::string flatbufferSchemaStr;

            flatbuffers::Parser parser;
            parser.opts.strict_json = true;

            if (!parser.Parse(vulnerabilityTranslationPackages_SCHEMA))
            {
                throw std::runtime_error(parser.error_);
            }
            else
            {
                std::string translationEntry;
                if (!flatbuffers::GenText(parser, translationEntryStr.c_str(), &translationEntry))
                {
                    nlohmann::json translationEntryJSON = nlohmann::json::parse(translationEntry);
                    nlohmann::json translationEntryJSONPatched = translationEntryJSON.patch(data.at("operations"));
                    std::string translationEntryJSONPatchedStr = translationEntryJSONPatched.dump();
                    if (!parser.Parse(translationEntryJSONPatchedStr.c_str()))
                    {
                        throw std::runtime_error(parser.error_);
                    }
                    else
                    {
                        uint8_t* buf = parser.builder_.GetBufferPointer();
                        size_t flatbufferSize = parser.builder_.GetSize();

                        const rocksdb::Slice translationSlice(reinterpret_cast<const char*>(buf), flatbufferSize);
                        rocksDbWrapper.put(resource, translationSlice);
                    }
                }
                else
                {
                    throw std::runtime_error("Couldn't serialize data.");
                }
            }
        }
    }

public:
    /**
     * @brief Creates or modifies a translation entry in a rocksdb database.
     *
     * @param data JSON with the required information to create or update a translation entry.
     * @param rocksDbWrapper rocksdb wrapper instance.
     */
    static void upsertTranslationEntry(const nlohmann::json& data, Utils::RocksDBWrapper& rocksDbWrapper)
    {
        if (data.contains("data"))
        {
            for (const auto& item : data.at("data"))
            {
                if (item.contains("type") && item.contains("resource"))
                {
                    const auto type = item.at("type").get_ref<const std::string&>();

                    if (type.compare("create") == 0)
                    {
                        insertTranslationEntry(item, rocksDbWrapper);
                    }
                    else if (type.compare("update") == 0)
                    {
                        updateTranslationEntry(item, rocksDbWrapper);
                    }
                    else
                    {
                        throw std::runtime_error("Invalid operation type: " + type + " for " +
                                                 item.at("resource").get_ref<const std::string&>());
                    }
                }
                else
                {
                    throw std::runtime_error(R"(Invalid data format. Missing "type" or "resource" key.)");
                }
            }
        }
        else
        {
            throw std::runtime_error(R"(Invalid data format. Missing "data" key.)");
        }
    }
};

#endif // _UPSERT_TRANSLATION_HPP
