/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _DATABASE_FEED_MANAGER_HPP
#define _DATABASE_FEED_MANAGER_HPP

#include "../policyManager/policyManager.hpp"
#include "../scanOrchestrator/scanContext.hpp"
#include "contentRegister.hpp"
#include "eventDecoder.hpp"
#include "feedIndexer.hpp"
#include "iDatabaseFeedManager.hpp"
#include "indexerConnector.hpp"
#include "observer.hpp"
#include "rocksDBWrapper.hpp"
#include "routerSubscriber.hpp"
#include "scanDispatcher.hpp"
#include "storeModel.hpp"
#include <external/nlohmann/json.hpp>
#include <functional>
#include <memory>
#include <string>
#include <vector>

constexpr auto DESCRIPTION_DATABASE_PATH {"queue/vd/descriptions"};
constexpr auto REMEDIATIONS_DATABASE_PATH {"queue/vd/remediations"};

/**
 * @brief DatabaseFeedManager class.
 *
 * @tparam TIndexerConnector Indexer connector type.
 * @tparam TPolicyManager Policy manager type.
 * @tparam TContentRegister Content register type.
 * @tparam TRouterSubscriber Router subscriber type.
 */
template<typename TIndexerConnector = IndexerConnector,
         typename TPolicyManager = PolicyManager,
         typename TContentRegister = ContentRegister,
         typename TRouterSubscriber = RouterSubscriber>
class TDatabaseFeedManager final : public Observer<nlohmann::json&>
{
public:
    /**
     * @brief Class constructor.
     *
     * @param indexerConnector Indexer connector.
     */
    // TODO: Remove LCOV flags once the implementation of the 'Indexer Connector' module is completed
    // LCOV_EXCL_START
    explicit TDatabaseFeedManager(std::shared_ptr<TIndexerConnector> indexerConnector)
        : Observer("database_feed_manager")
        , m_indexerConnector(indexerConnector)
    {

        const auto updaterPolicy = TPolicyManager::instance().getUpdaterConfiguration();
        // Vulnerability content updater initialization.
        m_contentRegistration = std::make_unique<TContentRegister>(
            updaterPolicy.at("topicName"), TPolicyManager::instance().getUpdaterConfiguration());

        m_descriptionsDatabase = std::make_unique<Utils::RocksDBWrapper>(DESCRIPTION_DATABASE_PATH);
        m_remediationsDatabase = std::make_unique<Utils::RocksDBWrapper>(REMEDIATIONS_DATABASE_PATH);

        // Subscription to vulnerability detector content update events.
        m_contentUpdateSubscription =
            std::make_unique<TRouterSubscriber>(updaterPolicy.at("topicName"), "vulnerability_feed_manager");

        m_contentUpdateSubscription->subscribe(
            [this](const std::vector<char>& message)
            {
                std::cout << "DatabaseFeedManager::update" << std::endl;
                auto eventContext = std::make_shared<EventContext>(
                    EventContext {.indexerConnector = m_indexerConnector, .message = message});
                auto eventDecoder = std::make_shared<EventDecoder>();
                eventDecoder->setLast(std::make_shared<StoreModel>());
                eventDecoder->setLast(std::make_shared<FeedIndexer>());
                eventDecoder->setLast(std::make_shared<ScanDispatcher>());

                eventDecoder->handleRequest(eventContext);
            });
    }
    /**
     * @brief Get the Vulnerabilities Candidates information.
     *
     * @param cnaName RocksDB table identifier.
     * @param context Scan context structure.
     * @param callback Store vulnerability data.
     */
    void accessGetVulnerabilitiesCandidates(const std::string& cnaName,
                                            const ScanContext& context,
                                            const std::function<bool(const char* data, const size_t size)>& callback)
    {
        getVulnerabilitiesCandidates(cnaName, context, callback);
    }

    /**
     * @brief Updates scheduler interval.
     *
     * @param data Data containing the interval.
     */
    void update(nlohmann::json& data) override
    {
        m_contentRegistration->changeSchedulerInterval(data.at("updater").at("interval").get<size_t>());
    }
    // LCOV_EXCL_STOP

private:
    std::unique_ptr<TRouterSubscriber> m_contentUpdateSubscription;
    std::unique_ptr<TContentRegister> m_contentRegistration;
    std::shared_ptr<TIndexerConnector> m_indexerConnector;
    std::unique_ptr<Utils::RocksDBWrapper> m_descriptionsDatabase;
    std::unique_ptr<Utils::RocksDBWrapper> m_remediationsDatabase;
    std::map<std::string, std::unique_ptr<Utils::RocksDBWrapper>> m_feedsDatabases;
};

using DatabaseFeedManager = TDatabaseFeedManager<>;

#endif // _DATABASE_FEED_MANAGER_HPP
