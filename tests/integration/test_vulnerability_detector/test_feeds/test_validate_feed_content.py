'''
copyright: Copyright (C) 2015-2023, Wazuh Inc.

           Created by Wazuh, Inc. <info@wazuh.com>.

           This program is free software; you can redistribute it and/or modify it under the terms of GPLv2

type: integration

brief: Wazuh is able to detect vulnerabilities in the applications installed in agents using the Vulnerability Detector
       module. This software audit is performed through the integration of vulnerability feeds indexed by Redhat,
       Canonical, Debian, Amazon Linux and NVD Database.

components:
    - vulnerability_detector

suite: feeds

targets:
    - manager

daemons:
    - wazuh-modulesd
    - wazuh-db
    - wazuh-analysisd

os_platform:
    - linux

os_version:
    - Arch Linux
    - Amazon Linux 2
    - Amazon Linux 1
    - CentOS 8
    - CentOS 7
    - Debian Buster
    - Red Hat 8
    - Ubuntu Trusty
    - Ubuntu Xenial
    - Ubuntu Bionic
    - Ubuntu Focal
    - Ubuntu Jammy
    - SUSE Linux Enterprise Desktop 11
    - SUSE Linux Enterprise Desktop 12
    - SUSE Linux Enterprise Desktop 15
    - SUSE Linux Enterprise Server 11
    - SUSE Linux Enterprise Server 12
    - SUSE Linux Enterprise Server 15

references:
    - https://documentation.wazuh.com/current/user-manual/capabilities/vulnerability-detection/
    - https://documentation.wazuh.com/current/user-manual/capabilities/syscollector.html

tags:
    - vulnerability
    - vulnerability_detector
    - feeds
'''
import os
import pytest
from datetime import datetime

from wazuh_testing.utils.configuration import get_test_cases_data
from wazuh_testing.utils.file import (decompress_file, download_file, remove_file, validate_json_file,
                                      validate_xml_file, get_file_info)
from . import TEST_CASES_PATH


# Configuration and cases data
cases_path = os.path.join(TEST_CASES_PATH, 'cases_validate_feed_content.yaml')


# Validate JSON feed content test configurations (t1)
_, configuration_metadata, case_ids = get_test_cases_data(cases_path)

# Add NVD from 2002 to current year configuration and metadata
current_year = datetime.now().year
for year in range(2002, current_year + 1):
    configuration_metadata.append({'type': 'json', 'provider_name': 'nvd', 'expected_format': 'application/gzip',
                                   'path': f"/tmp/nvdcve-1.1-{year}.json.gz", 'extension': 'gz',
                                   'url': f"https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-{year}.json.gz",
                                   'decompressed_file': f"/tmp/nvd-{year}.json"})
    case_ids.append(f"NVD-{year}")


def build_error_message(file_path, expected_format, check_type='extension'):
    """Define the error message when the extension or mime_type is not the expected one.

    Args:
        file_path (str): Path of the checked file.
        expected_format (str): Expected file format.
        check_type (str): 'extension` or `mime_type`.

    Returns:
        str: Error message.
    """
    return f"File {check_type} not expected. Got {file.get_file_info(file_path, check_type)} and expected " \
           f"{expected_format}"


@pytest.fixture
def manage_file(test_metadata):
    """Download and clean test files.

    Args:
        test_metadata (dict): Feed information which comes from metadata test case.
    """
    # Download the file
    download_file(source_url=test_metadata['url'], dest_path=test_metadata['path'])

    # Decompress files
    if 'application/gzip' in test_metadata['expected_format']:
        decompress_file(file_path=test_metadata['path'], dest_file_path=test_metadata['decompressed_file'],
                        compression_type='gzip')
    elif 'application/x-bzip2' in test_metadata['expected_format']:
        decompress_file(file_path=test_metadata['path'], dest_file_path=test_metadata['decompressed_file'],
                        compression_type='bz2')

    yield

    # Clean downloaded file/s
    remove_file(file_path=test_metadata['path'])

    if test_metadata['expected_format'] in ['application/gzip', 'application/x-bzip2']:
        remove_file(file_path=test_metadata['decompressed_file'])


@pytest.mark.tier(level=2)
@pytest.mark.parametrize('test_metadata', configuration_metadata, ids=case_ids)
def test_validate_json_feed_content(test_metadata, manage_file):
    '''
    description: Check if the downloaded JSON feeds have the expected format and are JSON parseable.

    test_phases:
        - Download the feed file.
        - Check the content is JSON parseable (decompress if necessary).

    wazuh_min_version: 4.4.0

    tier: 2

    parameters:
        - test_metadata:
            type: dict
            brief: Wazuh configuration metadata
        - manage_file:
            type: fixture
            brief: Download and clean test files.

    assertions:
        - Check if the file is JSON parseable.

    input_description:
        - The `cases_validate_redhat_json_feed_content.yaml` file provides the module configuration for this test.
    '''
    if 'decompressed_file' in test_metadata:
        # Check compressed file extension
        file_info = get_file_info(file_path=test_metadata['path'], info_type="extension")
        assert file_info == test_metadata['extension'], build_error_message(test_metadata['path'], 'extension')

        # Check compressed file mim_type
        file_info = get_file_info(file_path=test_metadata['path'], info_type="mime_type")
        assert file_info == test_metadata['expected_format'], build_error_message(test_metadata['path'], 'mime_type')

    # Get the raw feed path
    feed_file = test_metadata['decompressed_file'] if 'decompressed_file' in test_metadata else test_metadata['path']

    if test_metadata['type'] == 'json':
        # Check if the raw feed is JSON parseable
        assert validate_json_file(feed_file), f"{test_metadata['provider_name']} file is not JSON 'parseable'"
    else:
        # Check if the raw feed is XML parseable
        assert validate_xml_file(feed_file), f"{test_metadata['provider_name']} file is not XML 'parseable'"
