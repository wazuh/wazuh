# Security Configuration Assessment
# CIS Checks for Rocky Linux 9
# Copyright (C) 2015, Wazuh Inc.
#
# This program is free software; you can redistribute it
# and/or modify it under the terms of the GNU General Public
# License (version 2) as published by the FSF - Free Software
# Foundation
#
# Based on:
# Center for Internet Security Rocky Linux 9 Benchmark v2.0.0 - 06-25-2024

policy:
  id: "cis_rocky_linux_9"
  file: "cis_rocky_linux_9.yml"
  name: "CIS Rocky Linux 9 Benchmark v2.0.0"
  description: "This document provides prescriptive guidance for establishing a secure configuration posture for Rocky Linux 9 systems running on x86_64 platforms.This document was tested against Rocky Linux 9."
  references:
    - https://www.cisecurity.org/cis-benchmarks/

requirements:
  title: "Check RL9 family platform."
  description: "Requirements for running the policy against Rocky Linux 9 family."
  condition: any
  rules:
    - 'f:/etc/redhat-release -> r:^Rocky Linux && r:release 9\p*'

variables:
  $sshd_file: /etc/ssh/sshd_config

checks:

  ###############################################
  # 1.1 Filesystem
  ###############################################
  ###############################################
  # 1.1.1 Configure Filesystem Kernel Modules
  ###############################################

  # 1.1.1.1 Ensure cramfs kernel module is not available (Automated)
  - id: 31500
    title: "Ensure cramfs kernel module is not available."
    description: "The cramfs filesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. A cramfs image can be used without having to first decompress the image."
    rationale: "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
    remediation: "Run the following script to disable the cramfs filesystem: #!/usr/bin/env bash { l_mname=\"cramfs\" # set module name # Check if the module exists on the system if [ -z \"$(modprobe -n -v \"$l_mname\" 2>&1 | grep -Pi -- \"\\h*modprobe:\\h+FATAL:\\h+Module\\h+$l_mname\\h+not\\h+found\\h+in\\h+directory\")\" ]; then # Remediate loadable l_loadable=\"$(modprobe -n -v \"$l_mname\")\" [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\" if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then echo -e \" - setting module: \\\"$l_mname\\\" to be not loadable\" echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mname\".conf fi # Remediate loaded if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then echo -e \" - unloading module \\\"$l_mname\\\"\" modprobe -r \"$l_mname\" fi # Remediate deny list if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mname\\b\"; then echo -e \" - deny listing \\\"$l_mname\\\"\" echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mname\".conf fi else echo -e \" - Nothing to remediate\\n - Module \\\"$l_mname\\\" doesn't exist on the system\" fi }."
    compliance:
      - cis: ["1.1.1.1"]
      - cis_csc_v8: ["4.8"]
      - cis_csc_v7: ["9.2"]
      - mitre_mitigations: ["M1050"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1005"]
      - nist_sp_800-53: ["CM-7"]
    condition: any
    rules:
      - "c:modprobe -n -v cramfs -> r:install /bin/false|install /bin/true|Module cramfs not found"
      - "not c:lsmod -> r:cramfs"
      - 'd:/etc/modprobe.d/ -> r:\.*.conf -> r:^blacklist\s+cramfs'

  # 1.1.1.2 Ensure freevxfs kernel module is not available (Automated)
  - id: 31500
    title: "Ensure freevxfs kernel module is not available."
    description: "The freevxfs filesystem type is a free version of the Veritas type filesystem. This is the primary filesystem type for HP-UX operating systems."
    rationale: "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
    remediation: "Run the following script to disable the freevxfs filesystem: #!/usr/bin/env bash { l_mname=\"freevxfs\" # set module name # Check if the module exists on the system if [ -z \"$(modprobe -n -v \"$l_mname\" 2>&1 | grep -Pi -- \"\\h*modprobe:\\h+FATAL:\\h+Module\\h+$l_mname\\h+not\\h+found\\h+in\\h+directory\")\" ]; then # Remediate loadable l_loadable=\"$(modprobe -n -v \"$l_mname\")\" [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\" if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then echo -e \" - setting module: \\\"$l_mname\\\" to be not loadable\" echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mname\".conf fi # Remediate loaded if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then echo -e \" - unloading module \\\"$l_mname\\\"\" modprobe -r \"$l_mname\" fi # Remediate deny list if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mname\\b\"; then echo -e \" - deny listing \\\"$l_mname\\\"\" echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mname\".conf fi else echo -e \" - Nothing to remediate\\n - Module \\\"$l_mname\\\" doesn't exist on the system\" fi }."
    compliance:
      - cis: ["1.1.1.2"]
      - cis_csc_v8: ["4.8"]
      - cis_csc_v7: ["9.2"]
      - mitre_mitigations: ["M1050"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1005"]
      - nist_sp_800-53: ["CM-7"]
    condition: any
    rules:
      - "c:modprobe -n -v freevxfs -> r:install /bin/false|install /bin/true|Module freevxfs not found"
      - "not c:lsmod -> r:freevxfs"
      - 'd:/etc/modprobe.d/ -> r:\.*.conf -> r:^blacklist\s+freevxfs'

  # 1.1.1.3 Ensure hfs kernel module is not available (Automated)
  - id: 31500
    title: "Ensure hfs kernel module is not available."
    description: "The hfs filesystem type is a hierarchical filesystem that allows you to mount Mac OS filesystems."
    rationale: "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
    remediation: "Run the following script to disable the hfs filesystem: #!/usr/bin/env bash { l_mname=\"hfs\" # set module name # Check if the module exists on the system if [ -z \"$(modprobe -n -v \"$l_mname\" 2>&1 | grep -Pi -- \"\\h*modprobe:\\h+FATAL:\\h+Module\\h+$l_mname\\h+not\\h+found\\h+in\\h+directory\")\" ]; then # Remediate loadable l_loadable=\"$(modprobe -n -v \"$l_mname\")\" [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\" if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then echo -e \" - setting module: \\\"$l_mname\\\" to be not loadable\" echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mname\".conf fi # Remediate loaded if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then echo -e \" - unloading module \\\"$l_mname\\\"\" modprobe -r \"$l_mname\" fi # Remediate deny list if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mname\\b\"; then echo -e \" - deny listing \\\"$l_mname\\\"\" echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mname\".conf fi else echo -e \" - Nothing to remediate\\n - Module \\\"$l_mname\\\" doesn't exist on the system\" fi }."
    compliance:
      - cis: ["1.1.1.3"]
      - cis_csc_v8: ["4.8"]
      - cis_csc_v7: ["9.2"]
      - mitre_mitigations: ["M1050"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1005"]
      - nist_sp_800-53: ["CM-7"]
    condition: any
    rules:
      - "c:modprobe -n -v hfs -> r:install /bin/false|install /bin/true|Module hfs not found"
      - "not c:lsmod -> r:hfs"
      - 'd:/etc/modprobe.d/ -> r:\.*.conf -> r:^blacklist\s+hfs'

  # 1.1.1.4 Ensure hfsplus kernel module is not available (Automated)
  - id: 31500
    title: "Ensure hfsplus kernel module is not available."
    description: "The hfsplus filesystem type is a hierarchical filesystem designed to replace hfs that allows you to mount Mac OS filesystems."
    rationale: "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
    remediation: "Run the following script to disable the hfsplus filesystem: #!/usr/bin/env bash { l_mname=\"hfsplus\" # set module name # Check if the module exists on the system if [ -z \"$(modprobe -n -v \"$l_mname\" 2>&1 | grep -Pi -- \"\\h*modprobe:\\h+FATAL:\\h+Module\\h+$l_mname\\h+not\\h+found\\h+in\\h+directory\")\" ]; then # Remediate loadable l_loadable=\"$(modprobe -n -v \"$l_mname\")\" [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\" if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then echo -e \" - setting module: \\\"$l_mname\\\" to be not loadable\" echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mname\".conf fi # Remediate loaded if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then echo -e \" - unloading module \\\"$l_mname\\\"\" modprobe -r \"$l_mname\" fi # Remediate deny list if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mname\\b\"; then echo -e \" - deny listing \\\"$l_mname\\\"\" echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mname\".conf fi else echo -e \" - Nothing to remediate\\n - Module \\\"$l_mname\\\" doesn't exist on the system\" fi }."
    compliance:
      - cis: ["1.1.1.4"]
      - cis_csc_v8: ["4.8"]
      - cis_csc_v7: ["9.2"]
      - mitre_mitigations: ["M1050"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1005"]
      - nist_sp_800-53: ["CM-7"]
    condition: any
    rules:
      - "c:modprobe -n -v hfsplus -> r:install /bin/false|install /bin/true|Module hfsplus not found"
      - "not c:lsmod -> r:hfsplus"
      - 'd:/etc/modprobe.d/ -> r:\.*.conf -> r:^blacklist\s+hfsplus'

  # 1.1.1.5 Ensure jffs2 kernel module is not available (Automated)
  - id: 31500
    title: "Ensure jffs2 kernel module is not available."
    description: "The jffs2 (journaling flash filesystem 2) filesystem type is a log-structured filesystem used in flash memory devices."
    rationale: "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
    remediation: "Run the following script to disable the jffs2 filesystem: #!/usr/bin/env bash { l_mname=\"jffs2\" # set module name # Check if the module exists on the system if [ -z \"$(modprobe -n -v \"$l_mname\" 2>&1 | grep -Pi -- \"\\h*modprobe:\\h+FATAL:\\h+Module\\h+$l_mname\\h+not\\h+found\\h+in\\h+directory\")\" ]; then # Remediate loadable l_loadable=\"$(modprobe -n -v \"$l_mname\")\" [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\" if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then echo -e \" - setting module: \\\"$l_mname\\\" to be not loadable\" echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mname\".conf fi # Remediate loaded if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then echo -e \" - unloading module \\\"$l_mname\\\"\" modprobe -r \"$l_mname\" fi # Remediate deny list if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mname\\b\"; then echo -e \" - deny listing \\\"$l_mname\\\"\" echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mname\".conf fi else echo -e \" - Nothing to remediate\\n - Module \\\"$l_mname\\\" doesn't exist on the system\" fi }."
    compliance:
      - cis: ["1.1.1.5"]
      - cis_csc_v8: ["4.8"]
      - cis_csc_v7: ["9.2"]
      - mitre_mitigations: ["M1050"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1005"]
      - nist_sp_800-53: ["CM-7"]
    condition: any
    rules:
      - "c:modprobe -n -v jffs2 -> r:install /bin/false|install /bin/true|Module jffs2 not found"
      - "not c:lsmod -> r:jffs2"
      - 'd:/etc/modprobe.d/ -> r:\.*.conf -> r:^blacklist\s+jffs2'

  # 1.1.1.6 Ensure squashfs kernel module is not available (Automated)
  - id: 31500
    title: "Ensure squashfs kernel module is not available."
    description: "The squashfs filesystem type is a compressed read-only Linux filesystem embedded in small footprint systems. A squashfs image can be used without having to first decompress the image."
    rationale: "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
    impact: 'Snap application packages of software are self-contained and work across a range of Linux distributions. This is unlike traditional Linux package management approaches, like APT or RPM, which require specifically adapted packages per Linux distribution on an application update and delay therefore application deployment from developers to their software's end-user. Snaps themselves have no dependency on any external store ("App store"), can be obtained from any source and can be therefore used for upstream software deployment.'
    remediation: "Run the following script to disable squashfs: #!/usr/bin/env bash { l_mname=\"squashfs\" # set module name # Check if the module exists on the system if [ -z \"$(modprobe -n -v \"$l_mname\" 2>&1 | grep -Pi -- \"\\h*modprobe:\\h+FATAL:\\h+Module\\h+$l_mname\\h+not\\h+found\\h+in\\h+directory\")\" ]; then # Remediate loadable l_loadable=\"$(modprobe -n -v \"$l_mname\")\" [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\" if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then echo -e \" - setting module: \\\"$l_mname\\\" to be not loadable\" echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mname\".conf fi # Remediate loaded if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then echo -e \" - unloading module \\\"$l_mname\\\"\" modprobe -r \"$l_mname\" fi # Remediate deny list if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mname\\b\"; then echo -e \" - deny listing \\\"$l_mname\\\"\" echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mname\".conf fi else echo -e \" - Nothing to remediate\\n - Module \\\"$l_mname\\\" doesn't exist on the system\" fi }."
    compliance:
      - cis: ["1.1.1.6"]
      - cis_csc_v8: ["4.8"]
      - cis_csc_v7: ["9.2"]
      - cmmc_v2.0: ["CM.L2-3.4.7", "CM.L2-3.4.8", "SC.L2-3.13.6"]
      - iso_27001-2013: ["A.13.1.3"]
      - mitre_mitigations: ["M1050"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1005"]
      - pci_dss_3.2.1: ["1.1.6", "1.2.1", "2.2.2", "2.2.5"]
      - pci_dss_4.0: ["1.2.5", "2.2.4", "6.4.1"]
      - soc_2: ["CC6.3", "CC6.6"]
    condition: any
    rules:
      - "c:modprobe -n -v squashfs -> r:install /bin/false|install /bin/true|Module squashfs not found"
      - "not c:lsmod -> r:squashfs"
      - 'd:/etc/modprobe.d/ -> r:\.*.conf -> r:^blacklist\s+squashfs'

  # 1.1.1.7 Ensure udf kernel module is not available (Automated)
  - id: 31501
    title: "Ensure udf kernel module is not available."
    description: "The udf filesystem type is the universal disk format used to implement ISO/IEC 13346 and ECMA-167 specifications. This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is necessary to support writing DVDs and newer optical disc formats."
    rationale: "Removing support for unneeded filesystem types reduces the local attack surface of the system. If this filesystem type is not needed, disable it."
    impact: "Microsoft Azure requires the usage of udf. udf should not be disabled on systems run on Microsoft Azure."
    remediation: "Run the following script to disable the udf filesystem: #!/usr/bin/env bash { l_mname=\"udf\" # set module name # Check if the module exists on the system if [ -z \"$(modprobe -n -v \"$l_mname\" 2>&1 | grep -Pi -- \"\\h*modprobe:\\h+FATAL:\\h+Module\\h+$l_mname\\h+not\\h+found\\h+in\\h+directory\")\" ]; then # Remediate loadable l_loadable=\"$(modprobe -n -v \"$l_mname\")\" [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\" if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then echo -e \" - setting module: \\\"$l_mname\\\" to be not loadable\" echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mname\".conf fi # Remediate loaded if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then echo -e \" - unloading module \\\"$l_mname\\\"\" modprobe -r \"$l_mname\" fi # Remediate deny list if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$l_mname\\b\"; then echo -e \" - deny listing \\\"$l_mname\\\"\" echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mname\".conf fi else echo -e \" - Nothing to remediate\\n - Module \\\"$l_mname\\\" doesn't exist on the system\" fi }."
    compliance:
      - cis: ["1.1.1.7"]
      - cis_csc_v8: ["4.8"]
      - cis_csc_v7: ["9.2"]
      - cmmc_v2.0: ["CM.L2-3.4.7", "CM.L2-3.4.8", "SC.L2-3.13.6"]
      - iso_27001-2013: ["A.13.1.3"]
      - mitre_mitigations: ["M1050"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1005"]
      - pci_dss_3.2.1: ["1.1.6", "1.2.1", "2.2.2", "2.2.5"]
      - pci_dss_4.0: ["1.2.5", "2.2.4", "6.4.1"]
      - soc_2: ["CC6.3", "CC6.6"]
    condition: any
    rules:
      - "c:modprobe -n -v udf -> r:install /bin/false|install /bin/true|Module udf not found"
      - "not c:lsmod -> r:udf"
      - 'd:/etc/modprobe.d/ -> r:\.*.conf -> r:^blacklist\s+udf'

  # 1.1.1.8 Ensure usb-storage kernel module is not available (Automated)
  - id: 31528
    title: "Ensure usb-storage kernel module is not available."
    description: "USB storage provides a means to transfer and store files ensuring persistence and availability of the files independent of network connection status. Its popularity and utility has led to USB-based malware being a simple and common means for network infiltration and a first step to establishing a persistent threat within a networked environment."
    rationale: "Restricting USB access on the system will decrease the physical attack surface for a device and diminish the possible vectors to introduce malware."
    remediation: "Run the following script to disable usb-storage: #!/usr/bin/env bash { l_mname=\"usb-storage\" # set module name # Check if the module exists on the system if [ -z \"$(modprobe -n -v \"$l_mname\" 2>&1 | grep -Pi -- \"\\h*modprobe:\\h+FATAL:\\h+Module\\h+$l_mname\\h+not\\h+found\\h+in\\h+directory\")\" ]; then # Remediate loadable l_loadable=\"$(modprobe -n -v \"$l_mname\")\" [ \"$(wc -l <<< \"$l_loadable\")\" -gt \"1\" ] && l_loadable=\"$(grep -P -- \"(^\\h*install|\\b$l_mname)\\b\" <<< \"$l_loadable\")\" if ! grep -Pq -- '^\\h*install \\/bin\\/(true|false)' <<< \"$l_loadable\"; then echo -e \" - setting module: \\\"$l_mname\\\" to be not loadable\" echo -e \"install $l_mname /bin/false\" >> /etc/modprobe.d/\"$l_mname\".conf fi # Remediate loaded if lsmod | grep \"$l_mname\" > /dev/null 2>&1; then echo -e \" - unloading module \\\"$l_mname\\\"\" modprobe -r \"$l_mname\" fi # Remediate deny list if ! modprobe --showconfig | grep -Pq -- \"^\\h*blacklist\\h+$(tr '-' '_' <<< \"$l_mname\")\\b\"; then echo -e \" - deny listing \\\"$l_mname\\\"\" echo -e \"blacklist $l_mname\" >> /etc/modprobe.d/\"$l_mname\".conf fi else echo -e \" - Nothing to remediate\\n - Module \\\"$l_mname\\\" doesn't exist on the system\" fi }."
    compliance:
      - cis: ["1.1.1.8"]
      - cis_csc_v8: ["10.3"]
      - cis_csc_v7: ["13.7"]
      - cmmc_v2.0: ["MP.L2-3.8.7"]
      - hipaa: ["164.310(d)(1)"]
      - iso_27001-2013: ["A.8.3.1"]
      - mitre_mitigations: ["M1034"]
      - mitre_tactics: ["TA0001", "TA0010"]
      - mitre_techniques: ["T1091"]
      - nist_sp_800-53: ["SC-18(4)"]
    condition: any
    rules:
      - "c:modprobe -n -v usb-storage -> r:install /bin/true|install /bin/false"
      - "not c:lsmod -> r:usb-storage"
      - 'd:/etc/modprobe.d/ -> r:\.*.conf -> r:^blacklist\s+usb-storage'

  # 1.1.1.9 Ensure unused filesystems kernel modules are not available (Manual) - Not Implemented

  # 1.1.2.1.1 Ensure /tmp is a separate partition. (Automated)
  - id: 31502
    title: "Ensure /tmp is a separate partition."
    description: "The /tmp directory is a world-writable directory used for temporary storage by all users and some applications."
    rationale: "Making /tmp its own file system allows an administrator to set additional mount options such as the noexec option on the mount, making /tmp useless for an attacker to install executable code. It would also prevent an attacker from establishing a hard link to a system setuid program and wait for it to be updated. Once the program was updated, the hard link would be broken and the attacker would have his own copy of the program. If the program happened to have a security vulnerability, the attacker could continue to exploit the known flaw. Since the /tmp directory is intended to be world-writable, there is a risk of resource exhaustion if it is not bound to a separate partition. This can be accomplished by either mounting tmpfs to /tmp, or creating a separate partition for /tmp."
    impact: "By design files saved to /tmp should have no expectation of surviving a reboot of the system. tmpfs is ram based and all files stored to tmpfs will be lost when the system is rebooted. If files need to be persistent through a reboot, they should be saved to /var/tmp not /tmp. Running out of /tmp space is a problem regardless of what kind of filesystem lies under it, but in a configuration where /tmp is not a separate file system it will essentially have the whole disk available, as the default installation only creates a single / partition. On the other hand, a RAM-based /tmp (as with tmpfs) will almost certainly be much smaller, which can lead to applications filling up the filesystem much more easily. Another alternative is to create a dedicated partition for /tmp from a separate volume or disk. One of the downsides of a disk-based dedicated partition is that it will be slower than tmpfs which is RAM-based."
    remediation: "First ensure that systemd is correctly configured to ensure that /tmp will be mounted at boot time. # systemctl unmask tmp.mount For specific configuration requirements of the /tmp mount for your environment, modify /etc/fstab. Example of using tmpfs with specific mount options: tmpfs /tmp 0 tmpfs defaults,rw,nosuid,nodev,noexec,relatime,size=2G 0 Example of using a volume or disk with specific mount options. The source location of the volume or disk will vary depending on your environment. <device> /tmp <fstype> defaults,nodev,nosuid,noexec 0 0."
    references:
      - "https://www.freedesktop.org/wiki/Software/systemd/APIFileSystems/"
      - "https://www.freedesktop.org/software/systemd/man/systemd-fstab-generator.html"
    compliance:
      - cis: ["1.1.2.1.1"]
      - cis_csc_v8: ["4.8"]
      - cis_csc_v7: ["9.2"]
      - cmmc_v2.0: ["CM.L2-3.4.7", "CM.L2-3.4.8", "SC.L2-3.13.6"]
      - iso_27001-2013: ["A.13.1.3"]
      - mitre_mitigations: ["M1022"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1499", "T1499.001"]
      - nist_sp_800-53: ["CM-7"]
      - pci_dss_3.2.1: ["1.1.6", "1.2.1", "2.2.2", "2.2.5"]
      - pci_dss_4.0: ["1.2.5", "2.2.4", "6.4.1"]
      - soc_2: ["CC6.3", "CC6.6"]
    condition: all
    rules:
      - 'c:findmnt --kernel /tmp -> r:^/tmp\s'
      - "c:systemctl is-enabled tmp.mount -> r:enabled|static|generated"

  # 1.1.2.1.2 Ensure nodev option set on /tmp partition. (Automated)
  - id: 31503
    title: "Ensure nodev option set on /tmp partition."
    description: "The nodev mount option specifies that the filesystem cannot contain special devices."
    rationale: "Since the /tmp filesystem is not intended to support devices, set this option to ensure that users cannot create a block or character special devices in /tmp."
    remediation: "Edit the /etc/fstab file and add nodev to the fourth field (mounting options) for the /tmp partition. Example: <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0 Run the following command to remount /tmp with the configured options: # mount -o remount /tmp."
    compliance:
      - cis: ["1.1.2.1.2"]
      - cis_csc_v8: ["4.8"]
      - cis_csc_v7: ["9.2"]
      - cmmc_v2.0: ["CM.L2-3.4.7", "CM.L2-3.4.8", "SC.L2-3.13.6"]
      - iso_27001-2013: ["A.13.1.3"]
      - mitre_mitigations: ["M1022"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1200"]
      - nist_sp_800-53: ["CM-7"]
      - pci_dss_3.2.1: ["1.1.6", "1.2.1", "2.2.2", "2.2.5"]
      - pci_dss_4.0: ["1.2.5", "2.2.4", "6.4.1"]
      - soc_2: ["CC6.3", "CC6.6"]
    condition: all
    rules:
      - "c:findmnt --kernel /tmp -> r:nodev"

  # 1.1.2.1.3 Ensure nosuid option set on /tmp partition. (Automated)
  - id: 31505
    title: "Ensure nosuid option set on /tmp partition."
    description: "The nosuid mount option specifies that the filesystem cannot contain setuid files."
    rationale: "Since the /tmp filesystem is only intended for temporary file storage, set this option to ensure that users cannot create setuid files in /tmp."
    remediation: "Edit the /etc/fstab file and add nosuid to the fourth field (mounting options) for the /tmp partition. Example: <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0 Run the following command to remount /tmp with the configured options: # mount -o remount /tmp."
    compliance:
      - cis: ["1.1.2.1.3"]
      - cis_csc_v8: ["3.3"]
      - cis_csc_v7: ["14.6"]
      - cmmc_v2.0: ["AC.L1-3.1.1", "AC.L1-3.1.2", "AC.L2-3.1.3", "AC.L2-3.1.5", "MP.L2-3.8.2"]
      - hipaa: ["164.308(a)(3)(i)", "164.308(a)(3)(ii)(A)", "164.312(a)(1)"]
      - iso_27001-2013: ["A.9.1.1"]
      - mitre_mitigations: ["M1022"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1548", "T1548.001"]
      - nist_sp_800-53: ["AC-3", "MP-2"]
      - pci_dss_3.2.1: ["7.1", "7.1.1", "7.1.2", "7.1.3"]
      - pci_dss_4.0: ["1.3.1", "7.1"]
      - soc_2: ["CC5.2", "CC6.1"]
    condition: all
    rules:
      - "c:findmnt --kernel /tmp -> r:nosuid"
	  
  # 1.1.2.1.4 Ensure noexec option set on /tmp partition. (Automated)
  - id: 31504
    title: "Ensure noexec option set on /tmp partition."
    description: "The noexec mount option specifies that the filesystem cannot contain executable binaries."
    rationale: "Since the /tmp filesystem is only intended for temporary file storage, set this option to ensure that users cannot run executable binaries from /tmp."
    remediation: "Edit the /etc/fstab file and add noexec to the fourth field (mounting options) for the /tmp partition. Example: <device> /tmp <fstype> defaults,rw,nosuid,nodev,noexec,relatime 0 0 Run the following command to remount /tmp with the configured options: # mount -o remount /tmp."
    compliance:
      - cis: ["1.1.2.1.4"]
      - cis_csc_v8: ["3.3"]
      - cis_csc_v7: ["14.6"]
      - cmmc_v2.0: ["AC.L1-3.1.1", "AC.L1-3.1.2", "AC.L2-3.1.3", "AC.L2-3.1.5", "MP.L2-3.8.2"]
      - hipaa: ["164.308(a)(3)(i)", "164.308(a)(3)(ii)(A)", "164.312(a)(1)"]
      - iso_27001-2013: ["A.9.1.1"]
      - mitre_mitigations: ["M1022"]
      - mitre_tactics: ["TA0005"]
      - mitre_techniques: ["T1204", "T1204.002"]
      - nist_sp_800-53: ["AC-3", "MP-2"]
      - pci_dss_3.2.1: ["7.1", "7.1.1", "7.1.2", "7.1.3"]
      - pci_dss_4.0: ["1.3.1", "7.1"]
      - soc_2: ["CC5.2", "CC6.1"]
    condition: all
    rules:
      - "c:findmnt --kernel /tmp -> r:noexec"
